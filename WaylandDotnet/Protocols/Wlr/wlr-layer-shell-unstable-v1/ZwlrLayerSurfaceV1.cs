// <auto-generated>
// This file was generated from wlr-layer-shell-unstable-v1.xml
// Stability: Wlr
// Link: https://wayland.app/protocols/wlr-layer-shell-unstable-v1
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.Wlr;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// zwlr_layer_surface_v1
/// <para> layer metadata interface </para>
/// <para> Version: 5 </para>
/// <see>https://wayland.app/protocols/wlr-layer-shell-unstable-v1/#zwlr_layer_surface_v1</see>
/// </summary>
public sealed partial class ZwlrLayerSurfaceV1 : WaylandObject, IWaylandObjectFactory<ZwlrLayerSurfaceV1>
{
    public const string InterfaceName = "zwlr_layer_surface_v1";
    public static string _StaticInterfaceName => "zwlr_layer_surface_v1";
    public const int InterfaceVersion = 5;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public ZwlrLayerSurfaceV1(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary> types of keyboard interaction possible for a layer shell surface </summary>
    public enum KeyboardInteractivity : uint
    {
        /// <summary>
        ///
        /// </summary>
        None = 0,
        /// <summary>
        ///
        /// </summary>
        Exclusive = 1,
        /// <summary>
        ///
        /// </summary>
        OnDemand = 2,
    }

    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// provided surface state is invalid
        /// </summary>
        InvalidSurfaceState = 0,
        /// <summary>
        /// size is invalid
        /// </summary>
        InvalidSize = 1,
        /// <summary>
        /// anchor bitfield is invalid
        /// </summary>
        InvalidAnchor = 2,
        /// <summary>
        /// keyboard interactivity is invalid
        /// </summary>
        InvalidKeyboardInteractivity = 3,
        /// <summary>
        /// exclusive edge is invalid given the surface anchors
        /// </summary>
        InvalidExclusiveEdge = 4,
    }

    /// <summary>  </summary>
    [Flags]
    public enum AnchorFlag : uint
    {
        /// <summary>
        /// the top edge of the anchor rectangle
        /// </summary>
        Top = 1,
        /// <summary>
        /// the bottom edge of the anchor rectangle
        /// </summary>
        Bottom = 2,
        /// <summary>
        /// the left edge of the anchor rectangle
        /// </summary>
        Left = 4,
        /// <summary>
        /// the right edge of the anchor rectangle
        /// </summary>
        Right = 8,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void ConfigureHandler(uint serial, uint width, uint height);

    private ConfigureHandler? _onConfigure;

    /// <summary>
    ///Suggest a surface change
    /// <para>
    ///
    ///The configure event asks the client to resize its surface.
    ///
    ///Clients should arrange their surface for the new states, and then send
    ///an ack_configure request with the serial sent in this configure event at
    ///some point before committing the new surface.
    ///
    ///The client is free to dismiss all but the last configure event it
    ///received.
    ///
    ///The width and height arguments specify the size of the window in
    ///surface-local coordinates.
    ///
    ///The size is a hint, in the sense that the client is free to ignore it if
    ///it doesn't resize, pick a smaller size (to satisfy aspect ratio or
    ///resize in steps of NxM pixels). If the client picks a smaller size and
    ///is anchored to two opposite anchors (e.g. 'top' and 'bottom'), the
    ///surface will be centered on this axis.
    ///
    ///If the width or height arguments are zero, it means the client should
    ///decide its own window dimension.
    ///
    /// </para>
    /// </summary>
    public event ConfigureHandler? OnConfigure
    {
        add
        {
            CheckDisposed();
            _onConfigure += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onConfigure -= value;
        }
    }

    public delegate void ClosedHandler();

    private ClosedHandler? _onClosed;

    /// <summary>
    ///Surface should be closed
    /// <para>
    ///
    ///The closed event is sent by the compositor when the surface will no
    ///longer be shown. The output may have been destroyed or the user may
    ///have asked for it to be removed. Further changes to the surface will be
    ///ignored. The client should destroy the resource after receiving this
    ///event, and create a new surface if they so choose.
    ///
    /// </para>
    /// </summary>
    public event ClosedHandler? OnClosed
    {
        add
        {
            CheckDisposed();
            _onClosed += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onClosed -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to zwlr_layer_surface_v1");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (ZwlrLayerSurfaceV1)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // configure
                    if (obj._onConfigure != null)
                    {
                        var _serial = args[0].u;
                        var _width = args[1].u;
                        var _height = args[2].u;
                        obj._onConfigure?.Invoke(_serial, _width, _height);
                    }
                    break;
                case 1: // closed
                    if (obj._onClosed != null)
                    {
                        obj._onClosed?.Invoke();
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Sets the size of the surface
    /// <para>
    /// <br/>
    /// Sets the size of the surface in surface-local coordinates. The<br/>
    /// compositor will display the surface centered with respect to its<br/>
    /// anchors.<br/>
    /// <br/>
    /// If you pass 0 for either value, the compositor will assign it and<br/>
    /// inform you of the assignment in the configure event. You must set your<br/>
    /// anchor to opposite edges in the dimensions you omit; not doing so is a<br/>
    /// protocol error. Both values are 0 by default.<br/>
    /// <br/>
    /// Size is double-buffered, see wl_surface.commit.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetSize(uint width, uint height)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].u = width;
        args[1].u = height;

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Configures the anchor point of the surface
    /// <para>
    /// <br/>
    /// Requests that the compositor anchor the surface to the specified edges<br/>
    /// and corners. If two orthogonal edges are specified (e.g. 'top' and<br/>
    /// 'left'), then the anchor point will be the intersection of the edges<br/>
    /// (e.g. the top left corner of the output); otherwise the anchor point<br/>
    /// will be centered on that edge, or in the center if none is specified.<br/>
    /// <br/>
    /// Anchor is double-buffered, see wl_surface.commit.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetAnchor(uint anchor)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].u = anchor;

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Configures the exclusive geometry of this surface
    /// <para>
    /// <br/>
    /// Requests that the compositor avoids occluding an area with other<br/>
    /// surfaces. The compositor's use of this information is<br/>
    /// implementation-dependent - do not assume that this region will not<br/>
    /// actually be occluded.<br/>
    /// <br/>
    /// A positive value is only meaningful if the surface is anchored to one<br/>
    /// edge or an edge and both perpendicular edges. If the surface is not<br/>
    /// anchored, anchored to only two perpendicular edges (a corner), anchored<br/>
    /// to only two parallel edges or anchored to all edges, a positive value<br/>
    /// will be treated the same as zero.<br/>
    /// <br/>
    /// A positive zone is the distance from the edge in surface-local<br/>
    /// coordinates to consider exclusive.<br/>
    /// <br/>
    /// Surfaces that do not wish to have an exclusive zone may instead specify<br/>
    /// how they should interact with surfaces that do. If set to zero, the<br/>
    /// surface indicates that it would like to be moved to avoid occluding<br/>
    /// surfaces with a positive exclusive zone. If set to -1, the surface<br/>
    /// indicates that it would not like to be moved to accommodate for other<br/>
    /// surfaces, and the compositor should extend it all the way to the edges<br/>
    /// it is anchored to.<br/>
    /// <br/>
    /// For example, a panel might set its exclusive zone to 10, so that<br/>
    /// maximized shell surfaces are not shown on top of it. A notification<br/>
    /// might set its exclusive zone to 0, so that it is moved to avoid<br/>
    /// occluding the panel, but shell surfaces are shown underneath it. A<br/>
    /// wallpaper or lock screen might set their exclusive zone to -1, so that<br/>
    /// they stretch below or over the panel.<br/>
    /// <br/>
    /// The default value is 0.<br/>
    /// <br/>
    /// Exclusive zone is double-buffered, see wl_surface.commit.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetExclusiveZone(int zone)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].i = zone;

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Sets a margin from the anchor point
    /// <para>
    /// <br/>
    /// Requests that the surface be placed some distance away from the anchor<br/>
    /// point on the output, in surface-local coordinates. Setting this value<br/>
    /// for edges you are not anchored to has no effect.<br/>
    /// <br/>
    /// The exclusive zone includes the margin.<br/>
    /// <br/>
    /// Margin is double-buffered, see wl_surface.commit.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetMargin(int top, int right, int bottom, int left)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].i = top;
        args[1].i = right;
        args[2].i = bottom;
        args[3].i = left;

        const uint opcode = 3;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Requests keyboard events
    /// <para>
    /// <br/>
    /// Set how keyboard events are delivered to this surface. By default,<br/>
    /// layer shell surfaces do not receive keyboard events; this request can<br/>
    /// be used to change this.<br/>
    /// <br/>
    /// This setting is inherited by child surfaces set by the get_popup<br/>
    /// request.<br/>
    /// <br/>
    /// Layer surfaces receive pointer, touch, and tablet events normally. If<br/>
    /// you do not want to receive them, set the input region on your surface<br/>
    /// to an empty region.<br/>
    /// <br/>
    /// Keyboard interactivity is double-buffered, see wl_surface.commit.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetKeyboardInteractivity(uint keyboardInteractivity)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].u = keyboardInteractivity;

        const uint opcode = 4;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Assign this layer_surface as an xdg_popup parent
    /// <para>
    /// <br/>
    /// This assigns an xdg_popup's parent to this layer_surface.  This popup<br/>
    /// should have been created via xdg_surface::get_popup with the parent set<br/>
    /// to NULL, and this request must be invoked before committing the popup's<br/>
    /// initial state.<br/>
    /// <br/>
    /// See the documentation of xdg_popup for more details about what an<br/>
    /// xdg_popup is and how it is used.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void GetPopup(XdgPopup popup)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)(popup?.Handle ?? IntPtr.Zero);

        const uint opcode = 5;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Ack a configure event
    /// <para>
    /// <br/>
    /// When a configure event is received, if a client commits the<br/>
    /// surface in response to the configure event, then the client<br/>
    /// must make an ack_configure request sometime before the commit<br/>
    /// request, passing along the serial of the configure event.<br/>
    /// <br/>
    /// If the client receives multiple configure events before it<br/>
    /// can respond to one, it only has to ack the last configure event.<br/>
    /// <br/>
    /// A client is not required to commit immediately after sending<br/>
    /// an ack_configure request - it may even ack_configure several times<br/>
    /// before its next surface commit.<br/>
    /// <br/>
    /// A client may send multiple ack_configure requests before committing, but<br/>
    /// only the last request sent before a commit indicates which configure<br/>
    /// event the client really is responding to.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void AckConfigure(uint serial)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].u = serial;

        const uint opcode = 6;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Destroy the layer_surface
    /// <para>
    /// <br/>
    /// This request destroys the layer surface.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 7;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Change the layer of the surface
    /// <para>
    /// <br/>
    /// Change the layer that the surface is rendered on.<br/>
    /// <br/>
    /// Layer is double-buffered, see wl_surface.commit.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetLayer(uint layer)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].u = layer;

        const uint opcode = 8;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set the edge the exclusive zone will be applied to
    /// <para>
    /// <br/>
    /// Requests an edge for the exclusive zone to apply. The exclusive<br/>
    /// edge will be automatically deduced from anchor points when possible,<br/>
    /// but when the surface is anchored to a corner, it will be necessary<br/>
    /// to set it explicitly to disambiguate, as it is not possible to deduce<br/>
    /// which one of the two corner edges should be used.<br/>
    /// <br/>
    /// The edge must be one the surface is anchored to, otherwise the<br/>
    /// invalid_exclusive_edge protocol error will be raised.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetExclusiveEdge(uint edge)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].u = edge;

        const uint opcode = 9;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static ZwlrLayerSurfaceV1 Create(nint handle, WlDisplay display)
    {
        return new ZwlrLayerSurfaceV1(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
