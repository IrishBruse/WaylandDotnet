// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_pointer
/// <para> pointer input device </para>
/// <para> Version: 10 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_pointer</see>
/// </summary>
public sealed partial class WlPointer : WaylandObject, IWaylandObjectFactory<WlPointer>
{
    public const string InterfaceName = "wl_pointer";
    public const int InterfaceVersion = 10;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public WlPointer(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// given wl_surface has another role
        /// </summary>
        Role = 0,
    }

    /// <summary> physical button state </summary>
    public enum ButtonState : uint
    {
        /// <summary>
        /// the button is not pressed
        /// </summary>
        Released = 0,
        /// <summary>
        /// the button is pressed
        /// </summary>
        Pressed = 1,
    }

    /// <summary> axis types </summary>
    public enum Axis : uint
    {
        /// <summary>
        /// vertical axis
        /// </summary>
        VerticalScroll = 0,
        /// <summary>
        /// horizontal axis
        /// </summary>
        HorizontalScroll = 1,
    }

    /// <summary> axis source types </summary>
    public enum AxisSource : uint
    {
        /// <summary>
        /// a physical wheel rotation
        /// </summary>
        Wheel = 0,
        /// <summary>
        /// finger on a touch surface
        /// </summary>
        Finger = 1,
        /// <summary>
        /// continuous coordinate space
        /// </summary>
        Continuous = 2,
        /// <summary>
        /// a physical wheel tilt
        /// </summary>
        WheelTilt = 3,
    }

    /// <summary> axis relative direction </summary>
    public enum AxisRelativeDirection : uint
    {
        /// <summary>
        /// physical motion matches axis direction
        /// </summary>
        Identical = 0,
        /// <summary>
        /// physical motion is the inverse of the axis direction
        /// </summary>
        Inverted = 1,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void EnterHandler(uint serial, WlSurface surface, WlFixed surfaceX, WlFixed surfaceY);

    private EnterHandler? _onEnter;

    public event EnterHandler? OnEnter
    {
        add
        {
            CheckDisposed();
            _onEnter += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onEnter -= value;
        }
    }

    public delegate void LeaveHandler(uint serial, WlSurface surface);

    private LeaveHandler? _onLeave;

    public event LeaveHandler? OnLeave
    {
        add
        {
            CheckDisposed();
            _onLeave += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onLeave -= value;
        }
    }

    public delegate void MotionHandler(uint time, WlFixed surfaceX, WlFixed surfaceY);

    private MotionHandler? _onMotion;

    public event MotionHandler? OnMotion
    {
        add
        {
            CheckDisposed();
            _onMotion += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onMotion -= value;
        }
    }

    public delegate void ButtonHandler(uint serial, uint time, uint button, uint state);

    private ButtonHandler? _onButton;

    public event ButtonHandler? OnButton
    {
        add
        {
            CheckDisposed();
            _onButton += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onButton -= value;
        }
    }

    public delegate void AxisHandler(uint time, uint axis, WlFixed value);

    private AxisHandler? _onAxis;

    public event AxisHandler? OnAxis
    {
        add
        {
            CheckDisposed();
            _onAxis += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAxis -= value;
        }
    }

    public delegate void FrameHandler();

    private FrameHandler? _onFrame;

    public event FrameHandler? OnFrame
    {
        add
        {
            CheckDisposed();
            _onFrame += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onFrame -= value;
        }
    }

    public delegate void AxisSourceHandler(uint axisSource);

    private AxisSourceHandler? _onAxisSource;

    public event AxisSourceHandler? OnAxisSource
    {
        add
        {
            CheckDisposed();
            _onAxisSource += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAxisSource -= value;
        }
    }

    public delegate void AxisStopHandler(uint time, uint axis);

    private AxisStopHandler? _onAxisStop;

    public event AxisStopHandler? OnAxisStop
    {
        add
        {
            CheckDisposed();
            _onAxisStop += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAxisStop -= value;
        }
    }

    public delegate void AxisDiscreteHandler(uint axis, int discrete);

    private AxisDiscreteHandler? _onAxisDiscrete;

    public event AxisDiscreteHandler? OnAxisDiscrete
    {
        add
        {
            CheckDisposed();
            _onAxisDiscrete += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAxisDiscrete -= value;
        }
    }

    public delegate void AxisValue120Handler(uint axis, int value120);

    private AxisValue120Handler? _onAxisValue120;

    public event AxisValue120Handler? OnAxisValue120
    {
        add
        {
            CheckDisposed();
            _onAxisValue120 += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAxisValue120 -= value;
        }
    }

    public delegate void AxisRelativeDirectionHandler(uint axis, uint direction);

    private AxisRelativeDirectionHandler? _onAxisRelativeDirection;

    public event AxisRelativeDirectionHandler? OnAxisRelativeDirection
    {
        add
        {
            CheckDisposed();
            _onAxisRelativeDirection += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAxisRelativeDirection -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_pointer");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlPointer)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // enter
                    if (obj._onEnter != null)
                    {
                        var _serial = args[0].u;
                        WlSurface? _surface = null;
                        if (args[1].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'surface'");
                        _surface = new WlSurface((IntPtr)args[1].o, obj.Display);
                        var _surfaceX = args[2].f;
                        var _surfaceY = args[3].f;
                        obj._onEnter?.Invoke(_serial, _surface, _surfaceX, _surfaceY);
                    }
                    break;
                case 1: // leave
                    if (obj._onLeave != null)
                    {
                        var _serial = args[0].u;
                        WlSurface? _surface = null;
                        if (args[1].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'surface'");
                        _surface = new WlSurface((IntPtr)args[1].o, obj.Display);
                        obj._onLeave?.Invoke(_serial, _surface);
                    }
                    break;
                case 2: // motion
                    if (obj._onMotion != null)
                    {
                        var _time = args[0].u;
                        var _surfaceX = args[1].f;
                        var _surfaceY = args[2].f;
                        obj._onMotion?.Invoke(_time, _surfaceX, _surfaceY);
                    }
                    break;
                case 3: // button
                    if (obj._onButton != null)
                    {
                        var _serial = args[0].u;
                        var _time = args[1].u;
                        var _button = args[2].u;
                        var _state = args[3].u;
                        obj._onButton?.Invoke(_serial, _time, _button, _state);
                    }
                    break;
                case 4: // axis
                    if (obj._onAxis != null)
                    {
                        var _time = args[0].u;
                        var _axis = args[1].u;
                        var _value = args[2].f;
                        obj._onAxis?.Invoke(_time, _axis, _value);
                    }
                    break;
                case 5: // frame
                    if (obj._onFrame != null)
                    {
                        obj._onFrame?.Invoke();
                    }
                    break;
                case 6: // axis_source
                    if (obj._onAxisSource != null)
                    {
                        var _axisSource = args[0].u;
                        obj._onAxisSource?.Invoke(_axisSource);
                    }
                    break;
                case 7: // axis_stop
                    if (obj._onAxisStop != null)
                    {
                        var _time = args[0].u;
                        var _axis = args[1].u;
                        obj._onAxisStop?.Invoke(_time, _axis);
                    }
                    break;
                case 8: // axis_discrete
                    if (obj._onAxisDiscrete != null)
                    {
                        var _axis = args[0].u;
                        var _discrete = args[1].i;
                        obj._onAxisDiscrete?.Invoke(_axis, _discrete);
                    }
                    break;
                case 9: // axis_value120
                    if (obj._onAxisValue120 != null)
                    {
                        var _axis = args[0].u;
                        var _value120 = args[1].i;
                        obj._onAxisValue120?.Invoke(_axis, _value120);
                    }
                    break;
                case 10: // axis_relative_direction
                    if (obj._onAxisRelativeDirection != null)
                    {
                        var _axis = args[0].u;
                        var _direction = args[1].u;
                        obj._onAxisRelativeDirection?.Invoke(_axis, _direction);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Set the pointer surface
    /// <para>
    /// <br/>
    /// Set the pointer surface, i.e., the surface that contains the<br/>
    /// pointer image (cursor). This request gives the surface the role<br/>
    /// of a cursor. If the surface already has another role, it raises<br/>
    /// a protocol error.<br/>
    /// <br/>
    /// The cursor actually changes only if the pointer<br/>
    /// focus for this device is one of the requesting client's surfaces<br/>
    /// or the surface parameter is the current pointer surface. If<br/>
    /// there was a previous surface set with this request it is<br/>
    /// replaced. If surface is NULL, the pointer image is hidden.<br/>
    /// <br/>
    /// The parameters hotspot_x and hotspot_y define the position of<br/>
    /// the pointer surface relative to the pointer location. Its<br/>
    /// top-left corner is always at (x, y) - (hotspot_x, hotspot_y),<br/>
    /// where (x, y) are the coordinates of the pointer location, in<br/>
    /// surface-local coordinates.<br/>
    /// <br/>
    /// On wl_surface.offset requests to the pointer surface, hotspot_x<br/>
    /// and hotspot_y are decremented by the x and y parameters<br/>
    /// passed to the request. The offset must be applied by<br/>
    /// wl_surface.commit as usual.<br/>
    /// <br/>
    /// The hotspot can also be updated by passing the currently set<br/>
    /// pointer surface to this request with new values for hotspot_x<br/>
    /// and hotspot_y.<br/>
    /// <br/>
    /// The input region is ignored for wl_surfaces with the role of<br/>
    /// a cursor. When the use as a cursor ends, the wl_surface is<br/>
    /// unmapped.<br/>
    /// <br/>
    /// The serial parameter must match the latest wl_pointer.enter<br/>
    /// serial number sent to the client. Otherwise the request will be<br/>
    /// ignored.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetCursor(uint serial, WlSurface? surface, int hotspotX, int hotspotY)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].u = serial;
        args[1].o = (WlObject*)(surface?.Handle ?? IntPtr.Zero);
        args[2].i = hotspotX;
        args[3].i = hotspotY;

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Release the pointer object
    /// <para>
    /// <br/>
    /// Using this request a client can tell the server that it is not going to<br/>
    /// use the pointer object anymore.<br/>
    /// <br/>
    /// This request destroys the pointer proxy object, so clients must not call<br/>
    /// wl_pointer_destroy() after using this request.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Release()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static WlPointer Create(nint handle, WlDisplay display)
    {
        return new WlPointer(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
