// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_pointer
/// <para> pointer input device </para>
/// <para> Version: 10 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_pointer</see>
/// </summary>
public sealed partial class WlPointer : WaylandObject, IWaylandObjectFactory<WlPointer>
{
    public const string InterfaceName = "wl_pointer";
    public static string _StaticInterfaceName => "wl_pointer";
    public const int InterfaceVersion = 10;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public WlPointer(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// given wl_surface has another role
        /// </summary>
        Role = 0,
    }

    /// <summary> physical button state </summary>
    public enum ButtonState : uint
    {
        /// <summary>
        /// the button is not pressed
        /// </summary>
        Released = 0,
        /// <summary>
        /// the button is pressed
        /// </summary>
        Pressed = 1,
    }

    /// <summary> axis types </summary>
    public enum Axis : uint
    {
        /// <summary>
        /// vertical axis
        /// </summary>
        VerticalScroll = 0,
        /// <summary>
        /// horizontal axis
        /// </summary>
        HorizontalScroll = 1,
    }

    /// <summary> axis source types </summary>
    public enum AxisSource : uint
    {
        /// <summary>
        /// a physical wheel rotation
        /// </summary>
        Wheel = 0,
        /// <summary>
        /// finger on a touch surface
        /// </summary>
        Finger = 1,
        /// <summary>
        /// continuous coordinate space
        /// </summary>
        Continuous = 2,
        /// <summary>
        /// a physical wheel tilt
        /// </summary>
        WheelTilt = 3,
    }

    /// <summary> axis relative direction </summary>
    public enum AxisRelativeDirection : uint
    {
        /// <summary>
        /// physical motion matches axis direction
        /// </summary>
        Identical = 0,
        /// <summary>
        /// physical motion is the inverse of the axis direction
        /// </summary>
        Inverted = 1,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void EnterHandler(uint serial, WlSurface surface, WlFixed surfaceX, WlFixed surfaceY);

    private EnterHandler? _onEnter;

    /// <summary>
    ///Enter event
    /// <para>
    ///
    ///Notification that this seat's pointer is focused on a certain
    ///surface.
    ///
    ///When a seat's focus enters a surface, the pointer image
    ///is undefined and a client should respond to this event by setting
    ///an appropriate pointer image with the set_cursor request.
    ///
    /// </para>
    /// </summary>
    public event EnterHandler? OnEnter
    {
        add
        {
            CheckDisposed();
            _onEnter += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onEnter -= value;
        }
    }

    public delegate void LeaveHandler(uint serial, WlSurface surface);

    private LeaveHandler? _onLeave;

    /// <summary>
    ///Leave event
    /// <para>
    ///
    ///Notification that this seat's pointer is no longer focused on
    ///a certain surface.
    ///
    ///The leave notification is sent before the enter notification
    ///for the new focus.
    ///
    /// </para>
    /// </summary>
    public event LeaveHandler? OnLeave
    {
        add
        {
            CheckDisposed();
            _onLeave += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onLeave -= value;
        }
    }

    public delegate void MotionHandler(uint time, WlFixed surfaceX, WlFixed surfaceY);

    private MotionHandler? _onMotion;

    /// <summary>
    ///Pointer motion event
    /// <para>
    ///
    ///Notification of pointer location change. The arguments
    ///surface_x and surface_y are the location relative to the
    ///focused surface.
    ///
    /// </para>
    /// </summary>
    public event MotionHandler? OnMotion
    {
        add
        {
            CheckDisposed();
            _onMotion += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onMotion -= value;
        }
    }

    public delegate void ButtonHandler(uint serial, uint time, uint button, uint state);

    private ButtonHandler? _onButton;

    /// <summary>
    ///Pointer button event
    /// <para>
    ///
    ///Mouse button click and release notifications.
    ///
    ///The location of the click is given by the last motion or
    ///enter event.
    ///The time argument is a timestamp with millisecond
    ///granularity, with an undefined base.
    ///
    ///The button is a button code as defined in the Linux kernel's
    ///linux/input-event-codes.h header file, e.g. BTN_LEFT.
    ///
    ///Any 16-bit button code value is reserved for future additions to the
    ///kernel's event code list. All other button codes above 0xFFFF are
    ///currently undefined but may be used in future versions of this
    ///protocol.
    ///
    /// </para>
    /// </summary>
    public event ButtonHandler? OnButton
    {
        add
        {
            CheckDisposed();
            _onButton += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onButton -= value;
        }
    }

    public delegate void AxisHandler(uint time, uint axis, WlFixed value);

    private AxisHandler? _onAxis;

    /// <summary>
    ///Axis event
    /// <para>
    ///
    ///Scroll and other axis notifications.
    ///
    ///For scroll events (vertical and horizontal scroll axes), the
    ///value parameter is the length of a vector along the specified
    ///axis in a coordinate space identical to those of motion events,
    ///representing a relative movement along the specified axis.
    ///
    ///For devices that support movements non-parallel to axes multiple
    ///axis events will be emitted.
    ///
    ///When applicable, for example for touch pads, the server can
    ///choose to emit scroll events where the motion vector is
    ///equivalent to a motion event vector.
    ///
    ///When applicable, a client can transform its content relative to the
    ///scroll distance.
    ///
    /// </para>
    /// </summary>
    public event AxisHandler? OnAxis
    {
        add
        {
            CheckDisposed();
            _onAxis += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAxis -= value;
        }
    }

    public delegate void FrameHandler();

    private FrameHandler? _onFrame;

    /// <summary>
    ///End of a pointer event sequence
    /// <para>
    ///
    ///Indicates the end of a set of events that logically belong together.
    ///A client is expected to accumulate the data in all events within the
    ///frame before proceeding.
    ///
    ///All wl_pointer events before a wl_pointer.frame event belong
    ///logically together. For example, in a diagonal scroll motion the
    ///compositor will send an optional wl_pointer.axis_source event, two
    ///wl_pointer.axis events (horizontal and vertical) and finally a
    ///wl_pointer.frame event. The client may use this information to
    ///calculate a diagonal vector for scrolling.
    ///
    ///When multiple wl_pointer.axis events occur within the same frame,
    ///the motion vector is the combined motion of all events.
    ///When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
    ///the same frame, this indicates that axis movement in one axis has
    ///stopped but continues in the other axis.
    ///When multiple wl_pointer.axis_stop events occur within the same
    ///frame, this indicates that these axes stopped in the same instance.
    ///
    ///A wl_pointer.frame event is sent for every logical event group,
    ///even if the group only contains a single wl_pointer event.
    ///Specifically, a client may get a sequence: motion, frame, button,
    ///frame, axis, frame, axis_stop, frame.
    ///
    ///The wl_pointer.enter and wl_pointer.leave events are logical events
    ///generated by the compositor and not the hardware. These events are
    ///also grouped by a wl_pointer.frame. When a pointer moves from one
    ///surface to another, a compositor should group the
    ///wl_pointer.leave event within the same wl_pointer.frame.
    ///However, a client must not rely on wl_pointer.leave and
    ///wl_pointer.enter being in the same wl_pointer.frame.
    ///Compositor-specific policies may require the wl_pointer.leave and
    ///wl_pointer.enter event being split across multiple wl_pointer.frame
    ///groups.
    ///
    /// </para>
    /// </summary>
    public event FrameHandler? OnFrame
    {
        add
        {
            CheckDisposed();
            _onFrame += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onFrame -= value;
        }
    }

    public delegate void AxisSourceHandler(uint axisSource);

    private AxisSourceHandler? _onAxisSource;

    /// <summary>
    ///Axis source event
    /// <para>
    ///
    ///Source information for scroll and other axes.
    ///
    ///This event does not occur on its own. It is sent before a
    ///wl_pointer.frame event and carries the source information for
    ///all events within that frame.
    ///
    ///The source specifies how this event was generated. If the source is
    ///wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
    ///sent when the user lifts the finger off the device.
    ///
    ///If the source is wl_pointer.axis_source.wheel,
    ///wl_pointer.axis_source.wheel_tilt or
    ///wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
    ///or may not be sent. Whether a compositor sends an axis_stop event
    ///for these sources is hardware-specific and implementation-dependent;
    ///clients must not rely on receiving an axis_stop event for these
    ///scroll sources and should treat scroll sequences from these scroll
    ///sources as unterminated by default.
    ///
    ///This event is optional. If the source is unknown for a particular
    ///axis event sequence, no event is sent.
    ///Only one wl_pointer.axis_source event is permitted per frame.
    ///
    ///The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
    ///not guaranteed.
    ///
    /// </para>
    /// </summary>
    public event AxisSourceHandler? OnAxisSource
    {
        add
        {
            CheckDisposed();
            _onAxisSource += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAxisSource -= value;
        }
    }

    public delegate void AxisStopHandler(uint time, uint axis);

    private AxisStopHandler? _onAxisStop;

    /// <summary>
    ///Axis stop event
    /// <para>
    ///
    ///Stop notification for scroll and other axes.
    ///
    ///For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
    ///is sent to notify a client that the axis sequence has terminated.
    ///This enables the client to implement kinetic scrolling.
    ///See the wl_pointer.axis_source documentation for information on when
    ///this event may be generated.
    ///
    ///Any wl_pointer.axis events with the same axis_source after this
    ///event should be considered as the start of a new axis motion.
    ///
    ///The timestamp is to be interpreted identical to the timestamp in the
    ///wl_pointer.axis event. The timestamp value may be the same as a
    ///preceding wl_pointer.axis event.
    ///
    /// </para>
    /// </summary>
    public event AxisStopHandler? OnAxisStop
    {
        add
        {
            CheckDisposed();
            _onAxisStop += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAxisStop -= value;
        }
    }

    public delegate void AxisDiscreteHandler(uint axis, int discrete);

    private AxisDiscreteHandler? _onAxisDiscrete;

    /// <summary>
    ///Axis click event
    /// <para>
    ///
    ///Discrete step information for scroll and other axes.
    ///
    ///This event carries the axis value of the wl_pointer.axis event in
    ///discrete steps (e.g. mouse wheel clicks).
    ///
    ///This event is deprecated with wl_pointer version 8 - this event is not
    ///sent to clients supporting version 8 or later.
    ///
    ///This event does not occur on its own, it is coupled with a
    ///wl_pointer.axis event that represents this axis value on a
    ///continuous scale. The protocol guarantees that each axis_discrete
    ///event is always followed by exactly one axis event with the same
    ///axis number within the same wl_pointer.frame. Note that the protocol
    ///allows for other events to occur between the axis_discrete and
    ///its coupled axis event, including other axis_discrete or axis
    ///events. A wl_pointer.frame must not contain more than one axis_discrete
    ///event per axis type.
    ///
    ///This event is optional; continuous scrolling devices
    ///like two-finger scrolling on touchpads do not have discrete
    ///steps and do not generate this event.
    ///
    ///The discrete value carries the directional information. e.g. a value
    ///of -2 is two steps towards the negative direction of this axis.
    ///
    ///The axis number is identical to the axis number in the associated
    ///axis event.
    ///
    ///The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
    ///not guaranteed.
    ///
    /// </para>
    /// </summary>
    public event AxisDiscreteHandler? OnAxisDiscrete
    {
        add
        {
            CheckDisposed();
            _onAxisDiscrete += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAxisDiscrete -= value;
        }
    }

    public delegate void AxisValue120Handler(uint axis, int value120);

    private AxisValue120Handler? _onAxisValue120;

    /// <summary>
    ///Axis high-resolution scroll event
    /// <para>
    ///
    ///Discrete high-resolution scroll information.
    ///
    ///This event carries high-resolution wheel scroll information,
    ///with each multiple of 120 representing one logical scroll step
    ///(a wheel detent). For example, an axis_value120 of 30 is one quarter of
    ///a logical scroll step in the positive direction, a value120 of
    ///-240 are two logical scroll steps in the negative direction within the
    ///same hardware event.
    ///Clients that rely on discrete scrolling should accumulate the
    ///value120 to multiples of 120 before processing the event.
    ///
    ///The value120 must not be zero.
    ///
    ///This event replaces the wl_pointer.axis_discrete event in clients
    ///supporting wl_pointer version 8 or later.
    ///
    ///Where a wl_pointer.axis_source event occurs in the same
    ///wl_pointer.frame, the axis source applies to this event.
    ///
    ///The order of wl_pointer.axis_value120 and wl_pointer.axis_source is
    ///not guaranteed.
    ///
    /// </para>
    /// </summary>
    public event AxisValue120Handler? OnAxisValue120
    {
        add
        {
            CheckDisposed();
            _onAxisValue120 += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAxisValue120 -= value;
        }
    }

    public delegate void AxisRelativeDirectionHandler(uint axis, uint direction);

    private AxisRelativeDirectionHandler? _onAxisRelativeDirection;

    /// <summary>
    ///Axis relative physical direction event
    /// <para>
    ///
    ///Relative directional information of the entity causing the axis
    ///motion.
    ///
    ///For a wl_pointer.axis event, the wl_pointer.axis_relative_direction
    ///event specifies the movement direction of the entity causing the
    ///wl_pointer.axis event. For example:
    ///- if a user's fingers on a touchpad move down and this
    ///causes a wl_pointer.axis vertical_scroll down event, the physical
    ///direction is 'identical'
    ///- if a user's fingers on a touchpad move down and this causes a
    ///wl_pointer.axis vertical_scroll up scroll up event ('natural
    ///scrolling'), the physical direction is 'inverted'.
    ///
    ///A client may use this information to adjust scroll motion of
    ///components. Specifically, enabling natural scrolling causes the
    ///content to change direction compared to traditional scrolling.
    ///Some widgets like volume control sliders should usually match the
    ///physical direction regardless of whether natural scrolling is
    ///active. This event enables clients to match the scroll direction of
    ///a widget to the physical direction.
    ///
    ///This event does not occur on its own, it is coupled with a
    ///wl_pointer.axis event that represents this axis value.
    ///The protocol guarantees that each axis_relative_direction event is
    ///always followed by exactly one axis event with the same
    ///axis number within the same wl_pointer.frame. Note that the protocol
    ///allows for other events to occur between the axis_relative_direction
    ///and its coupled axis event.
    ///
    ///The axis number is identical to the axis number in the associated
    ///axis event.
    ///
    ///The order of wl_pointer.axis_relative_direction,
    ///wl_pointer.axis_discrete and wl_pointer.axis_source is not
    ///guaranteed.
    ///
    /// </para>
    /// </summary>
    public event AxisRelativeDirectionHandler? OnAxisRelativeDirection
    {
        add
        {
            CheckDisposed();
            _onAxisRelativeDirection += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAxisRelativeDirection -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_pointer");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlPointer)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // enter
                    if (obj._onEnter != null)
                    {
                        var _serial = args[0].u;
                        WlSurface? _surface = null;
                        if (args[1].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'surface'");
                        _surface = new WlSurface((IntPtr)args[1].o, obj.Display);
                        var _surfaceX = args[2].f;
                        var _surfaceY = args[3].f;
                        obj._onEnter?.Invoke(_serial, _surface, _surfaceX, _surfaceY);
                    }
                    break;
                case 1: // leave
                    if (obj._onLeave != null)
                    {
                        var _serial = args[0].u;
                        WlSurface? _surface = null;
                        if (args[1].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'surface'");
                        _surface = new WlSurface((IntPtr)args[1].o, obj.Display);
                        obj._onLeave?.Invoke(_serial, _surface);
                    }
                    break;
                case 2: // motion
                    if (obj._onMotion != null)
                    {
                        var _time = args[0].u;
                        var _surfaceX = args[1].f;
                        var _surfaceY = args[2].f;
                        obj._onMotion?.Invoke(_time, _surfaceX, _surfaceY);
                    }
                    break;
                case 3: // button
                    if (obj._onButton != null)
                    {
                        var _serial = args[0].u;
                        var _time = args[1].u;
                        var _button = args[2].u;
                        var _state = args[3].u;
                        obj._onButton?.Invoke(_serial, _time, _button, _state);
                    }
                    break;
                case 4: // axis
                    if (obj._onAxis != null)
                    {
                        var _time = args[0].u;
                        var _axis = args[1].u;
                        var _value = args[2].f;
                        obj._onAxis?.Invoke(_time, _axis, _value);
                    }
                    break;
                case 5: // frame
                    if (obj._onFrame != null)
                    {
                        obj._onFrame?.Invoke();
                    }
                    break;
                case 6: // axis_source
                    if (obj._onAxisSource != null)
                    {
                        var _axisSource = args[0].u;
                        obj._onAxisSource?.Invoke(_axisSource);
                    }
                    break;
                case 7: // axis_stop
                    if (obj._onAxisStop != null)
                    {
                        var _time = args[0].u;
                        var _axis = args[1].u;
                        obj._onAxisStop?.Invoke(_time, _axis);
                    }
                    break;
                case 8: // axis_discrete
                    if (obj._onAxisDiscrete != null)
                    {
                        var _axis = args[0].u;
                        var _discrete = args[1].i;
                        obj._onAxisDiscrete?.Invoke(_axis, _discrete);
                    }
                    break;
                case 9: // axis_value120
                    if (obj._onAxisValue120 != null)
                    {
                        var _axis = args[0].u;
                        var _value120 = args[1].i;
                        obj._onAxisValue120?.Invoke(_axis, _value120);
                    }
                    break;
                case 10: // axis_relative_direction
                    if (obj._onAxisRelativeDirection != null)
                    {
                        var _axis = args[0].u;
                        var _direction = args[1].u;
                        obj._onAxisRelativeDirection?.Invoke(_axis, _direction);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Set the pointer surface
    /// <para>
    /// <br/>
    /// Set the pointer surface, i.e., the surface that contains the<br/>
    /// pointer image (cursor). This request gives the surface the role<br/>
    /// of a cursor. If the surface already has another role, it raises<br/>
    /// a protocol error.<br/>
    /// <br/>
    /// The cursor actually changes only if the pointer<br/>
    /// focus for this device is one of the requesting client's surfaces<br/>
    /// or the surface parameter is the current pointer surface. If<br/>
    /// there was a previous surface set with this request it is<br/>
    /// replaced. If surface is NULL, the pointer image is hidden.<br/>
    /// <br/>
    /// The parameters hotspot_x and hotspot_y define the position of<br/>
    /// the pointer surface relative to the pointer location. Its<br/>
    /// top-left corner is always at (x, y) - (hotspot_x, hotspot_y),<br/>
    /// where (x, y) are the coordinates of the pointer location, in<br/>
    /// surface-local coordinates.<br/>
    /// <br/>
    /// On wl_surface.offset requests to the pointer surface, hotspot_x<br/>
    /// and hotspot_y are decremented by the x and y parameters<br/>
    /// passed to the request. The offset must be applied by<br/>
    /// wl_surface.commit as usual.<br/>
    /// <br/>
    /// The hotspot can also be updated by passing the currently set<br/>
    /// pointer surface to this request with new values for hotspot_x<br/>
    /// and hotspot_y.<br/>
    /// <br/>
    /// The input region is ignored for wl_surfaces with the role of<br/>
    /// a cursor. When the use as a cursor ends, the wl_surface is<br/>
    /// unmapped.<br/>
    /// <br/>
    /// The serial parameter must match the latest wl_pointer.enter<br/>
    /// serial number sent to the client. Otherwise the request will be<br/>
    /// ignored.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetCursor(uint serial, WlSurface? surface, int hotspotX, int hotspotY)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].u = serial;
        args[1].o = (WlObject*)(surface?.Handle ?? IntPtr.Zero);
        args[2].i = hotspotX;
        args[3].i = hotspotY;

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Release the pointer object
    /// <para>
    /// <br/>
    /// Using this request a client can tell the server that it is not going to<br/>
    /// use the pointer object anymore.<br/>
    /// <br/>
    /// This request destroys the pointer proxy object, so clients must not call<br/>
    /// wl_pointer_destroy() after using this request.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Release()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static WlPointer Create(nint handle, WlDisplay display)
    {
        return new WlPointer(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
