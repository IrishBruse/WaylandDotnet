// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_shm
/// <para> shared memory support </para>
/// <para> Version: 2 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_shm</see>
/// </summary>
public sealed partial class WlShm : WaylandObject, IWaylandObjectFactory<WlShm>
{
    public const string InterfaceName = "wl_shm";
    public static string _StaticInterfaceName => "wl_shm";
    public const int InterfaceVersion = 2;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public WlShm(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    /// <summary> wl_shm error values </summary>
    public enum Error : uint
    {
        /// <summary>
        /// buffer format is not known
        /// </summary>
        InvalidFormat = 0,
        /// <summary>
        /// invalid size or stride during pool or buffer creation
        /// </summary>
        InvalidStride = 1,
        /// <summary>
        /// mmapping the file descriptor failed
        /// </summary>
        InvalidFd = 2,
    }

    /// <summary> pixel formats </summary>
    public enum Format : uint
    {
        /// <summary>
        /// 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
        /// </summary>
        Argb8888 = 0,
        /// <summary>
        /// 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
        /// </summary>
        Xrgb8888 = 1,
        /// <summary>
        /// 8-bit color index format, [7:0] C
        /// </summary>
        C8 = 0x20203843,
        /// <summary>
        /// 8-bit RGB format, [7:0] R:G:B 3:3:2
        /// </summary>
        Rgb332 = 0x38424752,
        /// <summary>
        /// 8-bit BGR format, [7:0] B:G:R 2:3:3
        /// </summary>
        Bgr233 = 0x38524742,
        /// <summary>
        /// 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
        /// </summary>
        Xrgb4444 = 0x32315258,
        /// <summary>
        /// 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
        /// </summary>
        Xbgr4444 = 0x32314258,
        /// <summary>
        /// 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
        /// </summary>
        Rgbx4444 = 0x32315852,
        /// <summary>
        /// 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
        /// </summary>
        Bgrx4444 = 0x32315842,
        /// <summary>
        /// 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
        /// </summary>
        Argb4444 = 0x32315241,
        /// <summary>
        /// 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
        /// </summary>
        Abgr4444 = 0x32314241,
        /// <summary>
        /// 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
        /// </summary>
        Rgba4444 = 0x32314152,
        /// <summary>
        /// 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
        /// </summary>
        Bgra4444 = 0x32314142,
        /// <summary>
        /// 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
        /// </summary>
        Xrgb1555 = 0x35315258,
        /// <summary>
        /// 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
        /// </summary>
        Xbgr1555 = 0x35314258,
        /// <summary>
        /// 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
        /// </summary>
        Rgbx5551 = 0x35315852,
        /// <summary>
        /// 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
        /// </summary>
        Bgrx5551 = 0x35315842,
        /// <summary>
        /// 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
        /// </summary>
        Argb1555 = 0x35315241,
        /// <summary>
        /// 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
        /// </summary>
        Abgr1555 = 0x35314241,
        /// <summary>
        /// 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
        /// </summary>
        Rgba5551 = 0x35314152,
        /// <summary>
        /// 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
        /// </summary>
        Bgra5551 = 0x35314142,
        /// <summary>
        /// 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
        /// </summary>
        Rgb565 = 0x36314752,
        /// <summary>
        /// 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
        /// </summary>
        Bgr565 = 0x36314742,
        /// <summary>
        /// 24-bit RGB format, [23:0] R:G:B little endian
        /// </summary>
        Rgb888 = 0x34324752,
        /// <summary>
        /// 24-bit BGR format, [23:0] B:G:R little endian
        /// </summary>
        Bgr888 = 0x34324742,
        /// <summary>
        /// 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
        /// </summary>
        Xbgr8888 = 0x34324258,
        /// <summary>
        /// 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
        /// </summary>
        Rgbx8888 = 0x34325852,
        /// <summary>
        /// 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
        /// </summary>
        Bgrx8888 = 0x34325842,
        /// <summary>
        /// 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
        /// </summary>
        Abgr8888 = 0x34324241,
        /// <summary>
        /// 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
        /// </summary>
        Rgba8888 = 0x34324152,
        /// <summary>
        /// 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
        /// </summary>
        Bgra8888 = 0x34324142,
        /// <summary>
        /// 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
        /// </summary>
        Xrgb2101010 = 0x30335258,
        /// <summary>
        /// 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
        /// </summary>
        Xbgr2101010 = 0x30334258,
        /// <summary>
        /// 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
        /// </summary>
        Rgbx1010102 = 0x30335852,
        /// <summary>
        /// 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
        /// </summary>
        Bgrx1010102 = 0x30335842,
        /// <summary>
        /// 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
        /// </summary>
        Argb2101010 = 0x30335241,
        /// <summary>
        /// 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
        /// </summary>
        Abgr2101010 = 0x30334241,
        /// <summary>
        /// 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
        /// </summary>
        Rgba1010102 = 0x30334152,
        /// <summary>
        /// 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
        /// </summary>
        Bgra1010102 = 0x30334142,
        /// <summary>
        /// packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
        /// </summary>
        Yuyv = 0x56595559,
        /// <summary>
        /// packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
        /// </summary>
        Yvyu = 0x55595659,
        /// <summary>
        /// packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
        /// </summary>
        Uyvy = 0x59565955,
        /// <summary>
        /// packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
        /// </summary>
        Vyuy = 0x59555956,
        /// <summary>
        /// packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
        /// </summary>
        Ayuv = 0x56555941,
        /// <summary>
        /// 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
        /// </summary>
        Nv12 = 0x3231564e,
        /// <summary>
        /// 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
        /// </summary>
        Nv21 = 0x3132564e,
        /// <summary>
        /// 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
        /// </summary>
        Nv16 = 0x3631564e,
        /// <summary>
        /// 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
        /// </summary>
        Nv61 = 0x3136564e,
        /// <summary>
        /// 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
        /// </summary>
        Yuv410 = 0x39565559,
        /// <summary>
        /// 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
        /// </summary>
        Yvu410 = 0x39555659,
        /// <summary>
        /// 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
        /// </summary>
        Yuv411 = 0x31315559,
        /// <summary>
        /// 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
        /// </summary>
        Yvu411 = 0x31315659,
        /// <summary>
        /// 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
        /// </summary>
        Yuv420 = 0x32315559,
        /// <summary>
        /// 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
        /// </summary>
        Yvu420 = 0x32315659,
        /// <summary>
        /// 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
        /// </summary>
        Yuv422 = 0x36315559,
        /// <summary>
        /// 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
        /// </summary>
        Yvu422 = 0x36315659,
        /// <summary>
        /// 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
        /// </summary>
        Yuv444 = 0x34325559,
        /// <summary>
        /// 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
        /// </summary>
        Yvu444 = 0x34325659,
        /// <summary>
        /// [7:0] R
        /// </summary>
        R8 = 0x20203852,
        /// <summary>
        /// [15:0] R little endian
        /// </summary>
        R16 = 0x20363152,
        /// <summary>
        /// [15:0] R:G 8:8 little endian
        /// </summary>
        Rg88 = 0x38384752,
        /// <summary>
        /// [15:0] G:R 8:8 little endian
        /// </summary>
        Gr88 = 0x38385247,
        /// <summary>
        /// [31:0] R:G 16:16 little endian
        /// </summary>
        Rg1616 = 0x32334752,
        /// <summary>
        /// [31:0] G:R 16:16 little endian
        /// </summary>
        Gr1616 = 0x32335247,
        /// <summary>
        /// [63:0] x:R:G:B 16:16:16:16 little endian
        /// </summary>
        Xrgb16161616f = 0x48345258,
        /// <summary>
        /// [63:0] x:B:G:R 16:16:16:16 little endian
        /// </summary>
        Xbgr16161616f = 0x48344258,
        /// <summary>
        /// [63:0] A:R:G:B 16:16:16:16 little endian
        /// </summary>
        Argb16161616f = 0x48345241,
        /// <summary>
        /// [63:0] A:B:G:R 16:16:16:16 little endian
        /// </summary>
        Abgr16161616f = 0x48344241,
        /// <summary>
        /// [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
        /// </summary>
        Xyuv8888 = 0x56555958,
        /// <summary>
        /// [23:0] Cr:Cb:Y 8:8:8 little endian
        /// </summary>
        Vuy888 = 0x34325556,
        /// <summary>
        /// Y followed by U then V, 10:10:10. Non-linear modifier only
        /// </summary>
        Vuy101010 = 0x30335556,
        /// <summary>
        /// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
        /// </summary>
        Y210 = 0x30313259,
        /// <summary>
        /// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
        /// </summary>
        Y212 = 0x32313259,
        /// <summary>
        /// [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
        /// </summary>
        Y216 = 0x36313259,
        /// <summary>
        /// [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
        /// </summary>
        Y410 = 0x30313459,
        /// <summary>
        /// [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
        /// </summary>
        Y412 = 0x32313459,
        /// <summary>
        /// [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
        /// </summary>
        Y416 = 0x36313459,
        /// <summary>
        /// [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
        /// </summary>
        Xvyu2101010 = 0x30335658,
        /// <summary>
        /// [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
        /// </summary>
        Xvyu1216161616 = 0x36335658,
        /// <summary>
        /// [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
        /// </summary>
        Xvyu16161616 = 0x38345658,
        /// <summary>
        /// [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
        /// </summary>
        Y0l0 = 0x304c3059,
        /// <summary>
        /// [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
        /// </summary>
        X0l0 = 0x304c3058,
        /// <summary>
        /// [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
        /// </summary>
        Y0l2 = 0x324c3059,
        /// <summary>
        /// [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
        /// </summary>
        X0l2 = 0x324c3058,
        /// <summary>
        ///
        /// </summary>
        Yuv4208bit = 0x38305559,
        /// <summary>
        ///
        /// </summary>
        Yuv42010bit = 0x30315559,
        /// <summary>
        ///
        /// </summary>
        Xrgb8888A8 = 0x38415258,
        /// <summary>
        ///
        /// </summary>
        Xbgr8888A8 = 0x38414258,
        /// <summary>
        ///
        /// </summary>
        Rgbx8888A8 = 0x38415852,
        /// <summary>
        ///
        /// </summary>
        Bgrx8888A8 = 0x38415842,
        /// <summary>
        ///
        /// </summary>
        Rgb888A8 = 0x38413852,
        /// <summary>
        ///
        /// </summary>
        Bgr888A8 = 0x38413842,
        /// <summary>
        ///
        /// </summary>
        Rgb565A8 = 0x38413552,
        /// <summary>
        ///
        /// </summary>
        Bgr565A8 = 0x38413542,
        /// <summary>
        /// non-subsampled Cr:Cb plane
        /// </summary>
        Nv24 = 0x3432564e,
        /// <summary>
        /// non-subsampled Cb:Cr plane
        /// </summary>
        Nv42 = 0x3234564e,
        /// <summary>
        /// 2x1 subsampled Cr:Cb plane, 10 bit per channel
        /// </summary>
        P210 = 0x30313250,
        /// <summary>
        /// 2x2 subsampled Cr:Cb plane 10 bits per channel
        /// </summary>
        P010 = 0x30313050,
        /// <summary>
        /// 2x2 subsampled Cr:Cb plane 12 bits per channel
        /// </summary>
        P012 = 0x32313050,
        /// <summary>
        /// 2x2 subsampled Cr:Cb plane 16 bits per channel
        /// </summary>
        P016 = 0x36313050,
        /// <summary>
        /// [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
        /// </summary>
        Axbxgxrx106106106106 = 0x30314241,
        /// <summary>
        /// 2x2 subsampled Cr:Cb plane
        /// </summary>
        Nv15 = 0x3531564e,
        /// <summary>
        ///
        /// </summary>
        Q410 = 0x30313451,
        /// <summary>
        ///
        /// </summary>
        Q401 = 0x31303451,
        /// <summary>
        /// [63:0] x:R:G:B 16:16:16:16 little endian
        /// </summary>
        Xrgb16161616 = 0x38345258,
        /// <summary>
        /// [63:0] x:B:G:R 16:16:16:16 little endian
        /// </summary>
        Xbgr16161616 = 0x38344258,
        /// <summary>
        /// [63:0] A:R:G:B 16:16:16:16 little endian
        /// </summary>
        Argb16161616 = 0x38345241,
        /// <summary>
        /// [63:0] A:B:G:R 16:16:16:16 little endian
        /// </summary>
        Abgr16161616 = 0x38344241,
        /// <summary>
        /// [7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte
        /// </summary>
        C1 = 0x20203143,
        /// <summary>
        /// [7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte
        /// </summary>
        C2 = 0x20203243,
        /// <summary>
        /// [7:0] C0:C1 4:4 two pixels/byte
        /// </summary>
        C4 = 0x20203443,
        /// <summary>
        /// [7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte
        /// </summary>
        D1 = 0x20203144,
        /// <summary>
        /// [7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte
        /// </summary>
        D2 = 0x20203244,
        /// <summary>
        /// [7:0] D0:D1 4:4 two pixels/byte
        /// </summary>
        D4 = 0x20203444,
        /// <summary>
        /// [7:0] D
        /// </summary>
        D8 = 0x20203844,
        /// <summary>
        /// [7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte
        /// </summary>
        R1 = 0x20203152,
        /// <summary>
        /// [7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte
        /// </summary>
        R2 = 0x20203252,
        /// <summary>
        /// [7:0] R0:R1 4:4 two pixels/byte
        /// </summary>
        R4 = 0x20203452,
        /// <summary>
        /// [15:0] x:R 6:10 little endian
        /// </summary>
        R10 = 0x20303152,
        /// <summary>
        /// [15:0] x:R 4:12 little endian
        /// </summary>
        R12 = 0x20323152,
        /// <summary>
        /// [31:0] A:Cr:Cb:Y 8:8:8:8 little endian
        /// </summary>
        Avuy8888 = 0x59555641,
        /// <summary>
        /// [31:0] X:Cr:Cb:Y 8:8:8:8 little endian
        /// </summary>
        Xvuy8888 = 0x59555658,
        /// <summary>
        /// 2x2 subsampled Cr:Cb plane 10 bits per channel packed
        /// </summary>
        P030 = 0x30333050,
        /// <summary>
        /// [47:0] R:G:B 16:16:16 little endian
        /// </summary>
        Rgb161616 = 0x38344752,
        /// <summary>
        /// [47:0] B:G:R 16:16:16 little endian
        /// </summary>
        Bgr161616 = 0x38344742,
        /// <summary>
        /// [15:0] R 16 little endian
        /// </summary>
        R16f = 0x48202052,
        /// <summary>
        /// [31:0] G:R 16:16 little endian
        /// </summary>
        Gr1616f = 0x48205247,
        /// <summary>
        /// [47:0] B:G:R 16:16:16 little endian
        /// </summary>
        Bgr161616f = 0x48524742,
        /// <summary>
        /// [31:0] R 32 little endian
        /// </summary>
        R32f = 0x46202052,
        /// <summary>
        /// [63:0] R:G 32:32 little endian
        /// </summary>
        Gr3232f = 0x46205247,
        /// <summary>
        /// [95:0] R:G:B 32:32:32 little endian
        /// </summary>
        Bgr323232f = 0x46524742,
        /// <summary>
        /// [127:0] R:G:B:A 32:32:32:32 little endian
        /// </summary>
        Abgr32323232f = 0x46384241,
        /// <summary>
        /// 2x1 subsampled Cr:Cb plane
        /// </summary>
        Nv20 = 0x3032564e,
        /// <summary>
        /// non-subsampled Cr:Cb plane
        /// </summary>
        Nv30 = 0x3033564e,
        /// <summary>
        /// 2x2 subsampled Cb (1) and Cr (2) planes 10 bits per channel
        /// </summary>
        S010 = 0x30313053,
        /// <summary>
        /// 2x1 subsampled Cb (1) and Cr (2) planes 10 bits per channel
        /// </summary>
        S210 = 0x30313253,
        /// <summary>
        /// non-subsampled Cb (1) and Cr (2) planes 10 bits per channel
        /// </summary>
        S410 = 0x30313453,
        /// <summary>
        /// 2x2 subsampled Cb (1) and Cr (2) planes 12 bits per channel
        /// </summary>
        S012 = 0x32313053,
        /// <summary>
        /// 2x1 subsampled Cb (1) and Cr (2) planes 12 bits per channel
        /// </summary>
        S212 = 0x32313253,
        /// <summary>
        /// non-subsampled Cb (1) and Cr (2) planes 12 bits per channel
        /// </summary>
        S412 = 0x32313453,
        /// <summary>
        /// 2x2 subsampled Cb (1) and Cr (2) planes 16 bits per channel
        /// </summary>
        S016 = 0x36313053,
        /// <summary>
        /// 2x1 subsampled Cb (1) and Cr (2) planes 16 bits per channel
        /// </summary>
        S216 = 0x36313253,
        /// <summary>
        /// non-subsampled Cb (1) and Cr (2) planes 16 bits per channel
        /// </summary>
        S416 = 0x36313453,
    }

    public delegate void FormatHandler(uint format);

    private FormatHandler? _onFormat;

    /// <summary>
    ///Pixel format description
    /// <para>
    ///
    ///Informs the client about a valid pixel format that
    ///can be used for buffers. Known formats include
    ///argb8888 and xrgb8888.
    ///
    /// </para>
    /// </summary>
    public event FormatHandler? OnFormat
    {
        add
        {
            CheckDisposed();
            _onFormat += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onFormat -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_shm");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlShm)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // format
                    if (obj._onFormat != null)
                    {
                        var _format = args[0].u;
                        obj._onFormat?.Invoke(_format);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    /// <summary>
    /// Create a shm pool
    /// <para>
    /// <br/>
    /// Create a new wl_shm_pool object.<br/>
    /// <br/>
    /// The pool can be used to create shared memory based buffer<br/>
    /// objects.  The server will mmap size bytes of the passed file<br/>
    /// descriptor, to use as backing memory for the pool.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe WlShmPool CreatePool(int fd, int size)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[3];
        args[0].o = (WlObject*)IntPtr.Zero;
        args[1].h = fd;
        args[2].i = size;

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.WlShmPool,
            (uint)WaylandInterfaces.WlShmPool->Version,
            0,
            (nint)args
        );

        return new WlShmPool(newProxy, Display);
    }

    /// <summary>
    /// Release the shm object
    /// <para>
    /// <br/>
    /// Using this request a client can tell the server that it is not going to<br/>
    /// use the shm object anymore.<br/>
    /// <br/>
    /// Objects created via this interface remain unaffected.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Release()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    public static WlShm Create(nint handle, WlDisplay display)
    {
        return new WlShm(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
