// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_data_source
/// <para> offer to transfer data </para>
/// <para> Version: 3 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_data_source</see>
/// </summary>
public sealed partial class WlDataSource : WaylandObject, IWaylandObjectFactory<WlDataSource>
{
    public const string InterfaceName = "wl_data_source";
    public static string _StaticInterfaceName => "wl_data_source";
    public const int InterfaceVersion = 3;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public WlDataSource(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// action mask contains invalid values
        /// </summary>
        InvalidActionMask = 0,
        /// <summary>
        /// source doesn't accept this request
        /// </summary>
        InvalidSource = 1,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void TargetHandler(string? mimeType);

    private TargetHandler? _onTarget;

    /// <summary>
    ///A target accepts an offered mime type
    /// <para>
    ///
    ///Sent when a target accepts pointer_focus or motion events.  If
    ///a target does not accept any of the offered types, type is NULL.
    ///
    ///Used for feedback during drag-and-drop.
    ///
    /// </para>
    /// </summary>
    public event TargetHandler? OnTarget
    {
        add
        {
            CheckDisposed();
            _onTarget += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onTarget -= value;
        }
    }

    public delegate void SendHandler(string mimeType, int fd);

    private SendHandler? _onSend;

    /// <summary>
    ///Send the data
    /// <para>
    ///
    ///Request for data from the client.  Send the data as the
    ///specified mime type over the passed file descriptor, then
    ///close it.
    ///
    /// </para>
    /// </summary>
    public event SendHandler? OnSend
    {
        add
        {
            CheckDisposed();
            _onSend += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onSend -= value;
        }
    }

    public delegate void CancelledHandler();

    private CancelledHandler? _onCancelled;

    /// <summary>
    ///Selection was cancelled
    /// <para>
    ///
    ///This data source is no longer valid. There are several reasons why
    ///this could happen:
    ///
    ///- The data source has been replaced by another data source.
    ///- The drag-and-drop operation was performed, but the drop destination
    ///did not accept any of the mime types offered through
    ///wl_data_source.target.
    ///- The drag-and-drop operation was performed, but the drop destination
    ///did not select any of the actions present in the mask offered through
    ///wl_data_source.action.
    ///- The drag-and-drop operation was performed but didn't happen over a
    ///surface.
    ///- The compositor cancelled the drag-and-drop operation (e.g. compositor
    ///dependent timeouts to avoid stale drag-and-drop transfers).
    ///
    ///The client should clean up and destroy this data source.
    ///
    ///For objects of version 2 or older, wl_data_source.cancelled will
    ///only be emitted if the data source was replaced by another data
    ///source.
    ///
    /// </para>
    /// </summary>
    public event CancelledHandler? OnCancelled
    {
        add
        {
            CheckDisposed();
            _onCancelled += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onCancelled -= value;
        }
    }

    public delegate void DndDropPerformedHandler();

    private DndDropPerformedHandler? _onDndDropPerformed;

    /// <summary>
    ///The drag-and-drop operation physically finished
    /// <para>
    ///
    ///The user performed the drop action. This event does not indicate
    ///acceptance, wl_data_source.cancelled may still be emitted afterwards
    ///if the drop destination does not accept any mime type.
    ///
    ///However, this event might however not be received if the compositor
    ///cancelled the drag-and-drop operation before this event could happen.
    ///
    ///Note that the data_source may still be used in the future and should
    ///not be destroyed here.
    ///
    /// </para>
    /// </summary>
    public event DndDropPerformedHandler? OnDndDropPerformed
    {
        add
        {
            CheckDisposed();
            _onDndDropPerformed += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDndDropPerformed -= value;
        }
    }

    public delegate void DndFinishedHandler();

    private DndFinishedHandler? _onDndFinished;

    /// <summary>
    ///The drag-and-drop operation concluded
    /// <para>
    ///
    ///The drop destination finished interoperating with this data
    ///source, so the client is now free to destroy this data source and
    ///free all associated data.
    ///
    ///If the action used to perform the operation was "move", the
    ///source can now delete the transferred data.
    ///
    /// </para>
    /// </summary>
    public event DndFinishedHandler? OnDndFinished
    {
        add
        {
            CheckDisposed();
            _onDndFinished += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDndFinished -= value;
        }
    }

    public delegate void ActionHandler(uint dndAction);

    private ActionHandler? _onAction;

    /// <summary>
    ///Notify the selected action
    /// <para>
    ///
    ///This event indicates the action selected by the compositor after
    ///matching the source/destination side actions. Only one action (or
    ///none) will be offered here.
    ///
    ///This event can be emitted multiple times during the drag-and-drop
    ///operation, mainly in response to destination side changes through
    ///wl_data_offer.set_actions, and as the data device enters/leaves
    ///surfaces.
    ///
    ///It is only possible to receive this event after
    ///wl_data_source.dnd_drop_performed if the drag-and-drop operation
    ///ended in an "ask" action, in which case the final wl_data_source.action
    ///event will happen immediately before wl_data_source.dnd_finished.
    ///
    ///Compositors may also change the selected action on the fly, mainly
    ///in response to keyboard modifier changes during the drag-and-drop
    ///operation.
    ///
    ///The most recent action received is always the valid one. The chosen
    ///action may change alongside negotiation (e.g. an "ask" action can turn
    ///into a "move" operation), so the effects of the final action must
    ///always be applied in wl_data_offer.dnd_finished.
    ///
    ///Clients can trigger cursor surface changes from this point, so
    ///they reflect the current action.
    ///
    /// </para>
    /// </summary>
    public event ActionHandler? OnAction
    {
        add
        {
            CheckDisposed();
            _onAction += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAction -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_data_source");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlDataSource)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // target
                    if (obj._onTarget != null)
                    {
                        var _mimeType = Utf8StringMarshaller.ConvertToManaged(args[0].s);
                        obj._onTarget?.Invoke(_mimeType);
                    }
                    break;
                case 1: // send
                    if (obj._onSend != null)
                    {
                        var _mimeType = Utf8StringMarshaller.ConvertToManaged(args[0].s);
                        var _fd = args[1].h;
                        obj._onSend?.Invoke(_mimeType, _fd);
                    }
                    break;
                case 2: // cancelled
                    if (obj._onCancelled != null)
                    {
                        obj._onCancelled?.Invoke();
                    }
                    break;
                case 3: // dnd_drop_performed
                    if (obj._onDndDropPerformed != null)
                    {
                        obj._onDndDropPerformed?.Invoke();
                    }
                    break;
                case 4: // dnd_finished
                    if (obj._onDndFinished != null)
                    {
                        obj._onDndFinished?.Invoke();
                    }
                    break;
                case 5: // action
                    if (obj._onAction != null)
                    {
                        var _dndAction = args[0].u;
                        obj._onAction?.Invoke(_dndAction);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Add an offered mime type
    /// <para>
    /// <br/>
    /// This request adds a mime type to the set of mime types<br/>
    /// advertised to targets.  Can be called several times to offer<br/>
    /// multiple types.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Offer(string mimeType)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].s = Utf8StringMarshaller.ConvertToUnmanaged(mimeType);

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Destroy the data source
    /// <para>
    /// <br/>
    /// Destroy the data source.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set the available drag-and-drop actions
    /// <para>
    /// <br/>
    /// Sets the actions that the source side client supports for this<br/>
    /// operation. This request may trigger wl_data_source.action and<br/>
    /// wl_data_offer.action events if the compositor needs to change the<br/>
    /// selected action.<br/>
    /// <br/>
    /// The dnd_actions argument must contain only values expressed in the<br/>
    /// wl_data_device_manager.dnd_actions enum, otherwise it will result<br/>
    /// in a protocol error.<br/>
    /// <br/>
    /// This request must be made once only, and can only be made on sources<br/>
    /// used in drag-and-drop, so it must be performed before<br/>
    /// wl_data_device.start_drag. Attempting to use the source other than<br/>
    /// for drag-and-drop will raise a protocol error.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetActions(uint dndActions)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].u = dndActions;

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static WlDataSource Create(nint handle, WlDisplay display)
    {
        return new WlDataSource(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
