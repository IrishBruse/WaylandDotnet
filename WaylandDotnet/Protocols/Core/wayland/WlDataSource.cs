// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_data_source
/// <para> offer to transfer data </para>
/// <para> Version: 3 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_data_source</see>
/// </summary>
public sealed partial class WlDataSource : WaylandObject, IWaylandObjectFactory<WlDataSource>
{
    public const string InterfaceName = "wl_data_source";
    public const int InterfaceVersion = 3;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public WlDataSource(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// action mask contains invalid values
        /// </summary>
        InvalidActionMask = 0,
        /// <summary>
        /// source doesn't accept this request
        /// </summary>
        InvalidSource = 1,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void TargetHandler(string? mimeType);

    private TargetHandler? _onTarget;

    public event TargetHandler? OnTarget
    {
        add
        {
            CheckDisposed();
            _onTarget += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onTarget -= value;
        }
    }

    public delegate void SendHandler(string mimeType, int fd);

    private SendHandler? _onSend;

    public event SendHandler? OnSend
    {
        add
        {
            CheckDisposed();
            _onSend += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onSend -= value;
        }
    }

    public delegate void CancelledHandler();

    private CancelledHandler? _onCancelled;

    public event CancelledHandler? OnCancelled
    {
        add
        {
            CheckDisposed();
            _onCancelled += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onCancelled -= value;
        }
    }

    public delegate void DndDropPerformedHandler();

    private DndDropPerformedHandler? _onDndDropPerformed;

    public event DndDropPerformedHandler? OnDndDropPerformed
    {
        add
        {
            CheckDisposed();
            _onDndDropPerformed += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDndDropPerformed -= value;
        }
    }

    public delegate void DndFinishedHandler();

    private DndFinishedHandler? _onDndFinished;

    public event DndFinishedHandler? OnDndFinished
    {
        add
        {
            CheckDisposed();
            _onDndFinished += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDndFinished -= value;
        }
    }

    public delegate void ActionHandler(uint dndAction);

    private ActionHandler? _onAction;

    public event ActionHandler? OnAction
    {
        add
        {
            CheckDisposed();
            _onAction += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAction -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_data_source");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlDataSource)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // target
                    if (obj._onTarget != null)
                    {
                        var _mimeType = Utf8StringMarshaller.ConvertToManaged(args[0].s);
                        obj._onTarget?.Invoke(_mimeType);
                    }
                    break;
                case 1: // send
                    if (obj._onSend != null)
                    {
                        var _mimeType = Utf8StringMarshaller.ConvertToManaged(args[0].s);
                        var _fd = args[1].h;
                        obj._onSend?.Invoke(_mimeType, _fd);
                    }
                    break;
                case 2: // cancelled
                    if (obj._onCancelled != null)
                    {
                        obj._onCancelled?.Invoke();
                    }
                    break;
                case 3: // dnd_drop_performed
                    if (obj._onDndDropPerformed != null)
                    {
                        obj._onDndDropPerformed?.Invoke();
                    }
                    break;
                case 4: // dnd_finished
                    if (obj._onDndFinished != null)
                    {
                        obj._onDndFinished?.Invoke();
                    }
                    break;
                case 5: // action
                    if (obj._onAction != null)
                    {
                        var _dndAction = args[0].u;
                        obj._onAction?.Invoke(_dndAction);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Add an offered mime type
    /// <para>
    /// <br/>
    /// This request adds a mime type to the set of mime types<br/>
    /// advertised to targets. Can be called several times to offer<br/>
    /// multiple types.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Offer(string mimeType)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].s = Utf8StringMarshaller.ConvertToUnmanaged(mimeType);

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Destroy the data source
    /// <para>
    /// <br/>
    /// Destroy the data source.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set the available drag-and-drop actions
    /// <para>
    /// <br/>
    /// Sets the actions that the source side client supports for this<br/>
    /// operation. This request may trigger wl_data_source.action and<br/>
    /// wl_data_offer.action events if the compositor needs to change the<br/>
    /// selected action.<br/>
    /// <br/>
    /// The dnd_actions argument must contain only values expressed in the<br/>
    /// wl_data_device_manager.dnd_actions enum, otherwise it will result<br/>
    /// in a protocol error.<br/>
    /// <br/>
    /// This request must be made once only, and can only be made on sources<br/>
    /// used in drag-and-drop, so it must be performed before<br/>
    /// wl_data_device.start_drag. Attempting to use the source other than<br/>
    /// for drag-and-drop will raise a protocol error.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetActions(uint dndActions)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].u = dndActions;

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static WlDataSource Create(nint handle, WlDisplay display)
    {
        return new WlDataSource(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
