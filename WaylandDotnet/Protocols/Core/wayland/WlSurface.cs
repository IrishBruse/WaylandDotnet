// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_surface
/// <para> an onscreen surface </para>
/// <para> Version: 6 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_surface</see>
/// </summary>
public sealed partial class WlSurface : WaylandObject, IWaylandObjectFactory<WlSurface>
{
    public const string InterfaceName = "wl_surface";
    public static string _StaticInterfaceName => "wl_surface";
    public const int InterfaceVersion = 6;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public WlSurface(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary> wl_surface error values </summary>
    public enum Error : uint
    {
        /// <summary>
        /// buffer scale value is invalid
        /// </summary>
        InvalidScale = 0,
        /// <summary>
        /// buffer transform value is invalid
        /// </summary>
        InvalidTransform = 1,
        /// <summary>
        /// buffer size is invalid
        /// </summary>
        InvalidSize = 2,
        /// <summary>
        /// buffer offset is invalid
        /// </summary>
        InvalidOffset = 3,
        /// <summary>
        /// surface was destroyed before its role object
        /// </summary>
        DefunctRoleObject = 4,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void EnterHandler(WlOutput output);

    private EnterHandler? _onEnter;

    /// <summary>
    ///Surface enters an output
    /// <para>
    ///
    ///This is emitted whenever a surface's creation, movement, or resizing
    ///results in some part of it being within the scanout region of an
    ///output.
    ///
    ///Note that a surface may be overlapping with zero or more outputs.
    ///
    /// </para>
    /// </summary>
    public event EnterHandler? OnEnter
    {
        add
        {
            CheckDisposed();
            _onEnter += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onEnter -= value;
        }
    }

    public delegate void LeaveHandler(WlOutput output);

    private LeaveHandler? _onLeave;

    /// <summary>
    ///Surface leaves an output
    /// <para>
    ///
    ///This is emitted whenever a surface's creation, movement, or resizing
    ///results in it no longer having any part of it within the scanout region
    ///of an output.
    ///
    ///Clients should not use the number of outputs the surface is on for frame
    ///throttling purposes. The surface might be hidden even if no leave event
    ///has been sent, and the compositor might expect new surface content
    ///updates even if no enter event has been sent. The frame event should be
    ///used instead.
    ///
    /// </para>
    /// </summary>
    public event LeaveHandler? OnLeave
    {
        add
        {
            CheckDisposed();
            _onLeave += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onLeave -= value;
        }
    }

    public delegate void PreferredBufferScaleHandler(int factor);

    private PreferredBufferScaleHandler? _onPreferredBufferScale;

    /// <summary>
    ///Preferred buffer scale for the surface
    /// <para>
    ///
    ///This event indicates the preferred buffer scale for this surface. It is
    ///sent whenever the compositor's preference changes.
    ///
    ///Before receiving this event the preferred buffer scale for this surface
    ///is 1.
    ///
    ///It is intended that scaling aware clients use this event to scale their
    ///content and use wl_surface.set_buffer_scale to indicate the scale they
    ///have rendered with. This allows clients to supply a higher detail
    ///buffer.
    ///
    ///The compositor shall emit a scale value greater than 0.
    ///
    /// </para>
    /// </summary>
    public event PreferredBufferScaleHandler? OnPreferredBufferScale
    {
        add
        {
            CheckDisposed();
            _onPreferredBufferScale += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPreferredBufferScale -= value;
        }
    }

    public delegate void PreferredBufferTransformHandler(uint transform);

    private PreferredBufferTransformHandler? _onPreferredBufferTransform;

    /// <summary>
    ///Preferred buffer transform for the surface
    /// <para>
    ///
    ///This event indicates the preferred buffer transform for this surface.
    ///It is sent whenever the compositor's preference changes.
    ///
    ///Before receiving this event the preferred buffer transform for this
    ///surface is normal.
    ///
    ///Applying this transformation to the surface buffer contents and using
    ///wl_surface.set_buffer_transform might allow the compositor to use the
    ///surface buffer more efficiently.
    ///
    /// </para>
    /// </summary>
    public event PreferredBufferTransformHandler? OnPreferredBufferTransform
    {
        add
        {
            CheckDisposed();
            _onPreferredBufferTransform += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPreferredBufferTransform -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_surface");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlSurface)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // enter
                    if (obj._onEnter != null)
                    {
                        WlOutput? _output = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'output'");
                        _output = new WlOutput((IntPtr)args[0].o, obj.Display);
                        obj._onEnter?.Invoke(_output);
                    }
                    break;
                case 1: // leave
                    if (obj._onLeave != null)
                    {
                        WlOutput? _output = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'output'");
                        _output = new WlOutput((IntPtr)args[0].o, obj.Display);
                        obj._onLeave?.Invoke(_output);
                    }
                    break;
                case 2: // preferred_buffer_scale
                    if (obj._onPreferredBufferScale != null)
                    {
                        var _factor = args[0].i;
                        obj._onPreferredBufferScale?.Invoke(_factor);
                    }
                    break;
                case 3: // preferred_buffer_transform
                    if (obj._onPreferredBufferTransform != null)
                    {
                        var _transform = args[0].u;
                        obj._onPreferredBufferTransform?.Invoke(_transform);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Delete surface
    /// <para>
    /// <br/>
    /// Deletes the surface and invalidates its object ID.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set the surface contents
    /// <para>
    /// <br/>
    /// Set a buffer as the content of this surface.<br/>
    /// <br/>
    /// The new size of the surface is calculated based on the buffer<br/>
    /// size transformed by the inverse buffer_transform and the<br/>
    /// inverse buffer_scale. This means that at commit time the supplied<br/>
    /// buffer size must be an integer multiple of the buffer_scale. If<br/>
    /// that's not the case, an invalid_size error is sent.<br/>
    /// <br/>
    /// The x and y arguments specify the location of the new pending<br/>
    /// buffer's upper left corner, relative to the current buffer's upper<br/>
    /// left corner, in surface-local coordinates. In other words, the<br/>
    /// x and y, combined with the new surface size define in which<br/>
    /// directions the surface's size changes. Setting anything other than 0<br/>
    /// as x and y arguments is discouraged, and should instead be replaced<br/>
    /// with using the separate wl_surface.offset request.<br/>
    /// <br/>
    /// When the bound wl_surface version is 5 or higher, passing any<br/>
    /// non-zero x or y is a protocol violation, and will result in an<br/>
    /// 'invalid_offset' error being raised. The x and y arguments are ignored<br/>
    /// and do not change the pending state. To achieve equivalent semantics,<br/>
    /// use wl_surface.offset.<br/>
    /// <br/>
    /// Surface contents are double-buffered state, see wl_surface.commit.<br/>
    /// <br/>
    /// The initial surface contents are void; there is no content.<br/>
    /// wl_surface.attach assigns the given wl_buffer as the pending<br/>
    /// wl_buffer. wl_surface.commit makes the pending wl_buffer the new<br/>
    /// surface contents, and the size of the surface becomes the size<br/>
    /// calculated from the wl_buffer, as described above. After commit,<br/>
    /// there is no pending buffer until the next attach.<br/>
    /// <br/>
    /// Committing a pending wl_buffer allows the compositor to read the<br/>
    /// pixels in the wl_buffer. The compositor may access the pixels at<br/>
    /// any time after the wl_surface.commit request. When the compositor<br/>
    /// will not access the pixels anymore, it will send the<br/>
    /// wl_buffer.release event. Only after receiving wl_buffer.release,<br/>
    /// the client may reuse the wl_buffer. A wl_buffer that has been<br/>
    /// attached and then replaced by another attach instead of committed<br/>
    /// will not receive a release event, and is not used by the<br/>
    /// compositor.<br/>
    /// <br/>
    /// If a pending wl_buffer has been committed to more than one wl_surface,<br/>
    /// the delivery of wl_buffer.release events becomes undefined. A well<br/>
    /// behaved client should not rely on wl_buffer.release events in this<br/>
    /// case. Alternatively, a client could create multiple wl_buffer objects<br/>
    /// from the same backing storage or use a protocol extension providing<br/>
    /// per-commit release notifications.<br/>
    /// <br/>
    /// Destroying the wl_buffer after wl_buffer.release does not change<br/>
    /// the surface contents. Destroying the wl_buffer before wl_buffer.release<br/>
    /// is allowed as long as the underlying buffer storage isn't re-used (this<br/>
    /// can happen e.g. on client process termination). However, if the client<br/>
    /// destroys the wl_buffer before receiving the wl_buffer.release event and<br/>
    /// mutates the underlying buffer storage, the surface contents become<br/>
    /// undefined immediately.<br/>
    /// <br/>
    /// If wl_surface.attach is sent with a NULL wl_buffer, the<br/>
    /// following wl_surface.commit will remove the surface content.<br/>
    /// <br/>
    /// If a pending wl_buffer has been destroyed, the result is not specified.<br/>
    /// Many compositors are known to remove the surface content on the following<br/>
    /// wl_surface.commit, but this behaviour is not universal. Clients seeking to<br/>
    /// maximise compatibility should not destroy pending buffers and should<br/>
    /// ensure that they explicitly remove content from surfaces, even after<br/>
    /// destroying buffers.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Attach(WlBuffer? buffer, int x, int y)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[3];
        args[0].o = (WlObject*)(buffer?.Handle ?? IntPtr.Zero);
        args[1].i = x;
        args[2].i = y;

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Mark part of the surface damaged
    /// <para>
    /// <br/>
    /// This request is used to describe the regions where the pending<br/>
    /// buffer is different from the current surface contents, and where<br/>
    /// the surface therefore needs to be repainted. The compositor<br/>
    /// ignores the parts of the damage that fall outside of the surface.<br/>
    /// <br/>
    /// Damage is double-buffered state, see wl_surface.commit.<br/>
    /// <br/>
    /// The damage rectangle is specified in surface-local coordinates,<br/>
    /// where x and y specify the upper left corner of the damage rectangle.<br/>
    /// <br/>
    /// The initial value for pending damage is empty: no damage.<br/>
    /// wl_surface.damage adds pending damage: the new pending damage<br/>
    /// is the union of old pending damage and the given rectangle.<br/>
    /// <br/>
    /// wl_surface.commit assigns pending damage as the current damage,<br/>
    /// and clears pending damage. The server will clear the current<br/>
    /// damage as it repaints the surface.<br/>
    /// <br/>
    /// Note! New clients should not use this request. Instead damage can be<br/>
    /// posted with wl_surface.damage_buffer which uses buffer coordinates<br/>
    /// instead of surface coordinates.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Damage(int x, int y, int width, int height)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].i = x;
        args[1].i = y;
        args[2].i = width;
        args[3].i = height;

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Request a frame throttling hint
    /// <para>
    /// <br/>
    /// Request a notification when it is a good time to start drawing a new<br/>
    /// frame, by creating a frame callback. This is useful for throttling<br/>
    /// redrawing operations, and driving animations.<br/>
    /// <br/>
    /// When a client is animating on a wl_surface, it can use the 'frame'<br/>
    /// request to get notified when it is a good time to draw and commit the<br/>
    /// next frame of animation. If the client commits an update earlier than<br/>
    /// that, it is likely that some updates will not make it to the display,<br/>
    /// and the client is wasting resources by drawing too often.<br/>
    /// <br/>
    /// The frame request will take effect on the next wl_surface.commit.<br/>
    /// The notification will only be posted for one frame unless<br/>
    /// requested again. For a wl_surface, the notifications are posted in<br/>
    /// the order the frame requests were committed.<br/>
    /// <br/>
    /// The server must send the notifications so that a client<br/>
    /// will not send excessive updates, while still allowing<br/>
    /// the highest possible update rate for clients that wait for the reply<br/>
    /// before drawing again. The server should give some time for the client<br/>
    /// to draw and commit after sending the frame callback events to let it<br/>
    /// hit the next output refresh.<br/>
    /// <br/>
    /// A server should avoid signaling the frame callbacks if the<br/>
    /// surface is not visible in any way, e.g. the surface is off-screen,<br/>
    /// or completely obscured by other opaque surfaces.<br/>
    /// <br/>
    /// The object returned by this request will be destroyed by the<br/>
    /// compositor after the callback is fired and as such the client must not<br/>
    /// attempt to use it after that point.<br/>
    /// <br/>
    /// The callback_data passed in the callback is the current time, in<br/>
    /// milliseconds, with an undefined base.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe WlCallback Frame()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)IntPtr.Zero;

        const uint opcode = 3;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.WlCallback,
            (uint)WaylandInterfaces.WlCallback->Version,
            0,
            (nint)args
        );

        return new WlCallback(newProxy, Display);
    }

    /// <summary>
    /// Set opaque region
    /// <para>
    /// <br/>
    /// This request sets the region of the surface that contains<br/>
    /// opaque content.<br/>
    /// <br/>
    /// The opaque region is an optimization hint for the compositor<br/>
    /// that lets it optimize the redrawing of content behind opaque<br/>
    /// regions.  Setting an opaque region is not required for correct<br/>
    /// behaviour, but marking transparent content as opaque will result<br/>
    /// in repaint artifacts.<br/>
    /// <br/>
    /// The opaque region is specified in surface-local coordinates.<br/>
    /// <br/>
    /// The compositor ignores the parts of the opaque region that fall<br/>
    /// outside of the surface.<br/>
    /// <br/>
    /// Opaque region is double-buffered state, see wl_surface.commit.<br/>
    /// <br/>
    /// wl_surface.set_opaque_region changes the pending opaque region.<br/>
    /// wl_surface.commit copies the pending region to the current region.<br/>
    /// Otherwise, the pending and current regions are never changed.<br/>
    /// <br/>
    /// The initial value for an opaque region is empty. Setting the pending<br/>
    /// opaque region has copy semantics, and the wl_region object can be<br/>
    /// destroyed immediately. A NULL wl_region causes the pending opaque<br/>
    /// region to be set to empty.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetOpaqueRegion(WlRegion? region)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)(region?.Handle ?? IntPtr.Zero);

        const uint opcode = 4;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set input region
    /// <para>
    /// <br/>
    /// This request sets the region of the surface that can receive<br/>
    /// pointer and touch events.<br/>
    /// <br/>
    /// Input events happening outside of this region will try the next<br/>
    /// surface in the server surface stack. The compositor ignores the<br/>
    /// parts of the input region that fall outside of the surface.<br/>
    /// <br/>
    /// The input region is specified in surface-local coordinates.<br/>
    /// <br/>
    /// Input region is double-buffered state, see wl_surface.commit.<br/>
    /// <br/>
    /// wl_surface.set_input_region changes the pending input region.<br/>
    /// wl_surface.commit copies the pending region to the current region.<br/>
    /// Otherwise the pending and current regions are never changed,<br/>
    /// except cursor and icon surfaces are special cases, see<br/>
    /// wl_pointer.set_cursor and wl_data_device.start_drag.<br/>
    /// <br/>
    /// The initial value for an input region is infinite. That means the<br/>
    /// whole surface will accept input. Setting the pending input region<br/>
    /// has copy semantics, and the wl_region object can be destroyed<br/>
    /// immediately. A NULL wl_region causes the input region to be set<br/>
    /// to infinite.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetInputRegion(WlRegion? region)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)(region?.Handle ?? IntPtr.Zero);

        const uint opcode = 5;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Commit pending surface state
    /// <para>
    /// <br/>
    /// Surface state (input, opaque, and damage regions, attached buffers,<br/>
    /// etc.) is double-buffered. Protocol requests modify the pending state,<br/>
    /// as opposed to the active state in use by the compositor.<br/>
    /// <br/>
    /// All requests that need a commit to become effective are documented<br/>
    /// to affect double-buffered state.<br/>
    /// <br/>
    /// Other interfaces may add further double-buffered surface state.<br/>
    /// <br/>
    /// A commit request atomically creates a Content Update (CU) from the<br/>
    /// pending state, even if the pending state has not been touched. The<br/>
    /// content update is placed at the end of a per-surface queue until it<br/>
    /// becomes active. After commit, the new pending state is as documented for<br/>
    /// each related request.<br/>
    /// <br/>
    /// A CU is either a Desync Content Update (DCU) or a Sync Content Update<br/>
    /// (SCU). If the surface is effectively synchronized at the commit request,<br/>
    /// it is a SCU, otherwise a DCU.<br/>
    /// <br/>
    /// When a surface transitions from effectively synchronized to effectively<br/>
    /// desynchronized, all SCUs in its queue which are not reachable by any<br/>
    /// DCU become DCUs and dependency edges from outside the queue to these CUs<br/>
    /// are removed.<br/>
    /// <br/>
    /// See wl_subsurface for the definition of 'effectively synchronized' and<br/>
    /// 'effectively desynchronized'.<br/>
    /// <br/>
    /// When a CU is placed in the queue, the CU has a dependency on the CU in<br/>
    /// front of it and to the SCU at end of the queue of every direct child<br/>
    /// surface if that SCU exists and does not have another dependent. This can<br/>
    /// form a directed acyclic graph of CUs with dependencies as edges.<br/>
    /// <br/>
    /// In addition to surface state, the CU can have constraints that must be<br/>
    /// satisfied before it can be applied. Other interfaces may add CU<br/>
    /// constraints.<br/>
    /// <br/>
    /// All DCUs which do not have a SCU in front of themselves in their queue,<br/>
    /// are candidates. If the graph that's reachable by a candidate does not<br/>
    /// have any unsatisfied constraints, the entire graph must be applied<br/>
    /// atomically.<br/>
    /// <br/>
    /// When a CU is applied, the wl_buffer is applied before all other state.<br/>
    /// This means that all coordinates in double-buffered state are relative to<br/>
    /// the newly attached wl_buffers, except for wl_surface.attach itself. If<br/>
    /// there is no newly attached wl_buffer, the coordinates are relative to<br/>
    /// the previous content update.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Commit()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 6;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Sets the buffer transformation
    /// <para>
    /// <br/>
    /// This request sets the transformation that the client has already applied<br/>
    /// to the content of the buffer. The accepted values for the transform<br/>
    /// parameter are the values for wl_output.transform.<br/>
    /// <br/>
    /// The compositor applies the inverse of this transformation whenever it<br/>
    /// uses the buffer contents.<br/>
    /// <br/>
    /// Buffer transform is double-buffered state, see wl_surface.commit.<br/>
    /// <br/>
    /// A newly created surface has its buffer transformation set to normal.<br/>
    /// <br/>
    /// wl_surface.set_buffer_transform changes the pending buffer<br/>
    /// transformation. wl_surface.commit copies the pending buffer<br/>
    /// transformation to the current one. Otherwise, the pending and current<br/>
    /// values are never changed.<br/>
    /// <br/>
    /// The purpose of this request is to allow clients to render content<br/>
    /// according to the output transform, thus permitting the compositor to<br/>
    /// use certain optimizations even if the display is rotated. Using<br/>
    /// hardware overlays and scanning out a client buffer for fullscreen<br/>
    /// surfaces are examples of such optimizations. Those optimizations are<br/>
    /// highly dependent on the compositor implementation, so the use of this<br/>
    /// request should be considered on a case-by-case basis.<br/>
    /// <br/>
    /// Note that if the transform value includes 90 or 270 degree rotation,<br/>
    /// the width of the buffer will become the surface height and the height<br/>
    /// of the buffer will become the surface width.<br/>
    /// <br/>
    /// If transform is not one of the values from the<br/>
    /// wl_output.transform enum the invalid_transform protocol error<br/>
    /// is raised.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetBufferTransform(int transform)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].i = transform;

        const uint opcode = 7;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Sets the buffer scaling factor
    /// <para>
    /// <br/>
    /// This request sets an optional scaling factor on how the compositor<br/>
    /// interprets the contents of the buffer attached to the window.<br/>
    /// <br/>
    /// Buffer scale is double-buffered state, see wl_surface.commit.<br/>
    /// <br/>
    /// A newly created surface has its buffer scale set to 1.<br/>
    /// <br/>
    /// wl_surface.set_buffer_scale changes the pending buffer scale.<br/>
    /// wl_surface.commit copies the pending buffer scale to the current one.<br/>
    /// Otherwise, the pending and current values are never changed.<br/>
    /// <br/>
    /// The purpose of this request is to allow clients to supply higher<br/>
    /// resolution buffer data for use on high resolution outputs. It is<br/>
    /// intended that you pick the same buffer scale as the scale of the<br/>
    /// output that the surface is displayed on. This means the compositor<br/>
    /// can avoid scaling when rendering the surface on that output.<br/>
    /// <br/>
    /// Note that if the scale is larger than 1, then you have to attach<br/>
    /// a buffer that is larger (by a factor of scale in each dimension)<br/>
    /// than the desired surface size.<br/>
    /// <br/>
    /// If scale is not greater than 0 the invalid_scale protocol error is<br/>
    /// raised.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetBufferScale(int scale)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].i = scale;

        const uint opcode = 8;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Mark part of the surface damaged using buffer coordinates
    /// <para>
    /// <br/>
    /// This request is used to describe the regions where the pending<br/>
    /// buffer is different from the current surface contents, and where<br/>
    /// the surface therefore needs to be repainted. The compositor<br/>
    /// ignores the parts of the damage that fall outside of the surface.<br/>
    /// <br/>
    /// Damage is double-buffered state, see wl_surface.commit.<br/>
    /// <br/>
    /// The damage rectangle is specified in buffer coordinates,<br/>
    /// where x and y specify the upper left corner of the damage rectangle.<br/>
    /// <br/>
    /// The initial value for pending damage is empty: no damage.<br/>
    /// wl_surface.damage_buffer adds pending damage: the new pending<br/>
    /// damage is the union of old pending damage and the given rectangle.<br/>
    /// <br/>
    /// wl_surface.commit assigns pending damage as the current damage,<br/>
    /// and clears pending damage. The server will clear the current<br/>
    /// damage as it repaints the surface.<br/>
    /// <br/>
    /// This request differs from wl_surface.damage in only one way - it<br/>
    /// takes damage in buffer coordinates instead of surface-local<br/>
    /// coordinates. While this generally is more intuitive than surface<br/>
    /// coordinates, it is especially desirable when using wp_viewport<br/>
    /// or when a drawing library (like EGL) is unaware of buffer scale<br/>
    /// and buffer transform.<br/>
    /// <br/>
    /// Note: Because buffer transformation changes and damage requests may<br/>
    /// be interleaved in the protocol stream, it is impossible to determine<br/>
    /// the actual mapping between surface and buffer damage until<br/>
    /// wl_surface.commit time. Therefore, compositors wishing to take both<br/>
    /// kinds of damage into account will have to accumulate damage from the<br/>
    /// two requests separately and only transform from one to the other<br/>
    /// after receiving the wl_surface.commit.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void DamageBuffer(int x, int y, int width, int height)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].i = x;
        args[1].i = y;
        args[2].i = width;
        args[3].i = height;

        const uint opcode = 9;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set the surface contents offset
    /// <para>
    /// <br/>
    /// The x and y arguments specify the location of the new pending<br/>
    /// buffer's upper left corner, relative to the current buffer's upper<br/>
    /// left corner, in surface-local coordinates. In other words, the<br/>
    /// x and y, combined with the new surface size define in which<br/>
    /// directions the surface's size changes.<br/>
    /// <br/>
    /// The exact semantics of wl_surface.offset are role-specific. Refer to<br/>
    /// the documentation of specific roles for more information.<br/>
    /// <br/>
    /// Surface location offset is double-buffered state, see<br/>
    /// wl_surface.commit.<br/>
    /// <br/>
    /// This request is semantically equivalent to and the replaces the x and y<br/>
    /// arguments in the wl_surface.attach request in wl_surface versions prior<br/>
    /// to 5. See wl_surface.attach for details.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Offset(int x, int y)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].i = x;
        args[1].i = y;

        const uint opcode = 10;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static WlSurface Create(nint handle, WlDisplay display)
    {
        return new WlSurface(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
