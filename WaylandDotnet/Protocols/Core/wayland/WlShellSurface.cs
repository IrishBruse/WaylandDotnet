// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_shell_surface
/// <para> desktop-style metadata interface </para>
/// <para> Version: 1 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_shell_surface</see>
/// </summary>
public sealed partial class WlShellSurface : WaylandObject, IWaylandObjectFactory<WlShellSurface>
{
    public const string InterfaceName = "wl_shell_surface";
    public const int InterfaceVersion = 1;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public WlShellSurface(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary> edge values for resizing </summary>
    [Flags]
    public enum ResizeFlag : uint
    {
        /// <summary>
        /// no edge
        /// </summary>
        None = 0,
        /// <summary>
        /// top edge
        /// </summary>
        Top = 1,
        /// <summary>
        /// bottom edge
        /// </summary>
        Bottom = 2,
        /// <summary>
        /// left edge
        /// </summary>
        Left = 4,
        /// <summary>
        /// top and left edges
        /// </summary>
        TopLeft = 5,
        /// <summary>
        /// bottom and left edges
        /// </summary>
        BottomLeft = 6,
        /// <summary>
        /// right edge
        /// </summary>
        Right = 8,
        /// <summary>
        /// top and right edges
        /// </summary>
        TopRight = 9,
        /// <summary>
        /// bottom and right edges
        /// </summary>
        BottomRight = 10,
    }

    /// <summary> details of transient behaviour </summary>
    [Flags]
    public enum TransientFlag : uint
    {
        /// <summary>
        /// do not set keyboard focus
        /// </summary>
        Inactive = 0x1,
    }

    /// <summary> different method to set the surface fullscreen </summary>
    public enum FullscreenMethod : uint
    {
        /// <summary>
        /// no preference, apply default policy
        /// </summary>
        Default = 0,
        /// <summary>
        /// scale, preserve the surface's aspect ratio and center on output
        /// </summary>
        Scale = 1,
        /// <summary>
        /// switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
        /// </summary>
        Driver = 2,
        /// <summary>
        /// no upscaling, center on output and add black borders to compensate size mismatch
        /// </summary>
        Fill = 3,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void PingHandler(uint serial);

    private PingHandler? _onPing;

    public event PingHandler? OnPing
    {
        add
        {
            CheckDisposed();
            _onPing += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPing -= value;
        }
    }

    public delegate void ConfigureHandler(uint edges, int width, int height);

    private ConfigureHandler? _onConfigure;

    public event ConfigureHandler? OnConfigure
    {
        add
        {
            CheckDisposed();
            _onConfigure += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onConfigure -= value;
        }
    }

    public delegate void PopupDoneHandler();

    private PopupDoneHandler? _onPopupDone;

    public event PopupDoneHandler? OnPopupDone
    {
        add
        {
            CheckDisposed();
            _onPopupDone += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPopupDone -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_shell_surface");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlShellSurface)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // ping
                    if (obj._onPing != null)
                    {
                        var _serial = args[0].u;
                        obj._onPing?.Invoke(_serial);
                    }
                    break;
                case 1: // configure
                    if (obj._onConfigure != null)
                    {
                        var _edges = args[0].u;
                        var _width = args[1].i;
                        var _height = args[2].i;
                        obj._onConfigure?.Invoke(_edges, _width, _height);
                    }
                    break;
                case 2: // popup_done
                    if (obj._onPopupDone != null)
                    {
                        obj._onPopupDone?.Invoke();
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Respond to a ping event
    /// <para>
    /// <br/>
    /// A client must respond to a ping event with a pong request or<br/>
    /// the client may be deemed unresponsive.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Pong(uint serial)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].u = serial;

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Start an interactive move
    /// <para>
    /// <br/>
    /// Start a pointer-driven move of the surface.<br/>
    /// <br/>
    /// This request must be used in response to a button press event.<br/>
    /// The server may ignore move requests depending on the state of<br/>
    /// the surface (e.g. fullscreen or maximized).<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Move(WlSeat seat, uint serial)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].o = (WlObject*)(seat?.Handle ?? IntPtr.Zero);
        args[1].u = serial;

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Start an interactive resize
    /// <para>
    /// <br/>
    /// Start a pointer-driven resizing of the surface.<br/>
    /// <br/>
    /// This request must be used in response to a button press event.<br/>
    /// The server may ignore resize requests depending on the state of<br/>
    /// the surface (e.g. fullscreen or maximized).<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Resize(WlSeat seat, uint serial, uint edges)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[3];
        args[0].o = (WlObject*)(seat?.Handle ?? IntPtr.Zero);
        args[1].u = serial;
        args[2].u = edges;

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Make the surface a toplevel surface
    /// <para>
    /// <br/>
    /// Map the surface as a toplevel surface.<br/>
    /// <br/>
    /// A toplevel surface is not fullscreen, maximized or transient.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetToplevel()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 3;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Make the surface a transient surface
    /// <para>
    /// <br/>
    /// Map the surface relative to an existing surface.<br/>
    /// <br/>
    /// The x and y arguments specify the location of the upper left<br/>
    /// corner of the surface relative to the upper left corner of the<br/>
    /// parent surface, in surface-local coordinates.<br/>
    /// <br/>
    /// The flags argument controls details of the transient behaviour.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetTransient(WlSurface parent, int x, int y, uint flags)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].o = (WlObject*)(parent?.Handle ?? IntPtr.Zero);
        args[1].i = x;
        args[2].i = y;
        args[3].u = flags;

        const uint opcode = 4;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Make the surface a fullscreen surface
    /// <para>
    /// <br/>
    /// Map the surface as a fullscreen surface.<br/>
    /// <br/>
    /// If an output parameter is given then the surface will be made<br/>
    /// fullscreen on that output. If the client does not specify the<br/>
    /// output then the compositor will apply its policy - usually<br/>
    /// choosing the output on which the surface has the biggest surface<br/>
    /// area.<br/>
    /// <br/>
    /// The client may specify a method to resolve a size conflict<br/>
    /// between the output size and the surface size - this is provided<br/>
    /// through the method parameter.<br/>
    /// <br/>
    /// The framerate parameter is used only when the method is set<br/>
    /// to "driver", to indicate the preferred framerate. A value of 0<br/>
    /// indicates that the client does not care about framerate. The<br/>
    /// framerate is specified in mHz, that is framerate of 60000 is 60Hz.<br/>
    /// <br/>
    /// A method of "scale" or "driver" implies a scaling operation of<br/>
    /// the surface, either via a direct scaling operation or a change of<br/>
    /// the output mode. This will override any kind of output scaling, so<br/>
    /// that mapping a surface with a buffer size equal to the mode can<br/>
    /// fill the screen independent of buffer_scale.<br/>
    /// <br/>
    /// A method of "fill" means we don't scale up the buffer, however<br/>
    /// any output scale is applied. This means that you may run into<br/>
    /// an edge case where the application maps a buffer with the same<br/>
    /// size of the output mode but buffer_scale 1 (thus making a<br/>
    /// surface larger than the output). In this case it is allowed to<br/>
    /// downscale the results to fit the screen.<br/>
    /// <br/>
    /// The compositor must reply to this request with a configure event<br/>
    /// with the dimensions for the output on which the surface will<br/>
    /// be made fullscreen.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetFullscreen(uint method, uint framerate, WlOutput? output)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[3];
        args[0].u = method;
        args[1].u = framerate;
        args[2].o = (WlObject*)(output?.Handle ?? IntPtr.Zero);

        const uint opcode = 5;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Make the surface a popup surface
    /// <para>
    /// <br/>
    /// Map the surface as a popup.<br/>
    /// <br/>
    /// A popup surface is a transient surface with an added pointer<br/>
    /// grab.<br/>
    /// <br/>
    /// An existing implicit grab will be changed to owner-events mode,<br/>
    /// and the popup grab will continue after the implicit grab ends<br/>
    /// (i.e. releasing the mouse button does not cause the popup to<br/>
    /// be unmapped).<br/>
    /// <br/>
    /// The popup grab continues until the window is destroyed or a<br/>
    /// mouse button is pressed in any other client's window. A click<br/>
    /// in any of the client's surfaces is reported as normal, however,<br/>
    /// clicks in other clients' surfaces will be discarded and trigger<br/>
    /// the callback.<br/>
    /// <br/>
    /// The x and y arguments specify the location of the upper left<br/>
    /// corner of the surface relative to the upper left corner of the<br/>
    /// parent surface, in surface-local coordinates.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetPopup(WlSeat seat, uint serial, WlSurface parent, int x, int y, uint flags)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[6];
        args[0].o = (WlObject*)(seat?.Handle ?? IntPtr.Zero);
        args[1].u = serial;
        args[2].o = (WlObject*)(parent?.Handle ?? IntPtr.Zero);
        args[3].i = x;
        args[4].i = y;
        args[5].u = flags;

        const uint opcode = 6;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Make the surface a maximized surface
    /// <para>
    /// <br/>
    /// Map the surface as a maximized surface.<br/>
    /// <br/>
    /// If an output parameter is given then the surface will be<br/>
    /// maximized on that output. If the client does not specify the<br/>
    /// output then the compositor will apply its policy - usually<br/>
    /// choosing the output on which the surface has the biggest surface<br/>
    /// area.<br/>
    /// <br/>
    /// The compositor will reply with a configure event telling<br/>
    /// the expected new surface size. The operation is completed<br/>
    /// on the next buffer attach to this surface.<br/>
    /// <br/>
    /// A maximized surface typically fills the entire output it is<br/>
    /// bound to, except for desktop elements such as panels. This is<br/>
    /// the main difference between a maximized shell surface and a<br/>
    /// fullscreen shell surface.<br/>
    /// <br/>
    /// The details depend on the compositor implementation.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetMaximized(WlOutput? output)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)(output?.Handle ?? IntPtr.Zero);

        const uint opcode = 7;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set surface title
    /// <para>
    /// <br/>
    /// Set a short title for the surface.<br/>
    /// <br/>
    /// This string may be used to identify the surface in a task bar,<br/>
    /// window list, or other user interface elements provided by the<br/>
    /// compositor.<br/>
    /// <br/>
    /// The string must be encoded in UTF-8.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetTitle(string title)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].s = Utf8StringMarshaller.ConvertToUnmanaged(title);

        const uint opcode = 8;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set surface class
    /// <para>
    /// <br/>
    /// Set a class for the surface.<br/>
    /// <br/>
    /// The surface class identifies the general class of applications<br/>
    /// to which the surface belongs. A common convention is to use the<br/>
    /// file name (or the full path if it is a non-standard location) of<br/>
    /// the application's .desktop file as the class.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetClass(string _class)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].s = Utf8StringMarshaller.ConvertToUnmanaged(_class);

        const uint opcode = 9;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static WlShellSurface Create(nint handle, WlDisplay display)
    {
        return new WlShellSurface(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
