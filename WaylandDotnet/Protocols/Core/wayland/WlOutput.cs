// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_output
/// <para> compositor output region </para>
/// <para> Version: 4 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_output</see>
/// </summary>
public sealed partial class WlOutput : WaylandObject, IWaylandObjectFactory<WlOutput>
{
    public const string InterfaceName = "wl_output";
    public static string _StaticInterfaceName => "wl_output";
    public const int InterfaceVersion = 4;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public WlOutput(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary> subpixel geometry information </summary>
    public enum Subpixel : uint
    {
        /// <summary>
        /// unknown geometry
        /// </summary>
        Unknown = 0,
        /// <summary>
        /// no geometry
        /// </summary>
        None = 1,
        /// <summary>
        /// horizontal RGB
        /// </summary>
        HorizontalRgb = 2,
        /// <summary>
        /// horizontal BGR
        /// </summary>
        HorizontalBgr = 3,
        /// <summary>
        /// vertical RGB
        /// </summary>
        VerticalRgb = 4,
        /// <summary>
        /// vertical BGR
        /// </summary>
        VerticalBgr = 5,
    }

    /// <summary> transformation applied to buffer contents </summary>
    public enum Transform : uint
    {
        /// <summary>
        /// no transform
        /// </summary>
        Normal = 0,
        /// <summary>
        /// 90 degrees counter-clockwise
        /// </summary>
        _90 = 1,
        /// <summary>
        /// 180 degrees counter-clockwise
        /// </summary>
        _180 = 2,
        /// <summary>
        /// 270 degrees counter-clockwise
        /// </summary>
        _270 = 3,
        /// <summary>
        /// 180 degree flip around a vertical axis
        /// </summary>
        Flipped = 4,
        /// <summary>
        /// flip and rotate 90 degrees counter-clockwise
        /// </summary>
        Flipped90 = 5,
        /// <summary>
        /// flip and rotate 180 degrees counter-clockwise
        /// </summary>
        Flipped180 = 6,
        /// <summary>
        /// flip and rotate 270 degrees counter-clockwise
        /// </summary>
        Flipped270 = 7,
    }

    /// <summary> mode information </summary>
    [Flags]
    public enum ModeFlag : uint
    {
        /// <summary>
        /// indicates this is the current mode
        /// </summary>
        Current = 0x1,
        /// <summary>
        /// indicates this is the preferred mode
        /// </summary>
        Preferred = 0x2,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void GeometryHandler(int x, int y, int physicalWidth, int physicalHeight, int subpixel, string make, string model, int transform);

    private GeometryHandler? _onGeometry;

    /// <summary>
    ///Properties of the output
    /// <para>
    ///
    ///The geometry event describes geometric properties of the output.
    ///The event is sent when binding to the output object and whenever
    ///any of the properties change.
    ///
    ///The physical size can be set to zero if it doesn't make sense for this
    ///output (e.g. for projectors or virtual outputs).
    ///
    ///The geometry event will be followed by a done event (starting from
    ///version 2).
    ///
    ///Clients should use wl_surface.preferred_buffer_transform instead of the
    ///transform advertised by this event to find the preferred buffer
    ///transform to use for a surface.
    ///
    ///Note: wl_output only advertises partial information about the output
    ///position and identification. Some compositors, for instance those not
    ///implementing a desktop-style output layout or those exposing virtual
    ///outputs, might fake this information. Instead of using x and y, clients
    ///should use xdg_output.logical_position. Instead of using make and model,
    ///clients should use name and description.
    ///
    /// </para>
    /// </summary>
    public event GeometryHandler? OnGeometry
    {
        add
        {
            CheckDisposed();
            _onGeometry += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onGeometry -= value;
        }
    }

    public delegate void ModeHandler(uint flags, int width, int height, int refresh);

    private ModeHandler? _onMode;

    /// <summary>
    ///Advertise available modes for the output
    /// <para>
    ///
    ///The mode event describes an available mode for the output.
    ///
    ///The event is sent when binding to the output object and there
    ///will always be one mode, the current mode.  The event is sent
    ///again if an output changes mode, for the mode that is now
    ///current.  In other words, the current mode is always the last
    ///mode that was received with the current flag set.
    ///
    ///Non-current modes are deprecated. A compositor can decide to only
    ///advertise the current mode and never send other modes. Clients
    ///should not rely on non-current modes.
    ///
    ///The size of a mode is given in physical hardware units of
    ///the output device. This is not necessarily the same as
    ///the output size in the global compositor space. For instance,
    ///the output may be scaled, as described in wl_output.scale,
    ///or transformed, as described in wl_output.transform. Clients
    ///willing to retrieve the output size in the global compositor
    ///space should use xdg_output.logical_size instead.
    ///
    ///The vertical refresh rate can be set to zero if it doesn't make
    ///sense for this output (e.g. for virtual outputs).
    ///
    ///The mode event will be followed by a done event (starting from
    ///version 2).
    ///
    ///Clients should not use the refresh rate to schedule frames. Instead,
    ///they should use the wl_surface.frame event or the presentation-time
    ///protocol.
    ///
    ///Note: this information is not always meaningful for all outputs. Some
    ///compositors, such as those exposing virtual outputs, might fake the
    ///refresh rate or the size.
    ///
    /// </para>
    /// </summary>
    public event ModeHandler? OnMode
    {
        add
        {
            CheckDisposed();
            _onMode += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onMode -= value;
        }
    }

    public delegate void DoneHandler();

    private DoneHandler? _onDone;

    /// <summary>
    ///Sent all information about output
    /// <para>
    ///
    ///This event is sent after all other properties have been
    ///sent after binding to the output object and after any
    ///other property changes done after that. This allows
    ///changes to the output properties to be seen as
    ///atomic, even if they happen via multiple events.
    ///
    /// </para>
    /// </summary>
    public event DoneHandler? OnDone
    {
        add
        {
            CheckDisposed();
            _onDone += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDone -= value;
        }
    }

    public delegate void ScaleHandler(int factor);

    private ScaleHandler? _onScale;

    /// <summary>
    ///Output scaling properties
    /// <para>
    ///
    ///This event contains scaling geometry information
    ///that is not in the geometry event. It may be sent after
    ///binding the output object or if the output scale changes
    ///later. The compositor will emit a non-zero, positive
    ///value for scale. If it is not sent, the client should
    ///assume a scale of 1.
    ///
    ///A scale larger than 1 means that the compositor will
    ///automatically scale surface buffers by this amount
    ///when rendering. This is used for very high resolution
    ///displays where applications rendering at the native
    ///resolution would be too small to be legible.
    ///
    ///Clients should use wl_surface.preferred_buffer_scale
    ///instead of this event to find the preferred buffer
    ///scale to use for a surface.
    ///
    ///The scale event will be followed by a done event.
    ///
    /// </para>
    /// </summary>
    public event ScaleHandler? OnScale
    {
        add
        {
            CheckDisposed();
            _onScale += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onScale -= value;
        }
    }

    public delegate void NameHandler(string name);

    private NameHandler? _onName;

    /// <summary>
    ///Name of this output
    /// <para>
    ///
    ///Many compositors will assign user-friendly names to their outputs, show
    ///them to the user, allow the user to refer to an output, etc. The client
    ///may wish to know this name as well to offer the user similar behaviors.
    ///
    ///The name is a UTF-8 string with no convention defined for its contents.
    ///Each name is unique among all wl_output globals. The name is only
    ///guaranteed to be unique for the compositor instance.
    ///
    ///The same output name is used for all clients for a given wl_output
    ///global. Thus, the name can be shared across processes to refer to a
    ///specific wl_output global.
    ///
    ///The name is not guaranteed to be persistent across sessions, thus cannot
    ///be used to reliably identify an output in e.g. configuration files.
    ///
    ///Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
    ///not assume that the name is a reflection of an underlying DRM connector,
    ///X11 connection, etc.
    ///
    ///The name event is sent after binding the output object. This event is
    ///only sent once per output object, and the name does not change over the
    ///lifetime of the wl_output global.
    ///
    ///Compositors may re-use the same output name if the wl_output global is
    ///destroyed and re-created later. Compositors should avoid re-using the
    ///same name if possible.
    ///
    ///The name event will be followed by a done event.
    ///
    /// </para>
    /// </summary>
    public event NameHandler? OnName
    {
        add
        {
            CheckDisposed();
            _onName += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onName -= value;
        }
    }

    public delegate void DescriptionHandler(string description);

    private DescriptionHandler? _onDescription;

    /// <summary>
    ///Human-readable description of this output
    /// <para>
    ///
    ///Many compositors can produce human-readable descriptions of their
    ///outputs. The client may wish to know this description as well, e.g. for
    ///output selection purposes.
    ///
    ///The description is a UTF-8 string with no convention defined for its
    ///contents. The description is not guaranteed to be unique among all
    ///wl_output globals. Examples might include 'Foocorp 11" Display' or
    ///'Virtual X11 output via :1'.
    ///
    ///The description event is sent after binding the output object and
    ///whenever the description changes. The description is optional, and may
    ///not be sent at all.
    ///
    ///The description event will be followed by a done event.
    ///
    /// </para>
    /// </summary>
    public event DescriptionHandler? OnDescription
    {
        add
        {
            CheckDisposed();
            _onDescription += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDescription -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_output");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlOutput)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // geometry
                    if (obj._onGeometry != null)
                    {
                        var _x = args[0].i;
                        var _y = args[1].i;
                        var _physicalWidth = args[2].i;
                        var _physicalHeight = args[3].i;
                        var _subpixel = args[4].i;
                        var _make = Utf8StringMarshaller.ConvertToManaged(args[5].s);
                        var _model = Utf8StringMarshaller.ConvertToManaged(args[6].s);
                        var _transform = args[7].i;
                        obj._onGeometry?.Invoke(_x, _y, _physicalWidth, _physicalHeight, _subpixel, _make, _model, _transform);
                    }
                    break;
                case 1: // mode
                    if (obj._onMode != null)
                    {
                        var _flags = args[0].u;
                        var _width = args[1].i;
                        var _height = args[2].i;
                        var _refresh = args[3].i;
                        obj._onMode?.Invoke(_flags, _width, _height, _refresh);
                    }
                    break;
                case 2: // done
                    if (obj._onDone != null)
                    {
                        obj._onDone?.Invoke();
                    }
                    break;
                case 3: // scale
                    if (obj._onScale != null)
                    {
                        var _factor = args[0].i;
                        obj._onScale?.Invoke(_factor);
                    }
                    break;
                case 4: // name
                    if (obj._onName != null)
                    {
                        var _name = Utf8StringMarshaller.ConvertToManaged(args[0].s);
                        obj._onName?.Invoke(_name);
                    }
                    break;
                case 5: // description
                    if (obj._onDescription != null)
                    {
                        var _description = Utf8StringMarshaller.ConvertToManaged(args[0].s);
                        obj._onDescription?.Invoke(_description);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Release the output object
    /// <para>
    /// <br/>
    /// Using this request a client can tell the server that it is not going to<br/>
    /// use the output object anymore.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Release()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static WlOutput Create(nint handle, WlDisplay display)
    {
        return new WlOutput(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
