// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_touch
/// <para> touchscreen input device </para>
/// <para> Version: 10 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_touch</see>
/// </summary>
public sealed partial class WlTouch : WaylandObject, IWaylandObjectFactory<WlTouch>
{
    public const string InterfaceName = "wl_touch";
    public static string _StaticInterfaceName => "wl_touch";
    public const int InterfaceVersion = 10;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public WlTouch(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEventDelegates

    public delegate void DownHandler(uint serial, uint time, WlSurface surface, int id, WlFixed x, WlFixed y);

    private DownHandler? _onDown;

    /// <summary>
    ///Touch down event and beginning of a touch sequence
    /// <para>
    ///
    ///A new touch point has appeared on the surface. This touch point is
    ///assigned a unique ID. Future events from this touch point reference
    ///this ID. The ID ceases to be valid after a touch up event and may be
    ///reused in the future.
    ///
    /// </para>
    /// </summary>
    public event DownHandler? OnDown
    {
        add
        {
            CheckDisposed();
            _onDown += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDown -= value;
        }
    }

    public delegate void UpHandler(uint serial, uint time, int id);

    private UpHandler? _onUp;

    /// <summary>
    ///End of a touch event sequence
    /// <para>
    ///
    ///The touch point has disappeared. No further events will be sent for
    ///this touch point and the touch point's ID is released and may be
    ///reused in a future touch down event.
    ///
    /// </para>
    /// </summary>
    public event UpHandler? OnUp
    {
        add
        {
            CheckDisposed();
            _onUp += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onUp -= value;
        }
    }

    public delegate void MotionHandler(uint time, int id, WlFixed x, WlFixed y);

    private MotionHandler? _onMotion;

    /// <summary>
    ///Update of touch point coordinates
    /// <para>
    ///
    ///A touch point has changed coordinates.
    ///
    /// </para>
    /// </summary>
    public event MotionHandler? OnMotion
    {
        add
        {
            CheckDisposed();
            _onMotion += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onMotion -= value;
        }
    }

    public delegate void FrameHandler();

    private FrameHandler? _onFrame;

    /// <summary>
    ///End of touch frame event
    /// <para>
    ///
    ///Indicates the end of a set of events that logically belong together.
    ///A client is expected to accumulate the data in all events within the
    ///frame before proceeding.
    ///
    ///A wl_touch.frame terminates at least one event but otherwise no
    ///guarantee is provided about the set of events within a frame. A client
    ///must assume that any state not updated in a frame is unchanged from the
    ///previously known state.
    ///
    /// </para>
    /// </summary>
    public event FrameHandler? OnFrame
    {
        add
        {
            CheckDisposed();
            _onFrame += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onFrame -= value;
        }
    }

    public delegate void CancelHandler();

    private CancelHandler? _onCancel;

    /// <summary>
    ///Touch session cancelled
    /// <para>
    ///
    ///Sent if the compositor decides the touch stream is a global
    ///gesture. No further events are sent to the clients from that
    ///particular gesture. Touch cancellation applies to all touch points
    ///currently active on this client's surface. The client is
    ///responsible for finalizing the touch points, future touch points on
    ///this surface may reuse the touch point ID.
    ///
    ///No frame event is required after the cancel event.
    ///
    /// </para>
    /// </summary>
    public event CancelHandler? OnCancel
    {
        add
        {
            CheckDisposed();
            _onCancel += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onCancel -= value;
        }
    }

    public delegate void ShapeHandler(int id, WlFixed major, WlFixed minor);

    private ShapeHandler? _onShape;

    /// <summary>
    ///Update shape of touch point
    /// <para>
    ///
    ///Sent when a touchpoint has changed its shape.
    ///
    ///This event does not occur on its own. It is sent before a
    ///wl_touch.frame event and carries the new shape information for
    ///any previously reported, or new touch points of that frame.
    ///
    ///Other events describing the touch point such as wl_touch.down,
    ///wl_touch.motion or wl_touch.orientation may be sent within the
    ///same wl_touch.frame. A client should treat these events as a single
    ///logical touch point update. The order of wl_touch.shape,
    ///wl_touch.orientation and wl_touch.motion is not guaranteed.
    ///A wl_touch.down event is guaranteed to occur before the first
    ///wl_touch.shape event for this touch ID but both events may occur within
    ///the same wl_touch.frame.
    ///
    ///A touchpoint shape is approximated by an ellipse through the major and
    ///minor axis length. The major axis length describes the longer diameter
    ///of the ellipse, while the minor axis length describes the shorter
    ///diameter. Major and minor are orthogonal and both are specified in
    ///surface-local coordinates. The center of the ellipse is always at the
    ///touchpoint location as reported by wl_touch.down or wl_touch.move.
    ///
    ///This event is only sent by the compositor if the touch device supports
    ///shape reports. The client has to make reasonable assumptions about the
    ///shape if it did not receive this event.
    ///
    /// </para>
    /// </summary>
    public event ShapeHandler? OnShape
    {
        add
        {
            CheckDisposed();
            _onShape += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onShape -= value;
        }
    }

    public delegate void OrientationHandler(int id, WlFixed orientation);

    private OrientationHandler? _onOrientation;

    /// <summary>
    ///Update orientation of touch point
    /// <para>
    ///
    ///Sent when a touchpoint has changed its orientation.
    ///
    ///This event does not occur on its own. It is sent before a
    ///wl_touch.frame event and carries the new shape information for
    ///any previously reported, or new touch points of that frame.
    ///
    ///Other events describing the touch point such as wl_touch.down,
    ///wl_touch.motion or wl_touch.shape may be sent within the
    ///same wl_touch.frame. A client should treat these events as a single
    ///logical touch point update. The order of wl_touch.shape,
    ///wl_touch.orientation and wl_touch.motion is not guaranteed.
    ///A wl_touch.down event is guaranteed to occur before the first
    ///wl_touch.orientation event for this touch ID but both events may occur
    ///within the same wl_touch.frame.
    ///
    ///The orientation describes the clockwise angle of a touchpoint's major
    ///axis to the positive surface y-axis and is normalized to the -180 to
    ///+180 degree range. The granularity of orientation depends on the touch
    ///device, some devices only support binary rotation values between 0 and
    ///90 degrees.
    ///
    ///This event is only sent by the compositor if the touch device supports
    ///orientation reports.
    ///
    /// </para>
    /// </summary>
    public event OrientationHandler? OnOrientation
    {
        add
        {
            CheckDisposed();
            _onOrientation += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onOrientation -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_touch");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlTouch)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // down
                    if (obj._onDown != null)
                    {
                        var _serial = args[0].u;
                        var _time = args[1].u;
                        WlSurface? _surface = null;
                        if (args[2].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'surface'");
                        _surface = new WlSurface((IntPtr)args[2].o, obj.Display);
                        var _id = args[3].i;
                        var _x = args[4].f;
                        var _y = args[5].f;
                        obj._onDown?.Invoke(_serial, _time, _surface, _id, _x, _y);
                    }
                    break;
                case 1: // up
                    if (obj._onUp != null)
                    {
                        var _serial = args[0].u;
                        var _time = args[1].u;
                        var _id = args[2].i;
                        obj._onUp?.Invoke(_serial, _time, _id);
                    }
                    break;
                case 2: // motion
                    if (obj._onMotion != null)
                    {
                        var _time = args[0].u;
                        var _id = args[1].i;
                        var _x = args[2].f;
                        var _y = args[3].f;
                        obj._onMotion?.Invoke(_time, _id, _x, _y);
                    }
                    break;
                case 3: // frame
                    if (obj._onFrame != null)
                    {
                        obj._onFrame?.Invoke();
                    }
                    break;
                case 4: // cancel
                    if (obj._onCancel != null)
                    {
                        obj._onCancel?.Invoke();
                    }
                    break;
                case 5: // shape
                    if (obj._onShape != null)
                    {
                        var _id = args[0].i;
                        var _major = args[1].f;
                        var _minor = args[2].f;
                        obj._onShape?.Invoke(_id, _major, _minor);
                    }
                    break;
                case 6: // orientation
                    if (obj._onOrientation != null)
                    {
                        var _id = args[0].i;
                        var _orientation = args[1].f;
                        obj._onOrientation?.Invoke(_id, _orientation);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Release the touch object
    /// <para>
    /// release<br/>
    /// </para>
    /// </summary>
    public unsafe void Release()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static WlTouch Create(nint handle, WlDisplay display)
    {
        return new WlTouch(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
