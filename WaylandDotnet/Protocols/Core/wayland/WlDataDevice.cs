// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_data_device
/// <para> data transfer device </para>
/// <para> Version: 3 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_data_device</see>
/// </summary>
public sealed partial class WlDataDevice : WaylandObject, IWaylandObjectFactory<WlDataDevice>
{
    public const string InterfaceName = "wl_data_device";
    public static string _StaticInterfaceName => "wl_data_device";
    public const int InterfaceVersion = 3;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public WlDataDevice(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// given wl_surface has another role
        /// </summary>
        Role = 0,
        /// <summary>
        /// source has already been used
        /// </summary>
        UsedSource = 1,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void DataOfferHandler(WlDataOffer id);

    private DataOfferHandler? _onDataOffer;

    /// <summary>
    ///Introduce a new wl_data_offer
    /// <para>
    ///
    ///The data_offer event introduces a new wl_data_offer object,
    ///which will subsequently be used in either the
    ///data_device.enter event (for drag-and-drop) or the
    ///data_device.selection event (for selections).  Immediately
    ///following the data_device.data_offer event, the new data_offer
    ///object will send out data_offer.offer events to describe the
    ///mime types it offers.
    ///
    /// </para>
    /// </summary>
    public event DataOfferHandler? OnDataOffer
    {
        add
        {
            CheckDisposed();
            _onDataOffer += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDataOffer -= value;
        }
    }

    public delegate void EnterHandler(uint serial, WlSurface surface, WlFixed x, WlFixed y, WlDataOffer? id);

    private EnterHandler? _onEnter;

    /// <summary>
    ///Initiate drag-and-drop session
    /// <para>
    ///
    ///This event is sent when an active drag-and-drop pointer enters
    ///a surface owned by the client.  The position of the pointer at
    ///enter time is provided by the x and y arguments, in surface-local
    ///coordinates.
    ///
    /// </para>
    /// </summary>
    public event EnterHandler? OnEnter
    {
        add
        {
            CheckDisposed();
            _onEnter += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onEnter -= value;
        }
    }

    public delegate void LeaveHandler();

    private LeaveHandler? _onLeave;

    /// <summary>
    ///End drag-and-drop session
    /// <para>
    ///
    ///This event is sent when the drag-and-drop pointer leaves the
    ///surface and the session ends.  The client must destroy the
    ///wl_data_offer introduced at enter time at this point.
    ///
    /// </para>
    /// </summary>
    public event LeaveHandler? OnLeave
    {
        add
        {
            CheckDisposed();
            _onLeave += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onLeave -= value;
        }
    }

    public delegate void MotionHandler(uint time, WlFixed x, WlFixed y);

    private MotionHandler? _onMotion;

    /// <summary>
    ///Drag-and-drop session motion
    /// <para>
    ///
    ///This event is sent when the drag-and-drop pointer moves within
    ///the currently focused surface. The new position of the pointer
    ///is provided by the x and y arguments, in surface-local
    ///coordinates.
    ///
    /// </para>
    /// </summary>
    public event MotionHandler? OnMotion
    {
        add
        {
            CheckDisposed();
            _onMotion += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onMotion -= value;
        }
    }

    public delegate void DropHandler();

    private DropHandler? _onDrop;

    /// <summary>
    ///End drag-and-drop session successfully
    /// <para>
    ///
    ///The event is sent when a drag-and-drop operation is ended
    ///because the implicit grab is removed.
    ///
    ///The drag-and-drop destination is expected to honor the last action
    ///received through wl_data_offer.action, if the resulting action is
    ///"copy" or "move", the destination can still perform
    ///wl_data_offer.receive requests, and is expected to end all
    ///transfers with a wl_data_offer.finish request.
    ///
    ///If the resulting action is "ask", the action will not be considered
    ///final. The drag-and-drop destination is expected to perform one last
    ///wl_data_offer.set_actions request, or wl_data_offer.destroy in order
    ///to cancel the operation.
    ///
    /// </para>
    /// </summary>
    public event DropHandler? OnDrop
    {
        add
        {
            CheckDisposed();
            _onDrop += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDrop -= value;
        }
    }

    public delegate void SelectionHandler(WlDataOffer? id);

    private SelectionHandler? _onSelection;

    /// <summary>
    ///Advertise new selection
    /// <para>
    ///
    ///The selection event is sent out to notify the client of a new
    ///wl_data_offer for the selection for this device.  The
    ///data_device.data_offer and the data_offer.offer events are
    ///sent out immediately before this event to introduce the data
    ///offer object.  The selection event is sent to a client
    ///immediately before receiving keyboard focus and when a new
    ///selection is set while the client has keyboard focus.  The
    ///data_offer is valid until a new data_offer or NULL is received
    ///or until the client loses keyboard focus.  Switching surface with
    ///keyboard focus within the same client doesn't mean a new selection
    ///will be sent.  The client must destroy the previous selection
    ///data_offer, if any, upon receiving this event.
    ///
    /// </para>
    /// </summary>
    public event SelectionHandler? OnSelection
    {
        add
        {
            CheckDisposed();
            _onSelection += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onSelection -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_data_device");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlDataDevice)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // data_offer
                    if (obj._onDataOffer != null)
                    {
                        WlDataOffer? _id = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'id'");
                        _id = new WlDataOffer((IntPtr)args[0].o, obj.Display);
                        obj._onDataOffer?.Invoke(_id);
                    }
                    break;
                case 1: // enter
                    if (obj._onEnter != null)
                    {
                        var _serial = args[0].u;
                        WlSurface? _surface = null;
                        if (args[1].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'surface'");
                        _surface = new WlSurface((IntPtr)args[1].o, obj.Display);
                        var _x = args[2].f;
                        var _y = args[3].f;
                        WlDataOffer? _id = null;
                        if (args[4].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'id'");
                        _id = new WlDataOffer((IntPtr)args[4].o, obj.Display);
                        obj._onEnter?.Invoke(_serial, _surface, _x, _y, _id);
                    }
                    break;
                case 2: // leave
                    if (obj._onLeave != null)
                    {
                        obj._onLeave?.Invoke();
                    }
                    break;
                case 3: // motion
                    if (obj._onMotion != null)
                    {
                        var _time = args[0].u;
                        var _x = args[1].f;
                        var _y = args[2].f;
                        obj._onMotion?.Invoke(_time, _x, _y);
                    }
                    break;
                case 4: // drop
                    if (obj._onDrop != null)
                    {
                        obj._onDrop?.Invoke();
                    }
                    break;
                case 5: // selection
                    if (obj._onSelection != null)
                    {
                        WlDataOffer? _id = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'id'");
                        _id = new WlDataOffer((IntPtr)args[0].o, obj.Display);
                        obj._onSelection?.Invoke(_id);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Start drag-and-drop operation
    /// <para>
    /// <br/>
    /// This request asks the compositor to start a drag-and-drop<br/>
    /// operation on behalf of the client.<br/>
    /// <br/>
    /// The source argument is the data source that provides the data<br/>
    /// for the eventual data transfer. If source is NULL, enter, leave<br/>
    /// and motion events are sent only to the client that initiated the<br/>
    /// drag and the client is expected to handle the data passing<br/>
    /// internally. If source is destroyed, the drag-and-drop session will be<br/>
    /// cancelled.<br/>
    /// <br/>
    /// The origin surface is the surface where the drag originates and<br/>
    /// the client must have an active implicit grab that matches the<br/>
    /// serial.<br/>
    /// <br/>
    /// The icon surface is an optional (can be NULL) surface that<br/>
    /// provides an icon to be moved around with the cursor.  Initially,<br/>
    /// the top-left corner of the icon surface is placed at the cursor<br/>
    /// hotspot, but subsequent wl_surface.offset requests can move the<br/>
    /// relative position. Attach requests must be confirmed with<br/>
    /// wl_surface.commit as usual. The icon surface is given the role of<br/>
    /// a drag-and-drop icon. If the icon surface already has another role,<br/>
    /// it raises a protocol error.<br/>
    /// <br/>
    /// The input region is ignored for wl_surfaces with the role of a<br/>
    /// drag-and-drop icon.<br/>
    /// <br/>
    /// The given source may not be used in any further set_selection or<br/>
    /// start_drag requests. Attempting to reuse a previously-used source<br/>
    /// may send a used_source error.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void StartDrag(WlDataSource? source, WlSurface origin, WlSurface? icon, uint serial)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].o = (WlObject*)(source?.Handle ?? IntPtr.Zero);
        args[1].o = (WlObject*)(origin?.Handle ?? IntPtr.Zero);
        args[2].o = (WlObject*)(icon?.Handle ?? IntPtr.Zero);
        args[3].u = serial;

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Copy data to the selection
    /// <para>
    /// <br/>
    /// This request asks the compositor to set the selection<br/>
    /// to the data from the source on behalf of the client.<br/>
    /// <br/>
    /// To unset the selection, set the source to NULL.<br/>
    /// <br/>
    /// The given source may not be used in any further set_selection or<br/>
    /// start_drag requests. Attempting to reuse a previously-used source<br/>
    /// may send a used_source error.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetSelection(WlDataSource? source, uint serial)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].o = (WlObject*)(source?.Handle ?? IntPtr.Zero);
        args[1].u = serial;

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Destroy data device
    /// <para>
    /// <br/>
    /// This request destroys the data device.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Release()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static WlDataDevice Create(nint handle, WlDisplay display)
    {
        return new WlDataDevice(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
