// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_display
/// <para> core global object </para>
/// <para> Version: 1 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_display</see>
/// </summary>
public sealed partial class WlDisplay : WaylandObject, IWaylandObjectFactory<WlDisplay>
{
    public const string InterfaceName = "wl_display";
    public const int InterfaceVersion = 1;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public WlDisplay(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary> global error values </summary>
    public enum Error : uint
    {
        /// <summary>
        /// server couldn't find object
        /// </summary>
        InvalidObject = 0,
        /// <summary>
        /// method doesn't exist on the specified interface or malformed request
        /// </summary>
        InvalidMethod = 1,
        /// <summary>
        /// server is out of memory
        /// </summary>
        NoMemory = 2,
        /// <summary>
        /// implementation error in compositor
        /// </summary>
        Implementation = 3,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void ErrorHandler(WaylandObject objectId, uint code, string message);

    private ErrorHandler? _onError;

    /// <summary>
    ///Fatal error event
    /// <para>
    ///
    ///The error event is sent out when a fatal (non-recoverable)
    ///error has occurred. The object_id argument is the object
    ///where the error occurred, most often in response to a request
    ///to that object. The code identifies the error and is defined
    ///by the object interface. As such, each interface defines its
    ///own set of error codes. The message is a brief description
    ///of the error, for (debugging) convenience.
    ///
    /// </para>
    /// </summary>
    public event ErrorHandler? OnError
    {
        add
        {
            CheckDisposed();
            _onError += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onError -= value;
        }
    }

    public delegate void DeleteIdHandler(uint id);

    private DeleteIdHandler? _onDeleteId;

    /// <summary>
    ///Acknowledge object ID deletion
    /// <para>
    ///
    ///This event is used internally by the object ID management
    ///logic. When a client deletes an object that it had created,
    ///the server will send this event to acknowledge that it has
    ///seen the delete request. When the client receives this event,
    ///it will know that it can safely reuse the object ID.
    ///
    /// </para>
    /// </summary>
    public event DeleteIdHandler? OnDeleteId
    {
        add
        {
            CheckDisposed();
            _onDeleteId += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDeleteId -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_display");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlDisplay)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // error
                    if (obj._onError != null)
                    {
                        var _objectId = new WlDisplay((IntPtr)args[0].o, obj.Display);
                        var _code = args[1].u;
                        var _message = Utf8StringMarshaller.ConvertToManaged(args[2].s);
                        obj._onError?.Invoke(_objectId, _code, _message);
                    }
                    break;
                case 1: // delete_id
                    if (obj._onDeleteId != null)
                    {
                        var _id = args[0].u;
                        obj._onDeleteId?.Invoke(_id);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Asynchronous roundtrip
    /// <para>
    /// <br/>
    /// The sync request asks the server to emit the 'done' event<br/>
    /// on the returned wl_callback object. Since requests are<br/>
    /// handled in-order and events are delivered in-order, this can<br/>
    /// be used as a barrier to ensure all previous requests and the<br/>
    /// resulting events have been handled.<br/>
    /// <br/>
    /// The object returned by this request will be destroyed by the<br/>
    /// compositor after the callback is fired and as such the client must not<br/>
    /// attempt to use it after that point.<br/>
    /// <br/>
    /// The callback_data passed in the callback is undefined and should be ignored.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe WlCallback Sync()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)IntPtr.Zero;

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.WlCallback,
            (uint)WaylandInterfaces.WlCallback->Version,
            0,
            (nint)args
        );

        return new WlCallback(newProxy, Display);
    }

    /// <summary>
    /// Get global registry object
    /// <para>
    /// <br/>
    /// This request creates a registry object that allows the client<br/>
    /// to list and bind the global objects available from the<br/>
    /// compositor.<br/>
    /// <br/>
    /// It should be noted that the server side resources consumed in<br/>
    /// response to a get_registry request can only be released when the<br/>
    /// client disconnects, not when the client side proxy is destroyed.<br/>
    /// Therefore, clients should invoke get_registry as infrequently as<br/>
    /// possible to avoid wasting memory.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe WlRegistry GetRegistry()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)IntPtr.Zero;

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.WlRegistry,
            (uint)WaylandInterfaces.WlRegistry->Version,
            0,
            (nint)args
        );

        return new WlRegistry(newProxy, Display);
    }


    #endregion // GenerateRequests

    public static WlDisplay Create(nint handle, WlDisplay display)
    {
        return new WlDisplay(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
