// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_seat
/// <para> group of input devices </para>
/// <para> Version: 10 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_seat</see>
/// </summary>
public sealed partial class WlSeat : WaylandObject, IWaylandObjectFactory<WlSeat>
{
    public const string InterfaceName = "wl_seat";
    public static string _StaticInterfaceName => "wl_seat";
    public const int InterfaceVersion = 10;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public WlSeat(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    /// <summary> seat capability bitmask </summary>
    [Flags]
    public enum CapabilityFlag : uint
    {
        /// <summary>
        /// the seat has pointer devices
        /// </summary>
        Pointer = 1,
        /// <summary>
        /// the seat has one or more keyboards
        /// </summary>
        Keyboard = 2,
        /// <summary>
        /// the seat has touch devices
        /// </summary>
        Touch = 4,
    }

    /// <summary> wl_seat error values </summary>
    public enum Error : uint
    {
        /// <summary>
        /// get_pointer, get_keyboard or get_touch called on seat without the matching capability
        /// </summary>
        MissingCapability = 0,
    }

    public delegate void CapabilitiesHandler(uint capabilities);

    private CapabilitiesHandler? _onCapabilities;

    /// <summary>
    ///Seat capabilities changed
    /// <para>
    ///
    ///This is sent on binding to the seat global or whenever a seat gains
    ///or loses the pointer, keyboard or touch capabilities.
    ///The argument is a capability enum containing the complete set of
    ///capabilities this seat has.
    ///
    ///When the pointer capability is added, a client may create a
    ///wl_pointer object using the wl_seat.get_pointer request. This object
    ///will receive pointer events until the capability is removed in the
    ///future.
    ///
    ///When the pointer capability is removed, a client should destroy the
    ///wl_pointer objects associated with the seat where the capability was
    ///removed, using the wl_pointer.release request. No further pointer
    ///events will be received on these objects.
    ///
    ///In some compositors, if a seat regains the pointer capability and a
    ///client has a previously obtained wl_pointer object of version 4 or
    ///less, that object may start sending pointer events again. This
    ///behavior is considered a misinterpretation of the intended behavior
    ///and must not be relied upon by the client. wl_pointer objects of
    ///version 5 or later must not send events if created before the most
    ///recent event notifying the client of an added pointer capability.
    ///
    ///The above behavior also applies to wl_keyboard and wl_touch with the
    ///keyboard and touch capabilities, respectively.
    ///
    /// </para>
    /// </summary>
    public event CapabilitiesHandler? OnCapabilities
    {
        add
        {
            CheckDisposed();
            _onCapabilities += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onCapabilities -= value;
        }
    }

    public delegate void NameHandler(string name);

    private NameHandler? _onName;

    /// <summary>
    ///Unique identifier for this seat
    /// <para>
    ///
    ///In a multi-seat configuration the seat name can be used by clients to
    ///help identify which physical devices the seat represents.
    ///
    ///The seat name is a UTF-8 string with no convention defined for its
    ///contents. Each name is unique among all wl_seat globals. The name is
    ///only guaranteed to be unique for the current compositor instance.
    ///
    ///The same seat names are used for all clients. Thus, the name can be
    ///shared across processes to refer to a specific wl_seat global.
    ///
    ///The name event is sent after binding to the seat global, and should be sent
    ///before announcing capabilities. This event only sent once per seat object,
    ///and the name does not change over the lifetime of the wl_seat global.
    ///
    ///Compositors may re-use the same seat name if the wl_seat global is
    ///destroyed and re-created later.
    ///
    /// </para>
    /// </summary>
    public event NameHandler? OnName
    {
        add
        {
            CheckDisposed();
            _onName += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onName -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_seat");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlSeat)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // capabilities
                    if (obj._onCapabilities != null)
                    {
                        var _capabilities = args[0].u;
                        obj._onCapabilities?.Invoke(_capabilities);
                    }
                    break;
                case 1: // name
                    if (obj._onName != null)
                    {
                        var _name = Utf8StringMarshaller.ConvertToManaged(args[0].s);
                        obj._onName?.Invoke(_name);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    /// <summary>
    /// Return pointer object
    /// <para>
    /// <br/>
    /// The ID provided will be initialized to the wl_pointer interface<br/>
    /// for this seat.<br/>
    /// <br/>
    /// This request only takes effect if the seat has the pointer<br/>
    /// capability, or has had the pointer capability in the past.<br/>
    /// It is a protocol violation to issue this request on a seat that has<br/>
    /// never had the pointer capability. The missing_capability error will<br/>
    /// be sent in this case.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe WlPointer GetPointer()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)IntPtr.Zero;

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.WlPointer,
            (uint)WaylandInterfaces.WlPointer->Version,
            0,
            (nint)args
        );

        return new WlPointer(newProxy, Display);
    }

    /// <summary>
    /// Return keyboard object
    /// <para>
    /// <br/>
    /// The ID provided will be initialized to the wl_keyboard interface<br/>
    /// for this seat.<br/>
    /// <br/>
    /// This request only takes effect if the seat has the keyboard<br/>
    /// capability, or has had the keyboard capability in the past.<br/>
    /// It is a protocol violation to issue this request on a seat that has<br/>
    /// never had the keyboard capability. The missing_capability error will<br/>
    /// be sent in this case.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe WlKeyboard GetKeyboard()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)IntPtr.Zero;

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.WlKeyboard,
            (uint)WaylandInterfaces.WlKeyboard->Version,
            0,
            (nint)args
        );

        return new WlKeyboard(newProxy, Display);
    }

    /// <summary>
    /// Return touch object
    /// <para>
    /// <br/>
    /// The ID provided will be initialized to the wl_touch interface<br/>
    /// for this seat.<br/>
    /// <br/>
    /// This request only takes effect if the seat has the touch<br/>
    /// capability, or has had the touch capability in the past.<br/>
    /// It is a protocol violation to issue this request on a seat that has<br/>
    /// never had the touch capability. The missing_capability error will<br/>
    /// be sent in this case.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe WlTouch GetTouch()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)IntPtr.Zero;

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.WlTouch,
            (uint)WaylandInterfaces.WlTouch->Version,
            0,
            (nint)args
        );

        return new WlTouch(newProxy, Display);
    }

    /// <summary>
    /// Release the seat object
    /// <para>
    /// <br/>
    /// Using this request a client can tell the server that it is not going to<br/>
    /// use the seat object anymore.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Release()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 3;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    public static WlSeat Create(nint handle, WlDisplay display)
    {
        return new WlSeat(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
