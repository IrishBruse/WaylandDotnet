// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_data_offer
/// <para> offer to transfer data </para>
/// <para> Version: 3 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_data_offer</see>
/// </summary>
public sealed partial class WlDataOffer : WaylandObject, IWaylandObjectFactory<WlDataOffer>
{
    public const string InterfaceName = "wl_data_offer";
    public static string _StaticInterfaceName => "wl_data_offer";
    public const int InterfaceVersion = 3;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public WlDataOffer(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// finish request was called untimely
        /// </summary>
        InvalidFinish = 0,
        /// <summary>
        /// action mask contains invalid values
        /// </summary>
        InvalidActionMask = 1,
        /// <summary>
        /// action argument has an invalid value
        /// </summary>
        InvalidAction = 2,
        /// <summary>
        /// offer doesn't accept this request
        /// </summary>
        InvalidOffer = 3,
    }

    public delegate void OfferHandler(string mimeType);

    private OfferHandler? _onOffer;

    /// <summary>
    ///Advertise offered mime type
    /// <para>
    ///
    ///Sent immediately after creating the wl_data_offer object.  One
    ///event per offered mime type.
    ///
    /// </para>
    /// </summary>
    public event OfferHandler? OnOffer
    {
        add
        {
            CheckDisposed();
            _onOffer += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onOffer -= value;
        }
    }

    public delegate void SourceActionsHandler(uint sourceActions);

    private SourceActionsHandler? _onSourceActions;

    /// <summary>
    ///Notify the source-side available actions
    /// <para>
    ///
    ///This event indicates the actions offered by the data source. It
    ///will be sent immediately after creating the wl_data_offer object,
    ///or anytime the source side changes its offered actions through
    ///wl_data_source.set_actions.
    ///
    /// </para>
    /// </summary>
    public event SourceActionsHandler? OnSourceActions
    {
        add
        {
            CheckDisposed();
            _onSourceActions += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onSourceActions -= value;
        }
    }

    public delegate void ActionHandler(uint dndAction);

    private ActionHandler? _onAction;

    /// <summary>
    ///Notify the selected action
    /// <para>
    ///
    ///This event indicates the action selected by the compositor after
    ///matching the source/destination side actions. Only one action (or
    ///none) will be offered here.
    ///
    ///This event can be emitted multiple times during the drag-and-drop
    ///operation in response to destination side action changes through
    ///wl_data_offer.set_actions.
    ///
    ///This event will no longer be emitted after wl_data_device.drop
    ///happened on the drag-and-drop destination, the client must
    ///honor the last action received, or the last preferred one set
    ///through wl_data_offer.set_actions when handling an "ask" action.
    ///
    ///Compositors may also change the selected action on the fly, mainly
    ///in response to keyboard modifier changes during the drag-and-drop
    ///operation.
    ///
    ///The most recent action received is always the valid one. Prior to
    ///receiving wl_data_device.drop, the chosen action may change (e.g.
    ///due to keyboard modifiers being pressed). At the time of receiving
    ///wl_data_device.drop the drag-and-drop destination must honor the
    ///last action received.
    ///
    ///Action changes may still happen after wl_data_device.drop,
    ///especially on "ask" actions, where the drag-and-drop destination
    ///may choose another action afterwards. Action changes happening
    ///at this stage are always the result of inter-client negotiation, the
    ///compositor shall no longer be able to induce a different action.
    ///
    ///Upon "ask" actions, it is expected that the drag-and-drop destination
    ///may potentially choose a different action and/or mime type,
    ///based on wl_data_offer.source_actions and finally chosen by the
    ///user (e.g. popping up a menu with the available options). The
    ///final wl_data_offer.set_actions and wl_data_offer.accept requests
    ///must happen before the call to wl_data_offer.finish.
    ///
    /// </para>
    /// </summary>
    public event ActionHandler? OnAction
    {
        add
        {
            CheckDisposed();
            _onAction += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAction -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_data_offer");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlDataOffer)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // offer
                    if (obj._onOffer != null)
                    {
                        var _mimeType = Utf8StringMarshaller.ConvertToManaged(args[0].s);
                        obj._onOffer?.Invoke(_mimeType);
                    }
                    break;
                case 1: // source_actions
                    if (obj._onSourceActions != null)
                    {
                        var _sourceActions = args[0].u;
                        obj._onSourceActions?.Invoke(_sourceActions);
                    }
                    break;
                case 2: // action
                    if (obj._onAction != null)
                    {
                        var _dndAction = args[0].u;
                        obj._onAction?.Invoke(_dndAction);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    /// <summary>
    /// Accept one of the offered mime types
    /// <para>
    /// <br/>
    /// Indicate that the client can accept the given mime type, or<br/>
    /// NULL for not accepted.<br/>
    /// <br/>
    /// For objects of version 2 or older, this request is used by the<br/>
    /// client to give feedback whether the client can receive the given<br/>
    /// mime type, or NULL if none is accepted; the feedback does not<br/>
    /// determine whether the drag-and-drop operation succeeds or not.<br/>
    /// <br/>
    /// For objects of version 3 or newer, this request determines the<br/>
    /// final result of the drag-and-drop operation. If the end result<br/>
    /// is that no mime types were accepted, the drag-and-drop operation<br/>
    /// will be cancelled and the corresponding drag source will receive<br/>
    /// wl_data_source.cancelled. Clients may still use this event in<br/>
    /// conjunction with wl_data_source.action for feedback.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Accept(uint serial, string? mimeType)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].u = serial;
        args[1].s = Utf8StringMarshaller.ConvertToUnmanaged(mimeType);

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Request that the data is transferred
    /// <para>
    /// <br/>
    /// To transfer the offered data, the client issues this request<br/>
    /// and indicates the mime type it wants to receive.  The transfer<br/>
    /// happens through the passed file descriptor (typically created<br/>
    /// with the pipe system call).  The source client writes the data<br/>
    /// in the mime type representation requested and then closes the<br/>
    /// file descriptor.<br/>
    /// <br/>
    /// The receiving client reads from the read end of the pipe until<br/>
    /// EOF and then closes its end, at which point the transfer is<br/>
    /// complete.<br/>
    /// <br/>
    /// This request may happen multiple times for different mime types,<br/>
    /// both before and after wl_data_device.drop. Drag-and-drop destination<br/>
    /// clients may preemptively fetch data or examine it more closely to<br/>
    /// determine acceptance.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Receive(string mimeType, int fd)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].s = Utf8StringMarshaller.ConvertToUnmanaged(mimeType);
        args[1].h = fd;

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Destroy data offer
    /// <para>
    /// <br/>
    /// Destroy the data offer.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// The offer will no longer be used
    /// <para>
    /// <br/>
    /// Notifies the compositor that the drag destination successfully<br/>
    /// finished the drag-and-drop operation.<br/>
    /// <br/>
    /// Upon receiving this request, the compositor will emit<br/>
    /// wl_data_source.dnd_finished on the drag source client.<br/>
    /// <br/>
    /// It is a client error to perform other requests than<br/>
    /// wl_data_offer.destroy after this one. It is also an error to perform<br/>
    /// this request after a NULL mime type has been set in<br/>
    /// wl_data_offer.accept or no action was received through<br/>
    /// wl_data_offer.action.<br/>
    /// <br/>
    /// If wl_data_offer.finish request is received for a non drag and drop<br/>
    /// operation, the invalid_finish protocol error is raised.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Finish()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 3;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set the available/preferred drag-and-drop actions
    /// <para>
    /// <br/>
    /// Sets the actions that the destination side client supports for<br/>
    /// this operation. This request may trigger the emission of<br/>
    /// wl_data_source.action and wl_data_offer.action events if the compositor<br/>
    /// needs to change the selected action.<br/>
    /// <br/>
    /// This request can be called multiple times throughout the<br/>
    /// drag-and-drop operation, typically in response to wl_data_device.enter<br/>
    /// or wl_data_device.motion events.<br/>
    /// <br/>
    /// This request determines the final result of the drag-and-drop<br/>
    /// operation. If the end result is that no action is accepted,<br/>
    /// the drag source will receive wl_data_source.cancelled.<br/>
    /// <br/>
    /// The dnd_actions argument must contain only values expressed in the<br/>
    /// wl_data_device_manager.dnd_actions enum, and the preferred_action<br/>
    /// argument must only contain one of those values set, otherwise it<br/>
    /// will result in a protocol error.<br/>
    /// <br/>
    /// While managing an "ask" action, the destination drag-and-drop client<br/>
    /// may perform further wl_data_offer.receive requests, and is expected<br/>
    /// to perform one last wl_data_offer.set_actions request with a preferred<br/>
    /// action other than "ask" (and optionally wl_data_offer.accept) before<br/>
    /// requesting wl_data_offer.finish, in order to convey the action selected<br/>
    /// by the user. If the preferred action is not in the<br/>
    /// wl_data_offer.source_actions mask, an error will be raised.<br/>
    /// <br/>
    /// If the "ask" action is dismissed (e.g. user cancellation), the client<br/>
    /// is expected to perform wl_data_offer.destroy right away.<br/>
    /// <br/>
    /// This request can only be made on drag-and-drop offers, a protocol error<br/>
    /// will be raised otherwise.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetActions(uint dndActions, uint preferredAction)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].u = dndActions;
        args[1].u = preferredAction;

        const uint opcode = 4;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    public static WlDataOffer Create(nint handle, WlDisplay display)
    {
        return new WlDataOffer(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
