// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_keyboard
/// <para> keyboard input device </para>
/// <para> Version: 10 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_keyboard</see>
/// </summary>
public sealed partial class WlKeyboard : WaylandObject, IWaylandObjectFactory<WlKeyboard>
{
    public const string InterfaceName = "wl_keyboard";
    public static string _StaticInterfaceName => "wl_keyboard";
    public const int InterfaceVersion = 10;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public WlKeyboard(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    /// <summary> keyboard mapping format </summary>
    public enum KeymapFormat : uint
    {
        /// <summary>
        /// no keymap; client must understand how to interpret the raw keycode
        /// </summary>
        NoKeymap = 0,
        /// <summary>
        /// libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode
        /// </summary>
        XkbV1 = 1,
    }

    /// <summary> physical key state </summary>
    public enum KeyState : uint
    {
        /// <summary>
        /// key is not pressed
        /// </summary>
        Released = 0,
        /// <summary>
        /// key is pressed
        /// </summary>
        Pressed = 1,
        /// <summary>
        /// key was repeated
        /// </summary>
        Repeated = 2,
    }

    public delegate void KeymapHandler(uint format, int fd, uint size);

    private KeymapHandler? _onKeymap;

    /// <summary>
    ///Keyboard mapping
    /// <para>
    ///
    ///This event provides a file descriptor to the client which can be
    ///memory-mapped in read-only mode to provide a keyboard mapping
    ///description.
    ///
    ///From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
    ///the recipient, as MAP_SHARED may fail.
    ///
    /// </para>
    /// </summary>
    public event KeymapHandler? OnKeymap
    {
        add
        {
            CheckDisposed();
            _onKeymap += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onKeymap -= value;
        }
    }

    public delegate void EnterHandler(uint serial, WlSurface surface, byte[] keys);

    private EnterHandler? _onEnter;

    /// <summary>
    ///Enter event
    /// <para>
    ///
    ///Notification that this seat's keyboard focus is on a certain
    ///surface.
    ///
    ///The compositor must send the wl_keyboard.modifiers event after this
    ///event.
    ///
    ///In the wl_keyboard logical state, this event sets the active surface to
    ///the surface argument and the keys currently logically down to the keys
    ///in the keys argument. The compositor must not send this event if the
    ///wl_keyboard already had an active surface immediately before this event.
    ///
    ///Clients should not use the list of pressed keys to emulate key-press
    ///events. The order of keys in the list is unspecified.
    ///
    /// </para>
    /// </summary>
    public event EnterHandler? OnEnter
    {
        add
        {
            CheckDisposed();
            _onEnter += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onEnter -= value;
        }
    }

    public delegate void LeaveHandler(uint serial, WlSurface surface);

    private LeaveHandler? _onLeave;

    /// <summary>
    ///Leave event
    /// <para>
    ///
    ///Notification that this seat's keyboard focus is no longer on
    ///a certain surface.
    ///
    ///The leave notification is sent before the enter notification
    ///for the new focus.
    ///
    ///In the wl_keyboard logical state, this event resets all values to their
    ///defaults. The compositor must not send this event if the active surface
    ///of the wl_keyboard was not equal to the surface argument immediately
    ///before this event.
    ///
    /// </para>
    /// </summary>
    public event LeaveHandler? OnLeave
    {
        add
        {
            CheckDisposed();
            _onLeave += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onLeave -= value;
        }
    }

    public delegate void KeyHandler(uint serial, uint time, uint key, uint state);

    private KeyHandler? _onKey;

    /// <summary>
    ///Key event
    /// <para>
    ///
    ///A key was pressed or released.
    ///The time argument is a timestamp with millisecond
    ///granularity, with an undefined base.
    ///
    ///The key is a platform-specific key code that can be interpreted
    ///by feeding it to the keyboard mapping (see the keymap event).
    ///
    ///If this event produces a change in modifiers, then the resulting
    ///wl_keyboard.modifiers event must be sent after this event.
    ///
    ///In the wl_keyboard logical state, this event adds the key to the keys
    ///currently logically down (if the state argument is pressed) or removes
    ///the key from the keys currently logically down (if the state argument is
    ///released). The compositor must not send this event if the wl_keyboard
    ///did not have an active surface immediately before this event. The
    ///compositor must not send this event if state is pressed (resp. released)
    ///and the key was already logically down (resp. was not logically down)
    ///immediately before this event.
    ///
    ///Since version 10, compositors may send key events with the "repeated"
    ///key state when a wl_keyboard.repeat_info event with a rate argument of
    ///0 has been received. This allows the compositor to take over the
    ///responsibility of key repetition.
    ///
    /// </para>
    /// </summary>
    public event KeyHandler? OnKey
    {
        add
        {
            CheckDisposed();
            _onKey += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onKey -= value;
        }
    }

    public delegate void ModifiersHandler(uint serial, uint modsDepressed, uint modsLatched, uint modsLocked, uint group);

    private ModifiersHandler? _onModifiers;

    /// <summary>
    ///Modifier and group state
    /// <para>
    ///
    ///Notifies clients that the modifier and/or group state has
    ///changed, and it should update its local state.
    ///
    ///The compositor may send this event without a surface of the client
    ///having keyboard focus, for example to tie modifier information to
    ///pointer focus instead. If a modifier event with pressed modifiers is sent
    ///without a prior enter event, the client can assume the modifier state is
    ///valid until it receives the next wl_keyboard.modifiers event. In order to
    ///reset the modifier state again, the compositor can send a
    ///wl_keyboard.modifiers event with no pressed modifiers.
    ///
    ///In the wl_keyboard logical state, this event updates the modifiers and
    ///group.
    ///
    /// </para>
    /// </summary>
    public event ModifiersHandler? OnModifiers
    {
        add
        {
            CheckDisposed();
            _onModifiers += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onModifiers -= value;
        }
    }

    public delegate void RepeatInfoHandler(int rate, int delay);

    private RepeatInfoHandler? _onRepeatInfo;

    /// <summary>
    ///Repeat rate and delay
    /// <para>
    ///
    ///Informs the client about the keyboard's repeat rate and delay.
    ///
    ///This event is sent as soon as the wl_keyboard object has been created,
    ///and is guaranteed to be received by the client before any key press
    ///event.
    ///
    ///Negative values for either rate or delay are illegal. A rate of zero
    ///will disable any repeating (regardless of the value of delay).
    ///
    ///This event can be sent later on as well with a new value if necessary,
    ///so clients should continue listening for the event past the creation
    ///of wl_keyboard.
    ///
    /// </para>
    /// </summary>
    public event RepeatInfoHandler? OnRepeatInfo
    {
        add
        {
            CheckDisposed();
            _onRepeatInfo += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onRepeatInfo -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_keyboard");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlKeyboard)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // keymap
                    if (obj._onKeymap != null)
                    {
                        var _format = args[0].u;
                        var _fd = args[1].h;
                        var _size = args[2].u;
                        obj._onKeymap?.Invoke(_format, _fd, _size);
                    }
                    break;
                case 1: // enter
                    if (obj._onEnter != null)
                    {
                        var _serial = args[0].u;
                        WlSurface? _surface = null;
                        if (args[1].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'surface'");
                        _surface = new WlSurface((IntPtr)args[1].o, obj.Display);
                        var _keys = args[2].a;
                        obj._onEnter?.Invoke(_serial, _surface, WaylandMarshal.ToSpan(_keys));
                    }
                    break;
                case 2: // leave
                    if (obj._onLeave != null)
                    {
                        var _serial = args[0].u;
                        WlSurface? _surface = null;
                        if (args[1].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'surface'");
                        _surface = new WlSurface((IntPtr)args[1].o, obj.Display);
                        obj._onLeave?.Invoke(_serial, _surface);
                    }
                    break;
                case 3: // key
                    if (obj._onKey != null)
                    {
                        var _serial = args[0].u;
                        var _time = args[1].u;
                        var _key = args[2].u;
                        var _state = args[3].u;
                        obj._onKey?.Invoke(_serial, _time, _key, _state);
                    }
                    break;
                case 4: // modifiers
                    if (obj._onModifiers != null)
                    {
                        var _serial = args[0].u;
                        var _modsDepressed = args[1].u;
                        var _modsLatched = args[2].u;
                        var _modsLocked = args[3].u;
                        var _group = args[4].u;
                        obj._onModifiers?.Invoke(_serial, _modsDepressed, _modsLatched, _modsLocked, _group);
                    }
                    break;
                case 5: // repeat_info
                    if (obj._onRepeatInfo != null)
                    {
                        var _rate = args[0].i;
                        var _delay = args[1].i;
                        obj._onRepeatInfo?.Invoke(_rate, _delay);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    /// <summary>
    /// Release the keyboard object
    /// <para>
    /// release<br/>
    /// </para>
    /// </summary>
    public unsafe void Release()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    public static WlKeyboard Create(nint handle, WlDisplay display)
    {
        return new WlKeyboard(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
