// <auto-generated>
// This file was generated from wayland.xml
// Stability: Core
// Link: https://wayland.app/protocols/wayland
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wl_registry
/// <para> global registry object </para>
/// <para> Version: 1 </para>
/// <see>https://wayland.app/protocols/wayland/#wl_registry</see>
/// </summary>
public sealed partial class WlRegistry : WaylandObject, IWaylandObjectFactory<WlRegistry>
{
    public const string InterfaceName = "wl_registry";
    public const int InterfaceVersion = 1;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public WlRegistry(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEventDelegates

    public delegate void GlobalHandler(uint name, string _interface, uint version);

    private GlobalHandler? _onGlobal;

    /// <summary>
    ///Announce global object
    /// <para>
    ///
    ///Notify the client of global objects.
    ///
    ///The event notifies the client that a global object with
    ///the given name is now available, and it implements the
    ///given version of the given interface.
    ///
    /// </para>
    /// </summary>
    public event GlobalHandler? OnGlobal
    {
        add
        {
            CheckDisposed();
            _onGlobal += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onGlobal -= value;
        }
    }

    public delegate void GlobalRemoveHandler(uint name);

    private GlobalRemoveHandler? _onGlobalRemove;

    /// <summary>
    ///Announce removal of global object
    /// <para>
    ///
    ///Notify the client of removed global objects.
    ///
    ///This event notifies the client that the global identified
    ///by name is no longer available. If the client bound to
    ///the global using the bind request, the client should now
    ///destroy that object.
    ///
    ///The object remains valid and requests to the object will be
    ///ignored until the client destroys it, to avoid races between
    ///the global going away and a client sending a request to it.
    ///
    /// </para>
    /// </summary>
    public event GlobalRemoveHandler? OnGlobalRemove
    {
        add
        {
            CheckDisposed();
            _onGlobalRemove += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onGlobalRemove -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wl_registry");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WlRegistry)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // global
                    if (obj._onGlobal != null)
                    {
                        var _name = args[0].u;
                        var __interface = Utf8StringMarshaller.ConvertToManaged(args[1].s);
                        var _version = args[2].u;
                        obj._onGlobal?.Invoke(_name, __interface, _version);
                    }
                    break;
                case 1: // global_remove
                    if (obj._onGlobalRemove != null)
                    {
                        var _name = args[0].u;
                        obj._onGlobalRemove?.Invoke(_name);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Bind an object to the display
    /// <para>
    /// <br/>
    /// Binds a new, client-created object to the server using the<br/>
    /// specified name as the identifier.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe WaylandObject Bind(string interfaceName, uint version, uint name)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].u = name;
        // Untyped new_id expansion for id
        args[1].s = Utf8StringMarshaller.ConvertToUnmanaged(interfaceName);
        args[2].u = version;
        args[3].o = (WlObject*)IntPtr.Zero; // Placeholder for new ID

        WlInterface* targetInterface = (WlInterface*)WaylandInterfaces.GetInterfacePtr(interfaceName);
        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            targetInterface,
            version,
            0,
            (nint)args
        );

        return new WaylandObject(newProxy, Display, interfaceName, version);
    }


    #endregion // GenerateRequests

    public static WlRegistry Create(nint handle, WlDisplay display)
    {
        return new WlRegistry(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
