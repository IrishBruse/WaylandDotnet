// <auto-generated>
// This file was generated from tablet-v2.xml
// Stability: Stable
// Link: https://wayland.app/protocols/tablet-v2
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.Stable;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// zwp_tablet_pad_group_v2
/// <para> a set of buttons, rings and strips </para>
/// <para> Version: 2 </para>
/// <see>https://wayland.app/protocols/tablet-v2/#zwp_tablet_pad_group_v2</see>
/// </summary>
public sealed partial class ZwpTabletPadGroupV2 : WaylandObject, IWaylandObjectFactory<ZwpTabletPadGroupV2>
{
    public const string InterfaceName = "zwp_tablet_pad_group_v2";
    public static string _StaticInterfaceName => "zwp_tablet_pad_group_v2";
    public const int InterfaceVersion = 2;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public ZwpTabletPadGroupV2(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    public delegate void ButtonsHandler(byte[] buttons);

    private ButtonsHandler? _onButtons;

    /// <summary>
    ///Buttons announced
    /// <para>
    ///
    ///Sent on zwp_tablet_pad_group_v2 initialization to announce the available
    ///buttons in the group. Button indices start at 0, a button may only be
    ///in one group at a time.
    ///
    ///This event is first sent in the initial burst of events before the
    ///zwp_tablet_pad_group_v2.done event.
    ///
    ///Some buttons are reserved by the compositor. These buttons may not be
    ///assigned to any zwp_tablet_pad_group_v2. Compositors may broadcast this
    ///event in the case of changes to the mapping of these reserved buttons.
    ///If the compositor happens to reserve all buttons in a group, this event
    ///will be sent with an empty array.
    ///
    /// </para>
    /// </summary>
    public event ButtonsHandler? OnButtons
    {
        add
        {
            CheckDisposed();
            _onButtons += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onButtons -= value;
        }
    }

    public delegate void RingHandler(ZwpTabletPadRingV2 ring);

    private RingHandler? _onRing;

    /// <summary>
    ///Ring announced
    /// <para>
    ///
    ///Sent on zwp_tablet_pad_group_v2 initialization to announce available rings.
    ///One event is sent for each ring available on this pad group.
    ///
    ///This event is sent in the initial burst of events before the
    ///zwp_tablet_pad_group_v2.done event.
    ///
    /// </para>
    /// </summary>
    public event RingHandler? OnRing
    {
        add
        {
            CheckDisposed();
            _onRing += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onRing -= value;
        }
    }

    public delegate void StripHandler(ZwpTabletPadStripV2 strip);

    private StripHandler? _onStrip;

    /// <summary>
    ///Strip announced
    /// <para>
    ///
    ///Sent on zwp_tablet_pad_v2 initialization to announce available strips.
    ///One event is sent for each strip available on this pad group.
    ///
    ///This event is sent in the initial burst of events before the
    ///zwp_tablet_pad_group_v2.done event.
    ///
    /// </para>
    /// </summary>
    public event StripHandler? OnStrip
    {
        add
        {
            CheckDisposed();
            _onStrip += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onStrip -= value;
        }
    }

    public delegate void ModesHandler(uint modes);

    private ModesHandler? _onModes;

    /// <summary>
    ///Mode-switch ability announced
    /// <para>
    ///
    ///Sent on zwp_tablet_pad_group_v2 initialization to announce that the pad
    ///group may switch between modes. A client may use a mode to store a
    ///specific configuration for buttons, rings and strips and use the
    ///zwp_tablet_pad_group_v2.mode_switch event to toggle between these
    ///configurations. Mode indices start at 0.
    ///
    ///Switching modes is compositor-dependent. See the
    ///zwp_tablet_pad_group_v2.mode_switch event for more details.
    ///
    ///This event is sent in the initial burst of events before the
    ///zwp_tablet_pad_group_v2.done event. This event is only sent when more than
    ///more than one mode is available.
    ///
    /// </para>
    /// </summary>
    public event ModesHandler? OnModes
    {
        add
        {
            CheckDisposed();
            _onModes += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onModes -= value;
        }
    }

    public delegate void DoneHandler();

    private DoneHandler? _onDone;

    /// <summary>
    ///Tablet group description events sequence complete
    /// <para>
    ///
    ///This event is sent immediately to signal the end of the initial
    ///burst of descriptive events. A client may consider the static
    ///description of the tablet to be complete and finalize initialization
    ///of the tablet group.
    ///
    /// </para>
    /// </summary>
    public event DoneHandler? OnDone
    {
        add
        {
            CheckDisposed();
            _onDone += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDone -= value;
        }
    }

    public delegate void ModeSwitchHandler(uint time, uint serial, uint mode);

    private ModeSwitchHandler? _onModeSwitch;

    /// <summary>
    ///Mode switch event
    /// <para>
    ///
    ///Notification that the mode was switched.
    ///
    ///A mode applies to all buttons, rings, strips and dials in a group
    ///simultaneously, but a client is not required to assign different actions
    ///for each mode. For example, a client may have mode-specific button
    ///mappings but map the ring to vertical scrolling in all modes. Mode
    ///indices start at 0.
    ///
    ///Switching modes is compositor-dependent. The compositor may provide
    ///visual cues to the user about the mode, e.g. by toggling LEDs on
    ///the tablet device. Mode-switching may be software-controlled or
    ///controlled by one or more physical buttons. For example, on a Wacom
    ///Intuos Pro, the button inside the ring may be assigned to switch
    ///between modes.
    ///
    ///The compositor will also send this event after zwp_tablet_pad_v2.enter on
    ///each group in order to notify of the current mode. Groups that only
    ///feature one mode will use mode=0 when emitting this event.
    ///
    ///If a button action in the new mode differs from the action in the
    ///previous mode, the client should immediately issue a
    ///zwp_tablet_pad_v2.set_feedback request for each changed button.
    ///
    ///If a ring, strip or dial action in the new mode differs from the action
    ///in the previous mode, the client should immediately issue a
    ///zwp_tablet_ring_v2.set_feedback, zwp_tablet_strip_v2.set_feedback or
    ///zwp_tablet_dial_v2.set_feedback request for each changed ring, strip or dial.
    ///
    /// </para>
    /// </summary>
    public event ModeSwitchHandler? OnModeSwitch
    {
        add
        {
            CheckDisposed();
            _onModeSwitch += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onModeSwitch -= value;
        }
    }

    public delegate void DialHandler(ZwpTabletPadDialV2 dial);

    private DialHandler? _onDial;

    /// <summary>
    ///Dial announced
    /// <para>
    ///
    ///Sent on zwp_tablet_pad_v2 initialization to announce available dials.
    ///One event is sent for each dial available on this pad group.
    ///
    ///This event is sent in the initial burst of events before the
    ///zwp_tablet_pad_group_v2.done event.
    ///
    /// </para>
    /// </summary>
    public event DialHandler? OnDial
    {
        add
        {
            CheckDisposed();
            _onDial += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDial -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to zwp_tablet_pad_group_v2");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (ZwpTabletPadGroupV2)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // buttons
                    if (obj._onButtons != null)
                    {
                        var _buttons = args[0].a;
                        obj._onButtons?.Invoke(WaylandMarshal.ToSpan(_buttons));
                    }
                    break;
                case 1: // ring
                    if (obj._onRing != null)
                    {
                        ZwpTabletPadRingV2? _ring = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'ring'");
                        _ring = new ZwpTabletPadRingV2((IntPtr)args[0].o, obj.Display);
                        obj._onRing?.Invoke(_ring);
                    }
                    break;
                case 2: // strip
                    if (obj._onStrip != null)
                    {
                        ZwpTabletPadStripV2? _strip = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'strip'");
                        _strip = new ZwpTabletPadStripV2((IntPtr)args[0].o, obj.Display);
                        obj._onStrip?.Invoke(_strip);
                    }
                    break;
                case 3: // modes
                    if (obj._onModes != null)
                    {
                        var _modes = args[0].u;
                        obj._onModes?.Invoke(_modes);
                    }
                    break;
                case 4: // done
                    if (obj._onDone != null)
                    {
                        obj._onDone?.Invoke();
                    }
                    break;
                case 5: // mode_switch
                    if (obj._onModeSwitch != null)
                    {
                        var _time = args[0].u;
                        var _serial = args[1].u;
                        var _mode = args[2].u;
                        obj._onModeSwitch?.Invoke(_time, _serial, _mode);
                    }
                    break;
                case 6: // dial
                    if (obj._onDial != null)
                    {
                        ZwpTabletPadDialV2? _dial = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'dial'");
                        _dial = new ZwpTabletPadDialV2((IntPtr)args[0].o, obj.Display);
                        obj._onDial?.Invoke(_dial);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    /// <summary>
    /// Destroy the pad object
    /// <para>
    /// <br/>
    /// Destroy the zwp_tablet_pad_group_v2 object. Objects created from this object<br/>
    /// are unaffected and should be destroyed separately.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    public static ZwpTabletPadGroupV2 Create(nint handle, WlDisplay display)
    {
        return new ZwpTabletPadGroupV2(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
