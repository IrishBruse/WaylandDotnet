// <auto-generated>
// This file was generated from tablet-v2.xml
// Stability: Stable
// Link: https://wayland.app/protocols/tablet-v2
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.Stable;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// zwp_tablet_tool_v2
/// <para> a physical tablet tool </para>
/// <para> Version: 2 </para>
/// <see>https://wayland.app/protocols/tablet-v2/#zwp_tablet_tool_v2</see>
/// </summary>
public sealed partial class ZwpTabletToolV2 : WaylandObject, IWaylandObjectFactory<ZwpTabletToolV2>
{
    public const string InterfaceName = "zwp_tablet_tool_v2";
    public static string _StaticInterfaceName => "zwp_tablet_tool_v2";
    public const int InterfaceVersion = 2;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public ZwpTabletToolV2(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    /// <summary> a physical tool type </summary>
    public enum Type : uint
    {
        /// <summary>
        /// Pen
        /// </summary>
        Pen = 0x140,
        /// <summary>
        /// Eraser
        /// </summary>
        Eraser = 0x141,
        /// <summary>
        /// Brush
        /// </summary>
        Brush = 0x142,
        /// <summary>
        /// Pencil
        /// </summary>
        Pencil = 0x143,
        /// <summary>
        /// Airbrush
        /// </summary>
        Airbrush = 0x144,
        /// <summary>
        /// Finger
        /// </summary>
        Finger = 0x145,
        /// <summary>
        /// Mouse
        /// </summary>
        Mouse = 0x146,
        /// <summary>
        /// Lens
        /// </summary>
        Lens = 0x147,
    }

    /// <summary> capability flags for a tool </summary>
    public enum Capability : uint
    {
        /// <summary>
        /// Tilt axes
        /// </summary>
        Tilt = 1,
        /// <summary>
        /// Pressure axis
        /// </summary>
        Pressure = 2,
        /// <summary>
        /// Distance axis
        /// </summary>
        Distance = 3,
        /// <summary>
        /// Z-rotation axis
        /// </summary>
        Rotation = 4,
        /// <summary>
        /// Slider axis
        /// </summary>
        Slider = 5,
        /// <summary>
        /// Wheel axis
        /// </summary>
        Wheel = 6,
    }

    /// <summary> physical button state </summary>
    public enum ButtonState : uint
    {
        /// <summary>
        /// button is not pressed
        /// </summary>
        Released = 0,
        /// <summary>
        /// button is pressed
        /// </summary>
        Pressed = 1,
    }

    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// given wl_surface has another role
        /// </summary>
        Role = 0,
    }

    public delegate void TypeHandler(uint toolType);

    private TypeHandler? _onType;

    /// <summary>
    ///Tool type
    /// <para>
    ///
    ///The tool type is the high-level type of the tool and usually decides
    ///the interaction expected from this tool.
    ///
    ///This event is sent in the initial burst of events before the
    ///zwp_tablet_tool_v2.done event.
    ///
    /// </para>
    /// </summary>
    public event TypeHandler? OnType
    {
        add
        {
            CheckDisposed();
            _onType += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onType -= value;
        }
    }

    public delegate void HardwareSerialHandler(uint hardwareSerialHi, uint hardwareSerialLo);

    private HardwareSerialHandler? _onHardwareSerial;

    /// <summary>
    ///Unique hardware serial number of the tool
    /// <para>
    ///
    ///If the physical tool can be identified by a unique 64-bit serial
    ///number, this event notifies the client of this serial number.
    ///
    ///If multiple tablets are available in the same seat and the tool is
    ///uniquely identifiable by the serial number, that tool may move
    ///between tablets.
    ///
    ///Otherwise, if the tool has no serial number and this event is
    ///missing, the tool is tied to the tablet it first comes into
    ///proximity with. Even if the physical tool is used on multiple
    ///tablets, separate zwp_tablet_tool_v2 objects will be created, one per
    ///tablet.
    ///
    ///This event is sent in the initial burst of events before the
    ///zwp_tablet_tool_v2.done event.
    ///
    /// </para>
    /// </summary>
    public event HardwareSerialHandler? OnHardwareSerial
    {
        add
        {
            CheckDisposed();
            _onHardwareSerial += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onHardwareSerial -= value;
        }
    }

    public delegate void HardwareIdWacomHandler(uint hardwareIdHi, uint hardwareIdLo);

    private HardwareIdWacomHandler? _onHardwareIdWacom;

    /// <summary>
    ///Hardware id notification in Wacom's format
    /// <para>
    ///
    ///This event notifies the client of a hardware id available on this tool.
    ///
    ///The hardware id is a device-specific 64-bit id that provides extra
    ///information about the tool in use, beyond the wl_tool.type
    ///enumeration. The format of the id is specific to tablets made by
    ///Wacom Inc. For example, the hardware id of a Wacom Grip
    ///Pen (a stylus) is 0x802.
    ///
    ///This event is sent in the initial burst of events before the
    ///zwp_tablet_tool_v2.done event.
    ///
    /// </para>
    /// </summary>
    public event HardwareIdWacomHandler? OnHardwareIdWacom
    {
        add
        {
            CheckDisposed();
            _onHardwareIdWacom += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onHardwareIdWacom -= value;
        }
    }

    public delegate void CapabilityHandler(uint capability);

    private CapabilityHandler? _onCapability;

    /// <summary>
    ///Tool capability notification
    /// <para>
    ///
    ///This event notifies the client of any capabilities of this tool,
    ///beyond the main set of x/y axes and tip up/down detection.
    ///
    ///One event is sent for each extra capability available on this tool.
    ///
    ///This event is sent in the initial burst of events before the
    ///zwp_tablet_tool_v2.done event.
    ///
    /// </para>
    /// </summary>
    public event CapabilityHandler? OnCapability
    {
        add
        {
            CheckDisposed();
            _onCapability += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onCapability -= value;
        }
    }

    public delegate void DoneHandler();

    private DoneHandler? _onDone;

    /// <summary>
    ///Tool description events sequence complete
    /// <para>
    ///
    ///This event signals the end of the initial burst of descriptive
    ///events. A client may consider the static description of the tool to
    ///be complete and finalize initialization of the tool.
    ///
    /// </para>
    /// </summary>
    public event DoneHandler? OnDone
    {
        add
        {
            CheckDisposed();
            _onDone += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDone -= value;
        }
    }

    public delegate void RemovedHandler();

    private RemovedHandler? _onRemoved;

    /// <summary>
    ///Tool removed
    /// <para>
    ///
    ///This event is sent when the tool is removed from the system and will
    ///send no further events. Should the physical tool come back into
    ///proximity later, a new zwp_tablet_tool_v2 object will be created.
    ///
    ///It is compositor-dependent when a tool is removed. A compositor may
    ///remove a tool on proximity out, tablet removal or any other reason.
    ///A compositor may also keep a tool alive until shutdown.
    ///
    ///If the tool is currently in proximity, a proximity_out event will be
    ///sent before the removed event. See zwp_tablet_tool_v2.proximity_out for
    ///the handling of any buttons logically down.
    ///
    ///When this event is received, the client must zwp_tablet_tool_v2.destroy
    ///the object.
    ///
    /// </para>
    /// </summary>
    public event RemovedHandler? OnRemoved
    {
        add
        {
            CheckDisposed();
            _onRemoved += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onRemoved -= value;
        }
    }

    public delegate void ProximityInHandler(uint serial, ZwpTabletV2 tablet, WlSurface surface);

    private ProximityInHandler? _onProximityIn;

    /// <summary>
    ///Proximity in event
    /// <para>
    ///
    ///Notification that this tool is focused on a certain surface.
    ///
    ///This event can be received when the tool has moved from one surface to
    ///another, or when the tool has come back into proximity above the
    ///surface.
    ///
    ///If any button is logically down when the tool comes into proximity,
    ///the respective button event is sent after the proximity_in event but
    ///within the same frame as the proximity_in event.
    ///
    /// </para>
    /// </summary>
    public event ProximityInHandler? OnProximityIn
    {
        add
        {
            CheckDisposed();
            _onProximityIn += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onProximityIn -= value;
        }
    }

    public delegate void ProximityOutHandler();

    private ProximityOutHandler? _onProximityOut;

    /// <summary>
    ///Proximity out event
    /// <para>
    ///
    ///Notification that this tool has either left proximity, or is no
    ///longer focused on a certain surface.
    ///
    ///When the tablet tool leaves proximity of the tablet, button release
    ///events are sent for each button that was held down at the time of
    ///leaving proximity. These events are sent before the proximity_out
    ///event but within the same zwp_tablet_v2.frame.
    ///
    ///If the tool stays within proximity of the tablet, but the focus
    ///changes from one surface to another, a button release event may not
    ///be sent until the button is actually released or the tool leaves the
    ///proximity of the tablet.
    ///
    /// </para>
    /// </summary>
    public event ProximityOutHandler? OnProximityOut
    {
        add
        {
            CheckDisposed();
            _onProximityOut += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onProximityOut -= value;
        }
    }

    public delegate void DownHandler(uint serial);

    private DownHandler? _onDown;

    /// <summary>
    ///Tablet tool is making contact
    /// <para>
    ///
    ///Sent whenever the tablet tool comes in contact with the surface of the
    ///tablet.
    ///
    ///If the tool is already in contact with the tablet when entering the
    ///input region, the client owning said region will receive a
    ///zwp_tablet_v2.proximity_in event, followed by a zwp_tablet_v2.down
    ///event and a zwp_tablet_v2.frame event.
    ///
    ///Note that this event describes logical contact, not physical
    ///contact. On some devices, a compositor may not consider a tool in
    ///logical contact until a minimum physical pressure threshold is
    ///exceeded.
    ///
    /// </para>
    /// </summary>
    public event DownHandler? OnDown
    {
        add
        {
            CheckDisposed();
            _onDown += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDown -= value;
        }
    }

    public delegate void UpHandler();

    private UpHandler? _onUp;

    /// <summary>
    ///Tablet tool is no longer making contact
    /// <para>
    ///
    ///Sent whenever the tablet tool stops making contact with the surface of
    ///the tablet, or when the tablet tool moves out of the input region
    ///and the compositor grab (if any) is dismissed.
    ///
    ///If the tablet tool moves out of the input region while in contact
    ///with the surface of the tablet and the compositor does not have an
    ///ongoing grab on the surface, the client owning said region will
    ///receive a zwp_tablet_v2.up event, followed by a zwp_tablet_v2.proximity_out
    ///event and a zwp_tablet_v2.frame event. If the compositor has an ongoing
    ///grab on this device, this event sequence is sent whenever the grab
    ///is dismissed in the future.
    ///
    ///Note that this event describes logical contact, not physical
    ///contact. On some devices, a compositor may not consider a tool out
    ///of logical contact until physical pressure falls below a specific
    ///threshold.
    ///
    /// </para>
    /// </summary>
    public event UpHandler? OnUp
    {
        add
        {
            CheckDisposed();
            _onUp += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onUp -= value;
        }
    }

    public delegate void MotionHandler(WlFixed x, WlFixed y);

    private MotionHandler? _onMotion;

    /// <summary>
    ///Motion event
    /// <para>
    ///
    ///Sent whenever a tablet tool moves.
    ///
    /// </para>
    /// </summary>
    public event MotionHandler? OnMotion
    {
        add
        {
            CheckDisposed();
            _onMotion += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onMotion -= value;
        }
    }

    public delegate void PressureHandler(uint pressure);

    private PressureHandler? _onPressure;

    /// <summary>
    ///Pressure change event
    /// <para>
    ///
    ///Sent whenever the pressure axis on a tool changes. The value of this
    ///event is normalized to a value between 0 and 65535.
    ///
    ///Note that pressure may be nonzero even when a tool is not in logical
    ///contact. See the down and up events for more details.
    ///
    /// </para>
    /// </summary>
    public event PressureHandler? OnPressure
    {
        add
        {
            CheckDisposed();
            _onPressure += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPressure -= value;
        }
    }

    public delegate void DistanceHandler(uint distance);

    private DistanceHandler? _onDistance;

    /// <summary>
    ///Distance change event
    /// <para>
    ///
    ///Sent whenever the distance axis on a tool changes. The value of this
    ///event is normalized to a value between 0 and 65535.
    ///
    ///Note that distance may be nonzero even when a tool is not in logical
    ///contact. See the down and up events for more details.
    ///
    /// </para>
    /// </summary>
    public event DistanceHandler? OnDistance
    {
        add
        {
            CheckDisposed();
            _onDistance += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDistance -= value;
        }
    }

    public delegate void TiltHandler(WlFixed tiltX, WlFixed tiltY);

    private TiltHandler? _onTilt;

    /// <summary>
    ///Tilt change event
    /// <para>
    ///
    ///Sent whenever one or both of the tilt axes on a tool change. Each tilt
    ///value is in degrees, relative to the z-axis of the tablet.
    ///The angle is positive when the top of a tool tilts along the
    ///positive x or y axis.
    ///
    /// </para>
    /// </summary>
    public event TiltHandler? OnTilt
    {
        add
        {
            CheckDisposed();
            _onTilt += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onTilt -= value;
        }
    }

    public delegate void RotationHandler(WlFixed degrees);

    private RotationHandler? _onRotation;

    /// <summary>
    ///Z-rotation change event
    /// <para>
    ///
    ///Sent whenever the z-rotation axis on the tool changes. The
    ///rotation value is in degrees clockwise from the tool's
    ///logical neutral position.
    ///
    /// </para>
    /// </summary>
    public event RotationHandler? OnRotation
    {
        add
        {
            CheckDisposed();
            _onRotation += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onRotation -= value;
        }
    }

    public delegate void SliderHandler(int position);

    private SliderHandler? _onSlider;

    /// <summary>
    ///Slider position change event
    /// <para>
    ///
    ///Sent whenever the slider position on the tool changes. The
    ///value is normalized between -65535 and 65535, with 0 as the logical
    ///neutral position of the slider.
    ///
    ///The slider is available on e.g. the Wacom Airbrush tool.
    ///
    /// </para>
    /// </summary>
    public event SliderHandler? OnSlider
    {
        add
        {
            CheckDisposed();
            _onSlider += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onSlider -= value;
        }
    }

    public delegate void WheelHandler(WlFixed degrees, int clicks);

    private WheelHandler? _onWheel;

    /// <summary>
    ///Wheel delta event
    /// <para>
    ///
    ///Sent whenever the wheel on the tool emits an event. This event
    ///contains two values for the same axis change. The degrees value is
    ///in the same orientation as the wl_pointer.vertical_scroll axis. The
    ///clicks value is in discrete logical clicks of the mouse wheel. This
    ///value may be zero if the movement of the wheel was less
    ///than one logical click.
    ///
    ///Clients should choose either value and avoid mixing degrees and
    ///clicks. The compositor may accumulate values smaller than a logical
    ///click and emulate click events when a certain threshold is met.
    ///Thus, zwp_tablet_tool_v2.wheel events with non-zero clicks values may
    ///have different degrees values.
    ///
    /// </para>
    /// </summary>
    public event WheelHandler? OnWheel
    {
        add
        {
            CheckDisposed();
            _onWheel += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onWheel -= value;
        }
    }

    public delegate void ButtonHandler(uint serial, uint button, uint state);

    private ButtonHandler? _onButton;

    /// <summary>
    ///Button event
    /// <para>
    ///
    ///Sent whenever a button on the tool is pressed or released.
    ///
    ///If a button is held down when the tool moves in or out of proximity,
    ///button events are generated by the compositor. See
    ///zwp_tablet_tool_v2.proximity_in and zwp_tablet_tool_v2.proximity_out for
    ///details.
    ///
    /// </para>
    /// </summary>
    public event ButtonHandler? OnButton
    {
        add
        {
            CheckDisposed();
            _onButton += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onButton -= value;
        }
    }

    public delegate void FrameHandler(uint time);

    private FrameHandler? _onFrame;

    /// <summary>
    ///Frame event
    /// <para>
    ///
    ///Marks the end of a series of axis and/or button updates from the
    ///tablet. The Wayland protocol requires axis updates to be sent
    ///sequentially, however all events within a frame should be considered
    ///one hardware event.
    ///
    /// </para>
    /// </summary>
    public event FrameHandler? OnFrame
    {
        add
        {
            CheckDisposed();
            _onFrame += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onFrame -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to zwp_tablet_tool_v2");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (ZwpTabletToolV2)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // type
                    if (obj._onType != null)
                    {
                        var _toolType = args[0].u;
                        obj._onType?.Invoke(_toolType);
                    }
                    break;
                case 1: // hardware_serial
                    if (obj._onHardwareSerial != null)
                    {
                        var _hardwareSerialHi = args[0].u;
                        var _hardwareSerialLo = args[1].u;
                        obj._onHardwareSerial?.Invoke(_hardwareSerialHi, _hardwareSerialLo);
                    }
                    break;
                case 2: // hardware_id_wacom
                    if (obj._onHardwareIdWacom != null)
                    {
                        var _hardwareIdHi = args[0].u;
                        var _hardwareIdLo = args[1].u;
                        obj._onHardwareIdWacom?.Invoke(_hardwareIdHi, _hardwareIdLo);
                    }
                    break;
                case 3: // capability
                    if (obj._onCapability != null)
                    {
                        var _capability = args[0].u;
                        obj._onCapability?.Invoke(_capability);
                    }
                    break;
                case 4: // done
                    if (obj._onDone != null)
                    {
                        obj._onDone?.Invoke();
                    }
                    break;
                case 5: // removed
                    if (obj._onRemoved != null)
                    {
                        obj._onRemoved?.Invoke();
                    }
                    break;
                case 6: // proximity_in
                    if (obj._onProximityIn != null)
                    {
                        var _serial = args[0].u;
                        ZwpTabletV2? _tablet = null;
                        if (args[1].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'tablet'");
                        _tablet = new ZwpTabletV2((IntPtr)args[1].o, obj.Display);
                        WlSurface? _surface = null;
                        if (args[2].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'surface'");
                        _surface = new WlSurface((IntPtr)args[2].o, obj.Display);
                        obj._onProximityIn?.Invoke(_serial, _tablet, _surface);
                    }
                    break;
                case 7: // proximity_out
                    if (obj._onProximityOut != null)
                    {
                        obj._onProximityOut?.Invoke();
                    }
                    break;
                case 8: // down
                    if (obj._onDown != null)
                    {
                        var _serial = args[0].u;
                        obj._onDown?.Invoke(_serial);
                    }
                    break;
                case 9: // up
                    if (obj._onUp != null)
                    {
                        obj._onUp?.Invoke();
                    }
                    break;
                case 10: // motion
                    if (obj._onMotion != null)
                    {
                        var _x = args[0].f;
                        var _y = args[1].f;
                        obj._onMotion?.Invoke(_x, _y);
                    }
                    break;
                case 11: // pressure
                    if (obj._onPressure != null)
                    {
                        var _pressure = args[0].u;
                        obj._onPressure?.Invoke(_pressure);
                    }
                    break;
                case 12: // distance
                    if (obj._onDistance != null)
                    {
                        var _distance = args[0].u;
                        obj._onDistance?.Invoke(_distance);
                    }
                    break;
                case 13: // tilt
                    if (obj._onTilt != null)
                    {
                        var _tiltX = args[0].f;
                        var _tiltY = args[1].f;
                        obj._onTilt?.Invoke(_tiltX, _tiltY);
                    }
                    break;
                case 14: // rotation
                    if (obj._onRotation != null)
                    {
                        var _degrees = args[0].f;
                        obj._onRotation?.Invoke(_degrees);
                    }
                    break;
                case 15: // slider
                    if (obj._onSlider != null)
                    {
                        var _position = args[0].i;
                        obj._onSlider?.Invoke(_position);
                    }
                    break;
                case 16: // wheel
                    if (obj._onWheel != null)
                    {
                        var _degrees = args[0].f;
                        var _clicks = args[1].i;
                        obj._onWheel?.Invoke(_degrees, _clicks);
                    }
                    break;
                case 17: // button
                    if (obj._onButton != null)
                    {
                        var _serial = args[0].u;
                        var _button = args[1].u;
                        var _state = args[2].u;
                        obj._onButton?.Invoke(_serial, _button, _state);
                    }
                    break;
                case 18: // frame
                    if (obj._onFrame != null)
                    {
                        var _time = args[0].u;
                        obj._onFrame?.Invoke(_time);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    /// <summary>
    /// Set the tablet tool's surface
    /// <para>
    /// <br/>
    /// Sets the surface of the cursor used for this tool on the given<br/>
    /// tablet. This request only takes effect if the tool is in proximity<br/>
    /// of one of the requesting client's surfaces or the surface parameter<br/>
    /// is the current pointer surface. If there was a previous surface set<br/>
    /// with this request it is replaced. If surface is NULL, the cursor<br/>
    /// image is hidden.<br/>
    /// <br/>
    /// The parameters hotspot_x and hotspot_y define the position of the<br/>
    /// pointer surface relative to the pointer location. Its top-left corner<br/>
    /// is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the<br/>
    /// coordinates of the pointer location, in surface-local coordinates.<br/>
    /// <br/>
    /// On surface.attach requests to the pointer surface, hotspot_x and<br/>
    /// hotspot_y are decremented by the x and y parameters passed to the<br/>
    /// request. Attach must be confirmed by wl_surface.commit as usual.<br/>
    /// <br/>
    /// The hotspot can also be updated by passing the currently set pointer<br/>
    /// surface to this request with new values for hotspot_x and hotspot_y.<br/>
    /// <br/>
    /// The current and pending input regions of the wl_surface are cleared,<br/>
    /// and wl_surface.set_input_region is ignored until the wl_surface is no<br/>
    /// longer used as the cursor. When the use as a cursor ends, the current<br/>
    /// and pending input regions become undefined, and the wl_surface is<br/>
    /// unmapped.<br/>
    /// <br/>
    /// This request gives the surface the role of a zwp_tablet_tool_v2 cursor. A<br/>
    /// surface may only ever be used as the cursor surface for one<br/>
    /// zwp_tablet_tool_v2. If the surface already has another role or has<br/>
    /// previously been used as cursor surface for a different tool, a<br/>
    /// protocol error is raised.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetCursor(uint serial, WlSurface? surface, int hotspotX, int hotspotY)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].u = serial;
        args[1].o = (WlObject*)(surface?.Handle ?? IntPtr.Zero);
        args[2].i = hotspotX;
        args[3].i = hotspotY;

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Destroy the tool object
    /// <para>
    /// <br/>
    /// This destroys the client's resource for this tool object.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    public static ZwpTabletToolV2 Create(nint handle, WlDisplay display)
    {
        return new ZwpTabletToolV2(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
