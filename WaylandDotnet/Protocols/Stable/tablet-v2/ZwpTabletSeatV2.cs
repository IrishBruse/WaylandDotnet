// <auto-generated>
// This file was generated from tablet-v2.xml
// Stability: Stable
// Link: https://wayland.app/protocols/tablet-v2
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.Stable;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// zwp_tablet_seat_v2
/// <para> controller object for graphic tablet devices of a seat </para>
/// <para> Version: 2 </para>
/// <see>https://wayland.app/protocols/tablet-v2/#zwp_tablet_seat_v2</see>
/// </summary>
public sealed partial class ZwpTabletSeatV2 : WaylandObject, IWaylandObjectFactory<ZwpTabletSeatV2>
{
    public const string InterfaceName = "zwp_tablet_seat_v2";
    public static string _StaticInterfaceName => "zwp_tablet_seat_v2";
    public const int InterfaceVersion = 2;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public ZwpTabletSeatV2(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    public delegate void TabletAddedHandler(ZwpTabletV2 id);

    private TabletAddedHandler? _onTabletAdded;

    /// <summary>
    ///New device notification
    /// <para>
    ///
    ///This event is sent whenever a new tablet becomes available on this
    ///seat. This event only provides the object id of the tablet, any
    ///static information about the tablet (device name, vid/pid, etc.) is
    ///sent through the zwp_tablet_v2 interface.
    ///
    /// </para>
    /// </summary>
    public event TabletAddedHandler? OnTabletAdded
    {
        add
        {
            CheckDisposed();
            _onTabletAdded += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onTabletAdded -= value;
        }
    }

    public delegate void ToolAddedHandler(ZwpTabletToolV2 id);

    private ToolAddedHandler? _onToolAdded;

    /// <summary>
    ///A new tool has been used with a tablet
    /// <para>
    ///
    ///This event is sent whenever a tool that has not previously been used
    ///with a tablet comes into use. This event only provides the object id
    ///of the tool; any static information about the tool (capabilities,
    ///type, etc.) is sent through the zwp_tablet_tool_v2 interface.
    ///
    /// </para>
    /// </summary>
    public event ToolAddedHandler? OnToolAdded
    {
        add
        {
            CheckDisposed();
            _onToolAdded += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onToolAdded -= value;
        }
    }

    public delegate void PadAddedHandler(ZwpTabletPadV2 id);

    private PadAddedHandler? _onPadAdded;

    /// <summary>
    ///New pad notification
    /// <para>
    ///
    ///This event is sent whenever a new pad is known to the system. Typically,
    ///pads are physically attached to tablets and a pad_added event is
    ///sent immediately after the zwp_tablet_seat_v2.tablet_added.
    ///However, some standalone pad devices logically attach to tablets at
    ///runtime, and the client must wait for zwp_tablet_pad_v2.enter to know
    ///the tablet a pad is attached to.
    ///
    ///This event only provides the object id of the pad. All further
    ///features (buttons, strips, rings) are sent through the zwp_tablet_pad_v2
    ///interface.
    ///
    /// </para>
    /// </summary>
    public event PadAddedHandler? OnPadAdded
    {
        add
        {
            CheckDisposed();
            _onPadAdded += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPadAdded -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to zwp_tablet_seat_v2");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (ZwpTabletSeatV2)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // tablet_added
                    if (obj._onTabletAdded != null)
                    {
                        ZwpTabletV2? _id = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'id'");
                        _id = new ZwpTabletV2((IntPtr)args[0].o, obj.Display);
                        obj._onTabletAdded?.Invoke(_id);
                    }
                    break;
                case 1: // tool_added
                    if (obj._onToolAdded != null)
                    {
                        ZwpTabletToolV2? _id = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'id'");
                        _id = new ZwpTabletToolV2((IntPtr)args[0].o, obj.Display);
                        obj._onToolAdded?.Invoke(_id);
                    }
                    break;
                case 2: // pad_added
                    if (obj._onPadAdded != null)
                    {
                        ZwpTabletPadV2? _id = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'id'");
                        _id = new ZwpTabletPadV2((IntPtr)args[0].o, obj.Display);
                        obj._onPadAdded?.Invoke(_id);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    /// <summary>
    /// Release the memory for the tablet seat object
    /// <para>
    /// <br/>
    /// Destroy the zwp_tablet_seat_v2 object. Objects created from this<br/>
    /// object are unaffected and should be destroyed separately.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    public static ZwpTabletSeatV2 Create(nint handle, WlDisplay display)
    {
        return new ZwpTabletSeatV2(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
