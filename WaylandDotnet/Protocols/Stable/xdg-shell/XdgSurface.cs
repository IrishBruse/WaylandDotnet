// <auto-generated>
// This file was generated from xdg-shell.xml
// Stability: Stable
// Link: https://wayland.app/protocols/xdg-shell
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.Stable;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// xdg_surface
/// <para> desktop user interface surface base interface </para>
/// <para> Version: 7 </para>
/// <see>https://wayland.app/protocols/xdg-shell/#xdg_surface</see>
/// </summary>
public sealed partial class XdgSurface : WaylandObject, IWaylandObjectFactory<XdgSurface>
{
    public const string InterfaceName = "xdg_surface";
    public const int InterfaceVersion = 7;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public XdgSurface(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// Surface was not fully constructed
        /// </summary>
        NotConstructed = 1,
        /// <summary>
        /// Surface was already constructed
        /// </summary>
        AlreadyConstructed = 2,
        /// <summary>
        /// Attaching a buffer to an unconfigured surface
        /// </summary>
        UnconfiguredBuffer = 3,
        /// <summary>
        /// Invalid serial number when acking a configure event
        /// </summary>
        InvalidSerial = 4,
        /// <summary>
        /// Width or height was zero or negative
        /// </summary>
        InvalidSize = 5,
        /// <summary>
        /// Surface was destroyed before its role object
        /// </summary>
        DefunctRoleObject = 6,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void ConfigureHandler(uint serial);

    private ConfigureHandler? _onConfigure;

    public event ConfigureHandler? OnConfigure
    {
        add
        {
            CheckDisposed();
            _onConfigure += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onConfigure -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to xdg_surface");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (XdgSurface)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // configure
                    if (obj._onConfigure != null)
                    {
                        var _serial = args[0].u;
                        obj._onConfigure?.Invoke(_serial);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Destroy the xdg_surface
    /// <para>
    /// <br/>
    /// Destroy the xdg_surface object. An xdg_surface must only be destroyed<br/>
    /// after its role object has been destroyed, otherwise<br/>
    /// a defunct_role_object error is raised.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Assign the xdg_toplevel surface role
    /// <para>
    /// <br/>
    /// This creates an xdg_toplevel object for the given xdg_surface and gives<br/>
    /// the associated wl_surface the xdg_toplevel role.<br/>
    /// <br/>
    /// See the documentation of xdg_toplevel for more details about what an<br/>
    /// xdg_toplevel is and how it is used.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe XdgToplevel GetToplevel()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)IntPtr.Zero;

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.XdgToplevel,
            (uint)WaylandInterfaces.XdgToplevel->Version,
            0,
            (nint)args
        );

        return new XdgToplevel(newProxy, Display);
    }

    /// <summary>
    /// Assign the xdg_popup surface role
    /// <para>
    /// <br/>
    /// This creates an xdg_popup object for the given xdg_surface and gives<br/>
    /// the associated wl_surface the xdg_popup role.<br/>
    /// <br/>
    /// If null is passed as a parent, a parent surface must be specified using<br/>
    /// some other protocol, before committing the initial state.<br/>
    /// <br/>
    /// See the documentation of xdg_popup for more details about what an<br/>
    /// xdg_popup is and how it is used.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe XdgPopup GetPopup(XdgSurface? parent, XdgPositioner positioner)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[3];
        args[0].o = (WlObject*)IntPtr.Zero;
        args[1].o = (WlObject*)(parent?.Handle ?? IntPtr.Zero);
        args[2].o = (WlObject*)(positioner?.Handle ?? IntPtr.Zero);

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.XdgPopup,
            (uint)WaylandInterfaces.XdgPopup->Version,
            0,
            (nint)args
        );

        return new XdgPopup(newProxy, Display);
    }

    /// <summary>
    /// Set the new window geometry
    /// <para>
    /// <br/>
    /// The window geometry of a surface is its "visible bounds" from the<br/>
    /// user's perspective. Client-side decorations often have invisible<br/>
    /// portions like drop-shadows which should be ignored for the<br/>
    /// purposes of aligning, placing and constraining windows. Note that<br/>
    /// in some situations, compositors may clip rendering to the window<br/>
    /// geometry, so the client should avoid putting functional elements<br/>
    /// outside of it.<br/>
    /// <br/>
    /// The window geometry is double-buffered state, see wl_surface.commit.<br/>
    /// <br/>
    /// When maintaining a position, the compositor should treat the (x, y)<br/>
    /// coordinate of the window geometry as the top left corner of the window.<br/>
    /// A client changing the (x, y) window geometry coordinate should in<br/>
    /// general not alter the position of the window.<br/>
    /// <br/>
    /// Once the window geometry of the surface is set, it is not possible to<br/>
    /// unset it, and it will remain the same until set_window_geometry is<br/>
    /// called again, even if a new subsurface or buffer is attached.<br/>
    /// <br/>
    /// If never set, the value is the full bounds of the surface,<br/>
    /// including any subsurfaces. This updates dynamically on every<br/>
    /// commit. This unset is meant for extremely simple clients.<br/>
    /// <br/>
    /// The arguments are given in the surface-local coordinate space of<br/>
    /// the wl_surface associated with this xdg_surface, and may extend outside<br/>
    /// of the wl_surface itself to mark parts of the subsurface tree as part of<br/>
    /// the window geometry.<br/>
    /// <br/>
    /// When applied, the effective window geometry will be the set window<br/>
    /// geometry clamped to the bounding rectangle of the combined<br/>
    /// geometry of the surface of the xdg_surface and the associated<br/>
    /// subsurfaces.<br/>
    /// <br/>
    /// The effective geometry will not be recalculated unless a new call to<br/>
    /// set_window_geometry is done and the new pending surface state is<br/>
    /// subsequently applied.<br/>
    /// <br/>
    /// The width and height of the effective window geometry must be<br/>
    /// greater than zero. Setting an invalid size will raise an<br/>
    /// invalid_size error.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetWindowGeometry(int x, int y, int width, int height)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].i = x;
        args[1].i = y;
        args[2].i = width;
        args[3].i = height;

        const uint opcode = 3;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Ack a configure event
    /// <para>
    /// <br/>
    /// When a configure event is received, if a client commits the<br/>
    /// surface in response to the configure event, then the client<br/>
    /// must make an ack_configure request sometime before the commit<br/>
    /// request, passing along the serial of the configure event.<br/>
    /// <br/>
    /// For instance, for toplevel surfaces the compositor might use this<br/>
    /// information to move a surface to the top left only when the client has<br/>
    /// drawn itself for the maximized or fullscreen state.<br/>
    /// <br/>
    /// If the client receives multiple configure events before it<br/>
    /// can respond to one, it only has to ack the last configure event.<br/>
    /// Acking a configure event that was never sent raises an invalid_serial<br/>
    /// error.<br/>
    /// <br/>
    /// A client is not required to commit immediately after sending<br/>
    /// an ack_configure request - it may even ack_configure several times<br/>
    /// before its next surface commit.<br/>
    /// <br/>
    /// A client may send multiple ack_configure requests before committing, but<br/>
    /// only the last request sent before a commit indicates which configure<br/>
    /// event the client really is responding to.<br/>
    /// <br/>
    /// Sending an ack_configure request consumes the serial number sent with<br/>
    /// the request, as well as serial numbers sent by all configure events<br/>
    /// sent on this xdg_surface prior to the configure event referenced by<br/>
    /// the committed serial.<br/>
    /// <br/>
    /// It is an error to issue multiple ack_configure requests referencing a<br/>
    /// serial from the same configure event, or to issue an ack_configure<br/>
    /// request referencing a serial from a configure event issued before the<br/>
    /// event identified by the last ack_configure request for the same<br/>
    /// xdg_surface. Doing so will raise an invalid_serial error.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void AckConfigure(uint serial)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].u = serial;

        const uint opcode = 4;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static XdgSurface Create(nint handle, WlDisplay display)
    {
        return new XdgSurface(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
