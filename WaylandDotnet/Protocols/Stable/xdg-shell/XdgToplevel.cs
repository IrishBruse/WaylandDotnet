// <auto-generated>
// This file was generated from xdg-shell.xml
// Stability: Stable
// Link: https://wayland.app/protocols/xdg-shell
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.Stable;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// xdg_toplevel
/// <para> toplevel surface </para>
/// <para> Version: 7 </para>
/// <see>https://wayland.app/protocols/xdg-shell/#xdg_toplevel</see>
/// </summary>
public sealed partial class XdgToplevel : WaylandObject, IWaylandObjectFactory<XdgToplevel>
{
    public const string InterfaceName = "xdg_toplevel";
    public const int InterfaceVersion = 7;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public XdgToplevel(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// provided value is         not a valid variant of the resize_edge enum
        /// </summary>
        InvalidResizeEdge = 0,
        /// <summary>
        /// invalid parent toplevel
        /// </summary>
        InvalidParent = 1,
        /// <summary>
        /// client provided an invalid min or max size
        /// </summary>
        InvalidSize = 2,
    }

    /// <summary> edge values for resizing </summary>
    public enum ResizeEdge : uint
    {
        /// <summary>
        ///
        /// </summary>
        None = 0,
        /// <summary>
        ///
        /// </summary>
        Top = 1,
        /// <summary>
        ///
        /// </summary>
        Bottom = 2,
        /// <summary>
        ///
        /// </summary>
        Left = 4,
        /// <summary>
        ///
        /// </summary>
        TopLeft = 5,
        /// <summary>
        ///
        /// </summary>
        BottomLeft = 6,
        /// <summary>
        ///
        /// </summary>
        Right = 8,
        /// <summary>
        ///
        /// </summary>
        TopRight = 9,
        /// <summary>
        ///
        /// </summary>
        BottomRight = 10,
    }

    /// <summary> types of state on the surface </summary>
    public enum State : uint
    {
        /// <summary>
        /// the surface is maximized
        /// </summary>
        Maximized = 1,
        /// <summary>
        /// the surface is fullscreen
        /// </summary>
        Fullscreen = 2,
        /// <summary>
        /// the surface is being resized
        /// </summary>
        Resizing = 3,
        /// <summary>
        /// the surface is now activated
        /// </summary>
        Activated = 4,
        /// <summary>
        ///
        /// </summary>
        TiledLeft = 5,
        /// <summary>
        ///
        /// </summary>
        TiledRight = 6,
        /// <summary>
        ///
        /// </summary>
        TiledTop = 7,
        /// <summary>
        ///
        /// </summary>
        TiledBottom = 8,
        /// <summary>
        ///
        /// </summary>
        Suspended = 9,
        /// <summary>
        ///
        /// </summary>
        ConstrainedLeft = 10,
        /// <summary>
        ///
        /// </summary>
        ConstrainedRight = 11,
        /// <summary>
        ///
        /// </summary>
        ConstrainedTop = 12,
        /// <summary>
        ///
        /// </summary>
        ConstrainedBottom = 13,
    }

    /// <summary>  </summary>
    public enum WmCapabilities : uint
    {
        /// <summary>
        /// show_window_menu is available
        /// </summary>
        WindowMenu = 1,
        /// <summary>
        /// set_maximized and unset_maximized are available
        /// </summary>
        Maximize = 2,
        /// <summary>
        /// set_fullscreen and unset_fullscreen are available
        /// </summary>
        Fullscreen = 3,
        /// <summary>
        /// set_minimized is available
        /// </summary>
        Minimize = 4,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void ConfigureHandler(int width, int height, byte[] states);

    private ConfigureHandler? _onConfigure;

    public event ConfigureHandler? OnConfigure
    {
        add
        {
            CheckDisposed();
            _onConfigure += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onConfigure -= value;
        }
    }

    public delegate void CloseHandler();

    private CloseHandler? _onClose;

    public event CloseHandler? OnClose
    {
        add
        {
            CheckDisposed();
            _onClose += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onClose -= value;
        }
    }

    public delegate void ConfigureBoundsHandler(int width, int height);

    private ConfigureBoundsHandler? _onConfigureBounds;

    public event ConfigureBoundsHandler? OnConfigureBounds
    {
        add
        {
            CheckDisposed();
            _onConfigureBounds += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onConfigureBounds -= value;
        }
    }

    public delegate void WmCapabilitiesHandler(byte[] capabilities);

    private WmCapabilitiesHandler? _onWmCapabilities;

    public event WmCapabilitiesHandler? OnWmCapabilities
    {
        add
        {
            CheckDisposed();
            _onWmCapabilities += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onWmCapabilities -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to xdg_toplevel");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (XdgToplevel)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // configure
                    if (obj._onConfigure != null)
                    {
                        var _width = args[0].i;
                        var _height = args[1].i;
                        var _states = args[2].a;
                        obj._onConfigure?.Invoke(_width, _height, WaylandMarshal.ToSpan(_states));
                    }
                    break;
                case 1: // close
                    if (obj._onClose != null)
                    {
                        obj._onClose?.Invoke();
                    }
                    break;
                case 2: // configure_bounds
                    if (obj._onConfigureBounds != null)
                    {
                        var _width = args[0].i;
                        var _height = args[1].i;
                        obj._onConfigureBounds?.Invoke(_width, _height);
                    }
                    break;
                case 3: // wm_capabilities
                    if (obj._onWmCapabilities != null)
                    {
                        var _capabilities = args[0].a;
                        obj._onWmCapabilities?.Invoke(WaylandMarshal.ToSpan(_capabilities));
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Destroy the xdg_toplevel
    /// <para>
    /// <br/>
    /// This request destroys the role surface and unmaps the surface;<br/>
    /// see "Unmapping" behavior in interface section for details.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set the parent of this surface
    /// <para>
    /// <br/>
    /// Set the "parent" of this surface. This surface should be stacked<br/>
    /// above the parent surface and all other ancestor surfaces.<br/>
    /// <br/>
    /// Parent surfaces should be set on dialogs, toolboxes, or other<br/>
    /// "auxiliary" surfaces, so that the parent is raised when the dialog<br/>
    /// is raised.<br/>
    /// <br/>
    /// Setting a null parent for a child surface unsets its parent. Setting<br/>
    /// a null parent for a surface which currently has no parent is a no-op.<br/>
    /// <br/>
    /// Only mapped surfaces can have child surfaces. Setting a parent which<br/>
    /// is not mapped is equivalent to setting a null parent. If a surface<br/>
    /// becomes unmapped, its children's parent is set to the parent of<br/>
    /// the now-unmapped surface. If the now-unmapped surface has no parent,<br/>
    /// its children's parent is unset. If the now-unmapped surface becomes<br/>
    /// mapped again, its parent-child relationship is not restored.<br/>
    /// <br/>
    /// The parent toplevel must not be one of the child toplevel's<br/>
    /// descendants, and the parent must be different from the child toplevel,<br/>
    /// otherwise the invalid_parent protocol error is raised.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetParent(XdgToplevel? parent)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)(parent?.Handle ?? IntPtr.Zero);

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set surface title
    /// <para>
    /// <br/>
    /// Set a short title for the surface.<br/>
    /// <br/>
    /// This string may be used to identify the surface in a task bar,<br/>
    /// window list, or other user interface elements provided by the<br/>
    /// compositor.<br/>
    /// <br/>
    /// The string must be encoded in UTF-8.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetTitle(string title)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].s = Utf8StringMarshaller.ConvertToUnmanaged(title);

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set application ID
    /// <para>
    /// <br/>
    /// Set an application identifier for the surface.<br/>
    /// <br/>
    /// The app ID identifies the general class of applications to which<br/>
    /// the surface belongs. The compositor can use this to group multiple<br/>
    /// surfaces together, or to determine how to launch a new application.<br/>
    /// <br/>
    /// For D-Bus activatable applications, the app ID is used as the D-Bus<br/>
    /// service name.<br/>
    /// <br/>
    /// The compositor shell will try to group application surfaces together<br/>
    /// by their app ID. As a best practice, it is suggested to select app<br/>
    /// ID's that match the basename of the application's .desktop file.<br/>
    /// For example, "org.freedesktop.FooViewer" where the .desktop file is<br/>
    /// "org.freedesktop.FooViewer.desktop".<br/>
    /// <br/>
    /// Like other properties, a set_app_id request can be sent after the<br/>
    /// xdg_toplevel has been mapped to update the property.<br/>
    /// <br/>
    /// See the desktop-entry specification [0] for more details on<br/>
    /// application identifiers and how they relate to well-known D-Bus<br/>
    /// names and .desktop files.<br/>
    /// <br/>
    /// [0] https://standards.freedesktop.org/desktop-entry-spec/<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetAppId(string appId)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].s = Utf8StringMarshaller.ConvertToUnmanaged(appId);

        const uint opcode = 3;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Show the window menu
    /// <para>
    /// <br/>
    /// Clients implementing client-side decorations might want to show<br/>
    /// a context menu when right-clicking on the decorations, giving the<br/>
    /// user a menu that they can use to maximize or minimize the window.<br/>
    /// <br/>
    /// This request asks the compositor to pop up such a window menu at<br/>
    /// the given position, relative to the local surface coordinates of<br/>
    /// the parent surface. There are no guarantees as to what menu items<br/>
    /// the window menu contains, or even if a window menu will be drawn<br/>
    /// at all.<br/>
    /// <br/>
    /// This request must be used in response to some sort of user action<br/>
    /// like a button press, key press, or touch down event.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void ShowWindowMenu(WlSeat seat, uint serial, int x, int y)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].o = (WlObject*)(seat?.Handle ?? IntPtr.Zero);
        args[1].u = serial;
        args[2].i = x;
        args[3].i = y;

        const uint opcode = 4;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Start an interactive move
    /// <para>
    /// <br/>
    /// Start an interactive, user-driven move of the surface.<br/>
    /// <br/>
    /// This request must be used in response to some sort of user action<br/>
    /// like a button press, key press, or touch down event. The passed<br/>
    /// serial is used to determine the type of interactive move (touch,<br/>
    /// pointer, etc).<br/>
    /// <br/>
    /// The server may ignore move requests depending on the state of<br/>
    /// the surface (e.g. fullscreen or maximized), or if the passed serial<br/>
    /// is no longer valid.<br/>
    /// <br/>
    /// If triggered, the surface will lose the focus of the device<br/>
    /// (wl_pointer, wl_touch, etc) used for the move. It is up to the<br/>
    /// compositor to visually indicate that the move is taking place, such as<br/>
    /// updating a pointer cursor, during the move. There is no guarantee<br/>
    /// that the device focus will return when the move is completed.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Move(WlSeat seat, uint serial)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].o = (WlObject*)(seat?.Handle ?? IntPtr.Zero);
        args[1].u = serial;

        const uint opcode = 5;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Start an interactive resize
    /// <para>
    /// <br/>
    /// Start a user-driven, interactive resize of the surface.<br/>
    /// <br/>
    /// This request must be used in response to some sort of user action<br/>
    /// like a button press, key press, or touch down event. The passed<br/>
    /// serial is used to determine the type of interactive resize (touch,<br/>
    /// pointer, etc).<br/>
    /// <br/>
    /// The server may ignore resize requests depending on the state of<br/>
    /// the surface (e.g. fullscreen or maximized).<br/>
    /// <br/>
    /// If triggered, the client will receive configure events with the<br/>
    /// "resize" state enum value and the expected sizes. See the "resize"<br/>
    /// enum value for more details about what is required. The client<br/>
    /// must also acknowledge configure events using "ack_configure". After<br/>
    /// the resize is completed, the client will receive another "configure"<br/>
    /// event without the resize state.<br/>
    /// <br/>
    /// If triggered, the surface also will lose the focus of the device<br/>
    /// (wl_pointer, wl_touch, etc) used for the resize. It is up to the<br/>
    /// compositor to visually indicate that the resize is taking place,<br/>
    /// such as updating a pointer cursor, during the resize. There is no<br/>
    /// guarantee that the device focus will return when the resize is<br/>
    /// completed.<br/>
    /// <br/>
    /// The edges parameter specifies how the surface should be resized, and<br/>
    /// is one of the values of the resize_edge enum. Values not matching<br/>
    /// a variant of the enum will cause the invalid_resize_edge protocol error.<br/>
    /// The compositor may use this information to update the surface position<br/>
    /// for example when dragging the top left corner. The compositor may also<br/>
    /// use this information to adapt its behavior, e.g. choose an appropriate<br/>
    /// cursor image.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Resize(WlSeat seat, uint serial, uint edges)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[3];
        args[0].o = (WlObject*)(seat?.Handle ?? IntPtr.Zero);
        args[1].u = serial;
        args[2].u = edges;

        const uint opcode = 6;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set the maximum size
    /// <para>
    /// <br/>
    /// Set a maximum size for the window.<br/>
    /// <br/>
    /// The client can specify a maximum size so that the compositor does<br/>
    /// not try to configure the window beyond this size.<br/>
    /// <br/>
    /// The width and height arguments are in window geometry coordinates.<br/>
    /// See xdg_surface.set_window_geometry.<br/>
    /// <br/>
    /// Values set in this way are double-buffered, see wl_surface.commit.<br/>
    /// <br/>
    /// The compositor can use this information to allow or disallow<br/>
    /// different states like maximize or fullscreen and draw accurate<br/>
    /// animations.<br/>
    /// <br/>
    /// Similarly, a tiling window manager may use this information to<br/>
    /// place and resize client windows in a more effective way.<br/>
    /// <br/>
    /// The client should not rely on the compositor to obey the maximum<br/>
    /// size. The compositor may decide to ignore the values set by the<br/>
    /// client and request a larger size.<br/>
    /// <br/>
    /// If never set, or a value of zero in the request, means that the<br/>
    /// client has no expected maximum size in the given dimension.<br/>
    /// As a result, a client wishing to reset the maximum size<br/>
    /// to an unspecified state can use zero for width and height in the<br/>
    /// request.<br/>
    /// <br/>
    /// Requesting a maximum size to be smaller than the minimum size of<br/>
    /// a surface is illegal and will result in an invalid_size error.<br/>
    /// <br/>
    /// The width and height must be greater than or equal to zero. Using<br/>
    /// strictly negative values for width or height will result in a<br/>
    /// invalid_size error.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetMaxSize(int width, int height)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].i = width;
        args[1].i = height;

        const uint opcode = 7;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set the minimum size
    /// <para>
    /// <br/>
    /// Set a minimum size for the window.<br/>
    /// <br/>
    /// The client can specify a minimum size so that the compositor does<br/>
    /// not try to configure the window below this size.<br/>
    /// <br/>
    /// The width and height arguments are in window geometry coordinates.<br/>
    /// See xdg_surface.set_window_geometry.<br/>
    /// <br/>
    /// Values set in this way are double-buffered, see wl_surface.commit.<br/>
    /// <br/>
    /// The compositor can use this information to allow or disallow<br/>
    /// different states like maximize or fullscreen and draw accurate<br/>
    /// animations.<br/>
    /// <br/>
    /// Similarly, a tiling window manager may use this information to<br/>
    /// place and resize client windows in a more effective way.<br/>
    /// <br/>
    /// The client should not rely on the compositor to obey the minimum<br/>
    /// size. The compositor may decide to ignore the values set by the<br/>
    /// client and request a smaller size.<br/>
    /// <br/>
    /// If never set, or a value of zero in the request, means that the<br/>
    /// client has no expected minimum size in the given dimension.<br/>
    /// As a result, a client wishing to reset the minimum size<br/>
    /// to an unspecified state can use zero for width and height in the<br/>
    /// request.<br/>
    /// <br/>
    /// Requesting a minimum size to be larger than the maximum size of<br/>
    /// a surface is illegal and will result in an invalid_size error.<br/>
    /// <br/>
    /// The width and height must be greater than or equal to zero. Using<br/>
    /// strictly negative values for width and height will result in a<br/>
    /// invalid_size error.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetMinSize(int width, int height)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].i = width;
        args[1].i = height;

        const uint opcode = 8;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Maximize the window
    /// <para>
    /// <br/>
    /// Maximize the surface.<br/>
    /// <br/>
    /// After requesting that the surface should be maximized, the compositor<br/>
    /// will respond by emitting a configure event. Whether this configure<br/>
    /// actually sets the window maximized is subject to compositor policies.<br/>
    /// The client must then update its content, drawing in the configured<br/>
    /// state. The client must also acknowledge the configure when committing<br/>
    /// the new content (see ack_configure).<br/>
    /// <br/>
    /// It is up to the compositor to decide how and where to maximize the<br/>
    /// surface, for example which output and what region of the screen should<br/>
    /// be used.<br/>
    /// <br/>
    /// If the surface was already maximized, the compositor will still emit<br/>
    /// a configure event with the "maximized" state.<br/>
    /// <br/>
    /// If the surface is in a fullscreen state, this request has no direct<br/>
    /// effect. It may alter the state the surface is returned to when<br/>
    /// unmaximized unless overridden by the compositor.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetMaximized()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 9;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Unmaximize the window
    /// <para>
    /// <br/>
    /// Unmaximize the surface.<br/>
    /// <br/>
    /// After requesting that the surface should be unmaximized, the compositor<br/>
    /// will respond by emitting a configure event. Whether this actually<br/>
    /// un-maximizes the window is subject to compositor policies.<br/>
    /// If available and applicable, the compositor will include the window<br/>
    /// geometry dimensions the window had prior to being maximized in the<br/>
    /// configure event. The client must then update its content, drawing it in<br/>
    /// the configured state. The client must also acknowledge the configure<br/>
    /// when committing the new content (see ack_configure).<br/>
    /// <br/>
    /// It is up to the compositor to position the surface after it was<br/>
    /// unmaximized; usually the position the surface had before maximizing, if<br/>
    /// applicable.<br/>
    /// <br/>
    /// If the surface was already not maximized, the compositor will still<br/>
    /// emit a configure event without the "maximized" state.<br/>
    /// <br/>
    /// If the surface is in a fullscreen state, this request has no direct<br/>
    /// effect. It may alter the state the surface is returned to when<br/>
    /// unmaximized unless overridden by the compositor.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void UnsetMaximized()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 10;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set the window as fullscreen on an output
    /// <para>
    /// <br/>
    /// Make the surface fullscreen.<br/>
    /// <br/>
    /// After requesting that the surface should be fullscreened, the<br/>
    /// compositor will respond by emitting a configure event. Whether the<br/>
    /// client is actually put into a fullscreen state is subject to compositor<br/>
    /// policies. The client must also acknowledge the configure when<br/>
    /// committing the new content (see ack_configure).<br/>
    /// <br/>
    /// The output passed by the request indicates the client's preference as<br/>
    /// to which display it should be set fullscreen on. If this value is NULL,<br/>
    /// it's up to the compositor to choose which display will be used to map<br/>
    /// this surface.<br/>
    /// <br/>
    /// If the surface doesn't cover the whole output, the compositor will<br/>
    /// position the surface in the center of the output and compensate with<br/>
    /// with border fill covering the rest of the output. The content of the<br/>
    /// border fill is undefined, but should be assumed to be in some way that<br/>
    /// attempts to blend into the surrounding area (e.g. solid black).<br/>
    /// <br/>
    /// If the fullscreened surface is not opaque, the compositor must make<br/>
    /// sure that other screen content not part of the same surface tree (made<br/>
    /// up of subsurfaces, popups or similarly coupled surfaces) are not<br/>
    /// visible below the fullscreened surface.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetFullscreen(WlOutput? output)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)(output?.Handle ?? IntPtr.Zero);

        const uint opcode = 11;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Unset the window as fullscreen
    /// <para>
    /// <br/>
    /// Make the surface no longer fullscreen.<br/>
    /// <br/>
    /// After requesting that the surface should be unfullscreened, the<br/>
    /// compositor will respond by emitting a configure event.<br/>
    /// Whether this actually removes the fullscreen state of the client is<br/>
    /// subject to compositor policies.<br/>
    /// <br/>
    /// Making a surface unfullscreen sets states for the surface based on the following:<br/>
    /// * the state(s) it may have had before becoming fullscreen<br/>
    /// * any state(s) decided by the compositor<br/>
    /// * any state(s) requested by the client while the surface was fullscreen<br/>
    /// <br/>
    /// The compositor may include the previous window geometry dimensions in<br/>
    /// the configure event, if applicable.<br/>
    /// <br/>
    /// The client must also acknowledge the configure when committing the new<br/>
    /// content (see ack_configure).<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void UnsetFullscreen()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 12;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set the window as minimized
    /// <para>
    /// <br/>
    /// Request that the compositor minimize your surface. There is no<br/>
    /// way to know if the surface is currently minimized, nor is there<br/>
    /// any way to unset minimization on this surface.<br/>
    /// <br/>
    /// If you are looking to throttle redrawing when minimized, please<br/>
    /// instead use the wl_surface.frame event for this, as this will<br/>
    /// also work with live previews on windows in Alt-Tab, Expose or<br/>
    /// similar compositor features.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetMinimized()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 13;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static XdgToplevel Create(nint handle, WlDisplay display)
    {
        return new XdgToplevel(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
