// <auto-generated>
// This file was generated from xdg-shell.xml
// Stability: Stable
// Link: https://wayland.app/protocols/xdg-shell
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.Stable;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// xdg_popup
/// <para> short-lived, popup surfaces for menus </para>
/// <para> Version: 7 </para>
/// <see>https://wayland.app/protocols/xdg-shell/#xdg_popup</see>
/// </summary>
public sealed partial class XdgPopup : WaylandObject, IWaylandObjectFactory<XdgPopup>
{
    public const string InterfaceName = "xdg_popup";
    public static string _StaticInterfaceName => "xdg_popup";
    public const int InterfaceVersion = 7;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public XdgPopup(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// tried to grab after being mapped
        /// </summary>
        InvalidGrab = 0,
    }

    public delegate void ConfigureHandler(int x, int y, int width, int height);

    private ConfigureHandler? _onConfigure;

    /// <summary>
    ///Configure the popup surface
    /// <para>
    ///
    ///This event asks the popup surface to configure itself given the
    ///configuration. The configured state should not be applied immediately.
    ///See xdg_surface.configure for details.
    ///
    ///The x and y arguments represent the position the popup was placed at
    ///given the xdg_positioner rule, relative to the upper left corner of the
    ///window geometry of the parent surface.
    ///
    ///For version 2 or older, the configure event for an xdg_popup is only
    ///ever sent once for the initial configuration. Starting with version 3,
    ///it may be sent again if the popup is setup with an xdg_positioner with
    ///set_reactive requested, or in response to xdg_popup.reposition requests.
    ///
    /// </para>
    /// </summary>
    public event ConfigureHandler? OnConfigure
    {
        add
        {
            CheckDisposed();
            _onConfigure += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onConfigure -= value;
        }
    }

    public delegate void PopupDoneHandler();

    private PopupDoneHandler? _onPopupDone;

    /// <summary>
    ///Popup interaction is done
    /// <para>
    ///
    ///The popup_done event is sent out when a popup is dismissed by the
    ///compositor. The client should destroy the xdg_popup object at this
    ///point.
    ///
    /// </para>
    /// </summary>
    public event PopupDoneHandler? OnPopupDone
    {
        add
        {
            CheckDisposed();
            _onPopupDone += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPopupDone -= value;
        }
    }

    public delegate void RepositionedHandler(uint token);

    private RepositionedHandler? _onRepositioned;

    /// <summary>
    ///Signal the completion of a repositioned request
    /// <para>
    ///
    ///The repositioned event is sent as part of a popup configuration
    ///sequence, together with xdg_popup.configure and lastly
    ///xdg_surface.configure to notify the completion of a reposition request.
    ///
    ///The repositioned event is to notify about the completion of a
    ///xdg_popup.reposition request. The token argument is the token passed
    ///in the xdg_popup.reposition request.
    ///
    ///Immediately after this event is emitted, xdg_popup.configure and
    ///xdg_surface.configure will be sent with the updated size and position,
    ///as well as a new configure serial.
    ///
    ///The client should optionally update the content of the popup, but must
    ///acknowledge the new popup configuration for the new position to take
    ///effect. See xdg_surface.ack_configure for details.
    ///
    /// </para>
    /// </summary>
    public event RepositionedHandler? OnRepositioned
    {
        add
        {
            CheckDisposed();
            _onRepositioned += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onRepositioned -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to xdg_popup");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (XdgPopup)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // configure
                    if (obj._onConfigure != null)
                    {
                        var _x = args[0].i;
                        var _y = args[1].i;
                        var _width = args[2].i;
                        var _height = args[3].i;
                        obj._onConfigure?.Invoke(_x, _y, _width, _height);
                    }
                    break;
                case 1: // popup_done
                    if (obj._onPopupDone != null)
                    {
                        obj._onPopupDone?.Invoke();
                    }
                    break;
                case 2: // repositioned
                    if (obj._onRepositioned != null)
                    {
                        var _token = args[0].u;
                        obj._onRepositioned?.Invoke(_token);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    /// <summary>
    /// Remove xdg_popup interface
    /// <para>
    /// <br/>
    /// This destroys the popup. Explicitly destroying the xdg_popup<br/>
    /// object will also dismiss the popup, and unmap the surface.<br/>
    /// <br/>
    /// If this xdg_popup is not the "topmost" popup, the<br/>
    /// xdg_wm_base.not_the_topmost_popup protocol error will be sent.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Make the popup take an explicit grab
    /// <para>
    /// <br/>
    /// This request makes the created popup take an explicit grab. An explicit<br/>
    /// grab will be dismissed when the user dismisses the popup, or when the<br/>
    /// client destroys the xdg_popup. This can be done by the user clicking<br/>
    /// outside the surface, using the keyboard, or even locking the screen<br/>
    /// through closing the lid or a timeout.<br/>
    /// <br/>
    /// If the compositor denies the grab, the popup will be immediately<br/>
    /// dismissed.<br/>
    /// <br/>
    /// This request must be used in response to some sort of user action like a<br/>
    /// button press, key press, or touch down event. The serial number of the<br/>
    /// event should be passed as 'serial'.<br/>
    /// <br/>
    /// The parent of a grabbing popup must either be an xdg_toplevel surface or<br/>
    /// another xdg_popup with an explicit grab. If the parent is another<br/>
    /// xdg_popup it means that the popups are nested, with this popup now being<br/>
    /// the topmost popup.<br/>
    /// <br/>
    /// Nested popups must be destroyed in the reverse order they were created<br/>
    /// in, e.g. the only popup you are allowed to destroy at all times is the<br/>
    /// topmost one.<br/>
    /// <br/>
    /// When compositors choose to dismiss a popup, they may dismiss every<br/>
    /// nested grabbing popup as well. When a compositor dismisses popups, it<br/>
    /// will follow the same dismissing order as required from the client.<br/>
    /// <br/>
    /// If the topmost grabbing popup is destroyed, the grab will be returned to<br/>
    /// the parent of the popup, if that parent previously had an explicit grab.<br/>
    /// <br/>
    /// If the parent is a grabbing popup which has already been dismissed, this<br/>
    /// popup will be immediately dismissed. If the parent is a popup that did<br/>
    /// not take an explicit grab, an error will be raised.<br/>
    /// <br/>
    /// During a popup grab, the client owning the grab will receive pointer<br/>
    /// and touch events for all their surfaces as normal (similar to an<br/>
    /// "owner-events" grab in X11 parlance), while the top most grabbing popup<br/>
    /// will always have keyboard focus.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Grab(WlSeat seat, uint serial)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].o = (WlObject*)(seat?.Handle ?? IntPtr.Zero);
        args[1].u = serial;

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Recalculate the popup's location
    /// <para>
    /// <br/>
    /// Reposition an already-mapped popup. The popup will be placed given the<br/>
    /// details in the passed xdg_positioner object, and a<br/>
    /// xdg_popup.repositioned followed by xdg_popup.configure and<br/>
    /// xdg_surface.configure will be emitted in response. Any parameters set<br/>
    /// by the previous positioner will be discarded.<br/>
    /// <br/>
    /// The passed token will be sent in the corresponding<br/>
    /// xdg_popup.repositioned event. The new popup position will not take<br/>
    /// effect until the corresponding configure event is acknowledged by the<br/>
    /// client. See xdg_popup.repositioned for details. The token itself is<br/>
    /// opaque, and has no other special meaning.<br/>
    /// <br/>
    /// If multiple reposition requests are sent, the compositor may skip all<br/>
    /// but the last one.<br/>
    /// <br/>
    /// If the popup is repositioned in response to a configure event for its<br/>
    /// parent, the client should send an xdg_positioner.set_parent_configure<br/>
    /// and possibly an xdg_positioner.set_parent_size request to allow the<br/>
    /// compositor to properly constrain the popup.<br/>
    /// <br/>
    /// If the popup is repositioned together with a parent that is being<br/>
    /// resized, but not in response to a configure event, the client should<br/>
    /// send an xdg_positioner.set_parent_size request.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Reposition(XdgPositioner positioner, uint token)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].o = (WlObject*)(positioner?.Handle ?? IntPtr.Zero);
        args[1].u = token;

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    public static XdgPopup Create(nint handle, WlDisplay display)
    {
        return new XdgPopup(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
