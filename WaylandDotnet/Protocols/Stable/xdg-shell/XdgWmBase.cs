// <auto-generated>
// This file was generated from xdg-shell.xml
// Stability: Stable
// Link: https://wayland.app/protocols/xdg-shell
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.Stable;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// xdg_wm_base
/// <para> create desktop-style surfaces </para>
/// <para> Version: 7 </para>
/// <see>https://wayland.app/protocols/xdg-shell/#xdg_wm_base</see>
/// </summary>
public sealed partial class XdgWmBase : WaylandObject, IWaylandObjectFactory<XdgWmBase>
{
    public const string InterfaceName = "xdg_wm_base";
    public static string _StaticInterfaceName => "xdg_wm_base";
    public const int InterfaceVersion = 7;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public XdgWmBase(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// given wl_surface has another role
        /// </summary>
        Role = 0,
        /// <summary>
        /// xdg_wm_base was destroyed before children
        /// </summary>
        DefunctSurfaces = 1,
        /// <summary>
        /// the client tried to map or destroy a non-topmost popup
        /// </summary>
        NotTheTopmostPopup = 2,
        /// <summary>
        /// the client specified an invalid popup parent surface
        /// </summary>
        InvalidPopupParent = 3,
        /// <summary>
        /// the client provided an invalid surface state
        /// </summary>
        InvalidSurfaceState = 4,
        /// <summary>
        /// the client provided an invalid positioner
        /// </summary>
        InvalidPositioner = 5,
        /// <summary>
        /// the client didn’t respond to a ping event in time
        /// </summary>
        Unresponsive = 6,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void PingHandler(uint serial);

    private PingHandler? _onPing;

    /// <summary>
    ///Check if the client is alive
    /// <para>
    ///
    ///The ping event asks the client if it's still alive. Pass the
    ///serial specified in the event back to the compositor by sending
    ///a "pong" request back with the specified serial. See xdg_wm_base.pong.
    ///
    ///Compositors can use this to determine if the client is still
    ///alive. It's unspecified what will happen if the client doesn't
    ///respond to the ping request, or in what timeframe. Clients should
    ///try to respond in a reasonable amount of time. The “unresponsive”
    ///error is provided for compositors that wish to disconnect unresponsive
    ///clients.
    ///
    ///A compositor is free to ping in any way it wants, but a client must
    ///always respond to any xdg_wm_base object it created.
    ///
    /// </para>
    /// </summary>
    public event PingHandler? OnPing
    {
        add
        {
            CheckDisposed();
            _onPing += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPing -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to xdg_wm_base");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (XdgWmBase)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // ping
                    if (obj._onPing != null)
                    {
                        var _serial = args[0].u;
                        obj._onPing?.Invoke(_serial);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Destroy xdg_wm_base
    /// <para>
    /// <br/>
    /// Destroy this xdg_wm_base object.<br/>
    /// <br/>
    /// Destroying a bound xdg_wm_base object while there are surfaces<br/>
    /// still alive created by this xdg_wm_base object instance is illegal<br/>
    /// and will result in a defunct_surfaces error.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Create a positioner object
    /// <para>
    /// <br/>
    /// Create a positioner object. A positioner object is used to position<br/>
    /// surfaces relative to some parent surface. See the interface description<br/>
    /// and xdg_surface.get_popup for details.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe XdgPositioner CreatePositioner()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)IntPtr.Zero;

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.XdgPositioner,
            (uint)WaylandInterfaces.XdgPositioner->Version,
            0,
            (nint)args
        );

        return new XdgPositioner(newProxy, Display);
    }

    /// <summary>
    /// Create a shell surface from a surface
    /// <para>
    /// <br/>
    /// This creates an xdg_surface for the given surface. While xdg_surface<br/>
    /// itself is not a role, the corresponding surface may only be assigned<br/>
    /// a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is<br/>
    /// illegal to create an xdg_surface for a wl_surface which already has an<br/>
    /// assigned role and this will result in a role error.<br/>
    /// <br/>
    /// This creates an xdg_surface for the given surface. An xdg_surface is<br/>
    /// used as basis to define a role to a given surface, such as xdg_toplevel<br/>
    /// or xdg_popup. It also manages functionality shared between xdg_surface<br/>
    /// based surface roles.<br/>
    /// <br/>
    /// See the documentation of xdg_surface for more details about what an<br/>
    /// xdg_surface is and how it is used.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe XdgSurface GetXdgSurface(WlSurface surface)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].o = (WlObject*)IntPtr.Zero;
        args[1].o = (WlObject*)(surface?.Handle ?? IntPtr.Zero);

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.XdgSurface,
            (uint)WaylandInterfaces.XdgSurface->Version,
            0,
            (nint)args
        );

        return new XdgSurface(newProxy, Display);
    }

    /// <summary>
    /// Respond to a ping event
    /// <para>
    /// <br/>
    /// A client must respond to a ping event with a pong request or<br/>
    /// the client may be deemed unresponsive. See xdg_wm_base.ping<br/>
    /// and xdg_wm_base.error.unresponsive.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Pong(uint serial)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].u = serial;

        const uint opcode = 3;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static XdgWmBase Create(nint handle, WlDisplay display)
    {
        return new XdgWmBase(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
