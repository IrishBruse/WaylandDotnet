// <auto-generated>
// This file was generated from presentation-time.xml
// Stability: Stable
// Link: https://wayland.app/protocols/presentation-time
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.Stable;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wp_presentation
/// <para> timed presentation related wl_surface requests </para>
/// <para> Version: 2 </para>
/// <see>https://wayland.app/protocols/presentation-time/#wp_presentation</see>
/// </summary>
public sealed partial class WpPresentation : WaylandObject, IWaylandObjectFactory<WpPresentation>
{
    public const string InterfaceName = "wp_presentation";
    public static string _StaticInterfaceName => "wp_presentation";
    public const int InterfaceVersion = 2;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public WpPresentation(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    /// <summary> fatal presentation errors </summary>
    public enum Error : uint
    {
        /// <summary>
        /// invalid value in tv_nsec
        /// </summary>
        InvalidTimestamp = 0,
        /// <summary>
        /// invalid flag
        /// </summary>
        InvalidFlag = 1,
    }

    public delegate void ClockIdHandler(uint clkId);

    private ClockIdHandler? _onClockId;

    /// <summary>
    ///Clock ID for timestamps
    /// <para>
    ///
    ///This event tells the client in which clock domain the
    ///compositor interprets the timestamps used by the presentation
    ///extension. This clock is called the presentation clock.
    ///
    ///The compositor sends this event when the client binds to the
    ///presentation interface. The presentation clock does not change
    ///during the lifetime of the client connection.
    ///
    ///The clock identifier is platform dependent. On POSIX platforms, the
    ///identifier value is one of the clockid_t values accepted by
    ///clock_gettime(). clock_gettime() is defined by POSIX.1-2001.
    ///
    ///Timestamps in this clock domain are expressed as tv_sec_hi,
    ///tv_sec_lo, tv_nsec triples, each component being an unsigned
    ///32-bit value. Whole seconds are in tv_sec which is a 64-bit
    ///value combined from tv_sec_hi and tv_sec_lo, and the
    ///additional fractional part in tv_nsec as nanoseconds. Hence,
    ///for valid timestamps tv_nsec must be in [0, 999999999].
    ///
    ///Note that clock_id applies only to the presentation clock,
    ///and implies nothing about e.g. the timestamps used in the
    ///Wayland core protocol input events.
    ///
    ///Compositors should prefer a clock which does not jump and is
    ///not slewed e.g. by NTP. The absolute value of the clock is
    ///irrelevant. Precision of one millisecond or better is
    ///recommended. Clients must be able to query the current clock
    ///value directly, not by asking the compositor.
    ///
    /// </para>
    /// </summary>
    public event ClockIdHandler? OnClockId
    {
        add
        {
            CheckDisposed();
            _onClockId += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onClockId -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wp_presentation");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WpPresentation)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // clock_id
                    if (obj._onClockId != null)
                    {
                        var _clkId = args[0].u;
                        obj._onClockId?.Invoke(_clkId);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    /// <summary>
    /// Unbind from the presentation interface
    /// <para>
    /// <br/>
    /// Informs the server that the client will no longer be using<br/>
    /// this protocol object. Existing objects created by this object<br/>
    /// are not affected.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Request presentation feedback information
    /// <para>
    /// <br/>
    /// Request presentation feedback for the current content submission<br/>
    /// on the given surface. This creates a new presentation_feedback<br/>
    /// object, which will deliver the feedback information once. If<br/>
    /// multiple presentation_feedback objects are created for the same<br/>
    /// submission, they will all deliver the same information.<br/>
    /// <br/>
    /// For details on what information is returned, see the<br/>
    /// presentation_feedback interface.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe WpPresentationFeedback Feedback(WlSurface surface)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].o = (WlObject*)(surface?.Handle ?? IntPtr.Zero);
        args[1].o = (WlObject*)IntPtr.Zero;

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.WpPresentationFeedback,
            (uint)WaylandInterfaces.WpPresentationFeedback->Version,
            0,
            (nint)args
        );

        return new WpPresentationFeedback(newProxy, Display);
    }

    public static WpPresentation Create(nint handle, WlDisplay display)
    {
        return new WpPresentation(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
