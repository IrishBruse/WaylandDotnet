// <auto-generated>
// This file was generated from presentation-time.xml
// Stability: Stable
// Link: https://wayland.app/protocols/presentation-time
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.Stable;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// wp_presentation_feedback
/// <para> presentation time feedback event </para>
/// <para> Version: 2 </para>
/// <see>https://wayland.app/protocols/presentation-time/#wp_presentation_feedback</see>
/// </summary>
public sealed partial class WpPresentationFeedback : WaylandObject, IWaylandObjectFactory<WpPresentationFeedback>
{
    public const string InterfaceName = "wp_presentation_feedback";
    public static string _StaticInterfaceName => "wp_presentation_feedback";
    public const int InterfaceVersion = 2;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public WpPresentationFeedback(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    /// <summary> bitmask of flags in presented event </summary>
    [Flags]
    public enum KindFlag : uint
    {
        /// <summary>
        ///
        /// </summary>
        Vsync = 0x1,
        /// <summary>
        ///
        /// </summary>
        HwClock = 0x2,
        /// <summary>
        ///
        /// </summary>
        HwCompletion = 0x4,
        /// <summary>
        ///
        /// </summary>
        ZeroCopy = 0x8,
    }

    public delegate void SyncOutputHandler(WlOutput output);

    private SyncOutputHandler? _onSyncOutput;

    /// <summary>
    ///Presentation synchronized to this output
    /// <para>
    ///
    ///As presentation can be synchronized to only one output at a
    ///time, this event tells which output it was. This event is only
    ///sent prior to the presented event.
    ///
    ///As clients may bind to the same global wl_output multiple
    ///times, this event is sent for each bound instance that matches
    ///the synchronized output. If a client has not bound to the
    ///right wl_output global at all, this event is not sent.
    ///
    /// </para>
    /// </summary>
    public event SyncOutputHandler? OnSyncOutput
    {
        add
        {
            CheckDisposed();
            _onSyncOutput += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onSyncOutput -= value;
        }
    }

    public delegate void PresentedHandler(uint tvSecHi, uint tvSecLo, uint tvNsec, uint refresh, uint seqHi, uint seqLo, uint flags);

    private PresentedHandler? _onPresented;

    /// <summary>
    ///The content update was displayed
    /// <para>
    ///
    ///The associated content update was displayed to the user at the
    ///indicated time (tv_sec_hi/lo, tv_nsec). For the interpretation of
    ///the timestamp, see presentation.clock_id event.
    ///
    ///The timestamp corresponds to the time when the content update
    ///turned into light the first time on the surface's main output.
    ///Compositors may approximate this from the framebuffer flip
    ///completion events from the system, and the latency of the
    ///physical display path if known.
    ///
    ///This event is preceded by all related sync_output events
    ///telling which output's refresh cycle the feedback corresponds
    ///to, i.e. the main output for the surface. Compositors are
    ///recommended to choose the output containing the largest part
    ///of the wl_surface, or keeping the output they previously
    ///chose. Having a stable presentation output association helps
    ///clients predict future output refreshes (vblank).
    ///
    ///The 'refresh' argument gives the compositor's prediction of how
    ///many nanoseconds after tv_sec, tv_nsec the very next output
    ///refresh may occur. This is to further aid clients in
    ///predicting future refreshes, i.e., estimating the timestamps
    ///targeting the next few vblanks. If such prediction cannot
    ///usefully be done, the argument is zero.
    ///
    ///For version 2 and later, if the output does not have a constant
    ///refresh rate, explicit video mode switches excluded, then the
    ///refresh argument must be either an appropriate rate picked by the
    ///compositor (e.g. fastest rate), or 0 if no such rate exists.
    ///For version 1, if the output does not have a constant refresh rate,
    ///the refresh argument must be zero.
    ///
    ///The 64-bit value combined from seq_hi and seq_lo is the value
    ///of the output's vertical retrace counter when the content
    ///update was first scanned out to the display. This value must
    ///be compatible with the definition of MSC in
    ///GLX_OML_sync_control specification. Note, that if the display
    ///path has a non-zero latency, the time instant specified by
    ///this counter may differ from the timestamp's.
    ///
    ///If the output does not have a concept of vertical retrace or a
    ///refresh cycle, or the output device is self-refreshing without
    ///a way to query the refresh count, then the arguments seq_hi
    ///and seq_lo must be zero.
    ///
    /// </para>
    /// </summary>
    public event PresentedHandler? OnPresented
    {
        add
        {
            CheckDisposed();
            _onPresented += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPresented -= value;
        }
    }

    public delegate void DiscardedHandler();

    private DiscardedHandler? _onDiscarded;

    /// <summary>
    ///The content update was not displayed
    /// <para>
    ///
    ///The content update was never displayed to the user.
    ///
    /// </para>
    /// </summary>
    public event DiscardedHandler? OnDiscarded
    {
        add
        {
            CheckDisposed();
            _onDiscarded += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDiscarded -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to wp_presentation_feedback");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (WpPresentationFeedback)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // sync_output
                    if (obj._onSyncOutput != null)
                    {
                        WlOutput? _output = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'output'");
                        _output = new WlOutput((IntPtr)args[0].o, obj.Display);
                        obj._onSyncOutput?.Invoke(_output);
                    }
                    break;
                case 1: // presented
                    if (obj._onPresented != null)
                    {
                        var _tvSecHi = args[0].u;
                        var _tvSecLo = args[1].u;
                        var _tvNsec = args[2].u;
                        var _refresh = args[3].u;
                        var _seqHi = args[4].u;
                        var _seqLo = args[5].u;
                        var _flags = args[6].u;
                        obj._onPresented?.Invoke(_tvSecHi, _tvSecLo, _tvNsec, _refresh, _seqHi, _seqLo, _flags);
                    }
                    break;
                case 2: // discarded
                    if (obj._onDiscarded != null)
                    {
                        obj._onDiscarded?.Invoke();
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    public static WpPresentationFeedback Create(nint handle, WlDisplay display)
    {
        return new WpPresentationFeedback(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
