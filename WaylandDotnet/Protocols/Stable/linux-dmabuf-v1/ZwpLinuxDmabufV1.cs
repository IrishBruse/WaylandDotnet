// <auto-generated>
// This file was generated from linux-dmabuf-v1.xml
// Stability: Stable
// Link: https://wayland.app/protocols/linux-dmabuf-v1
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.Stable;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// zwp_linux_dmabuf_v1
/// <para> factory for creating dmabuf-based wl_buffers </para>
/// <para> Version: 5 </para>
/// <see>https://wayland.app/protocols/linux-dmabuf-v1/#zwp_linux_dmabuf_v1</see>
/// </summary>
public sealed partial class ZwpLinuxDmabufV1 : WaylandObject, IWaylandObjectFactory<ZwpLinuxDmabufV1>
{
    public const string InterfaceName = "zwp_linux_dmabuf_v1";
    public static string _StaticInterfaceName => "zwp_linux_dmabuf_v1";
    public const int InterfaceVersion = 5;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public ZwpLinuxDmabufV1(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    public delegate void FormatHandler(uint format);

    private FormatHandler? _onFormat;

    /// <summary>
    ///Supported buffer format
    /// <para>
    ///
    ///This event advertises one buffer format that the server supports.
    ///All the supported formats are advertised once when the client
    ///binds to this interface. A roundtrip after binding guarantees
    ///that the client has received all supported formats.
    ///
    ///For the definition of the format codes, see the
    ///zwp_linux_buffer_params_v1::create request.
    ///
    ///Starting version 4, the format event is deprecated and must not be
    ///sent by compositors. Instead, use get_default_feedback or
    ///get_surface_feedback.
    ///
    /// </para>
    /// </summary>
    public event FormatHandler? OnFormat
    {
        add
        {
            CheckDisposed();
            _onFormat += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onFormat -= value;
        }
    }

    public delegate void ModifierHandler(uint format, uint modifierHi, uint modifierLo);

    private ModifierHandler? _onModifier;

    /// <summary>
    ///Supported buffer format modifier
    /// <para>
    ///
    ///This event advertises the formats that the server supports, along with
    ///the modifiers supported for each format. All the supported modifiers
    ///for all the supported formats are advertised once when the client
    ///binds to this interface. A roundtrip after binding guarantees that
    ///the client has received all supported format-modifier pairs.
    ///
    ///For legacy support, DRM_FORMAT_MOD_INVALID (that is, modifier_hi ==
    ///0x00ffffff and modifier_lo == 0xffffffff) is allowed in this event.
    ///It indicates that the server can support the format with an implicit
    ///modifier. When a plane has DRM_FORMAT_MOD_INVALID as its modifier, it
    ///is as if no explicit modifier is specified. The effective modifier
    ///will be derived from the dmabuf.
    ///
    ///A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for
    ///a given format supports both explicit modifiers and implicit modifiers.
    ///
    ///For the definition of the format and modifier codes, see the
    ///zwp_linux_buffer_params_v1::create and zwp_linux_buffer_params_v1::add
    ///requests.
    ///
    ///Starting version 4, the modifier event is deprecated and must not be
    ///sent by compositors. Instead, use get_default_feedback or
    ///get_surface_feedback.
    ///
    /// </para>
    /// </summary>
    public event ModifierHandler? OnModifier
    {
        add
        {
            CheckDisposed();
            _onModifier += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onModifier -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to zwp_linux_dmabuf_v1");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (ZwpLinuxDmabufV1)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // format
                    if (obj._onFormat != null)
                    {
                        var _format = args[0].u;
                        obj._onFormat?.Invoke(_format);
                    }
                    break;
                case 1: // modifier
                    if (obj._onModifier != null)
                    {
                        var _format = args[0].u;
                        var _modifierHi = args[1].u;
                        var _modifierLo = args[2].u;
                        obj._onModifier?.Invoke(_format, _modifierHi, _modifierLo);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    /// <summary>
    /// Unbind the factory
    /// <para>
    /// <br/>
    /// Objects created through this interface, especially wl_buffers, will<br/>
    /// remain valid.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Create a temporary object for buffer parameters
    /// <para>
    /// <br/>
    /// This temporary object is used to collect multiple dmabuf handles into<br/>
    /// a single batch to create a wl_buffer. It can only be used once and<br/>
    /// should be destroyed after a 'created' or 'failed' event has been<br/>
    /// received.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe ZwpLinuxBufferParamsV1 CreateParams()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)IntPtr.Zero;

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.ZwpLinuxBufferParamsV1,
            (uint)WaylandInterfaces.ZwpLinuxBufferParamsV1->Version,
            0,
            (nint)args
        );

        return new ZwpLinuxBufferParamsV1(newProxy, Display);
    }

    /// <summary>
    /// Get default feedback
    /// <para>
    /// <br/>
    /// This request creates a new wp_linux_dmabuf_feedback object not bound<br/>
    /// to a particular surface. This object will deliver feedback about dmabuf<br/>
    /// parameters to use if the client doesn't support per-surface feedback<br/>
    /// (see get_surface_feedback).<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe ZwpLinuxDmabufFeedbackV1 GetDefaultFeedback()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)IntPtr.Zero;

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.ZwpLinuxDmabufFeedbackV1,
            (uint)WaylandInterfaces.ZwpLinuxDmabufFeedbackV1->Version,
            0,
            (nint)args
        );

        return new ZwpLinuxDmabufFeedbackV1(newProxy, Display);
    }

    /// <summary>
    /// Get feedback for a surface
    /// <para>
    /// <br/>
    /// This request creates a new wp_linux_dmabuf_feedback object for the<br/>
    /// specified wl_surface. This object will deliver feedback about dmabuf<br/>
    /// parameters to use for buffers attached to this surface.<br/>
    /// <br/>
    /// If the surface is destroyed before the wp_linux_dmabuf_feedback object,<br/>
    /// the feedback object becomes inert.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe ZwpLinuxDmabufFeedbackV1 GetSurfaceFeedback(WlSurface surface)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].o = (WlObject*)IntPtr.Zero;
        args[1].o = (WlObject*)(surface?.Handle ?? IntPtr.Zero);

        const uint opcode = 3;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.ZwpLinuxDmabufFeedbackV1,
            (uint)WaylandInterfaces.ZwpLinuxDmabufFeedbackV1->Version,
            0,
            (nint)args
        );

        return new ZwpLinuxDmabufFeedbackV1(newProxy, Display);
    }

    public static ZwpLinuxDmabufV1 Create(nint handle, WlDisplay display)
    {
        return new ZwpLinuxDmabufV1(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
