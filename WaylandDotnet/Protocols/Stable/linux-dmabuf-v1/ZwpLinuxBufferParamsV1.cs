// <auto-generated>
// This file was generated from linux-dmabuf-v1.xml
// Stability: Stable
// Link: https://wayland.app/protocols/linux-dmabuf-v1
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.Stable;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// zwp_linux_buffer_params_v1
/// <para> parameters for creating a dmabuf-based wl_buffer </para>
/// <para> Version: 5 </para>
/// <see>https://wayland.app/protocols/linux-dmabuf-v1/#zwp_linux_buffer_params_v1</see>
/// </summary>
public sealed partial class ZwpLinuxBufferParamsV1 : WaylandObject, IWaylandObjectFactory<ZwpLinuxBufferParamsV1>
{
    public const string InterfaceName = "zwp_linux_buffer_params_v1";
    public static string _StaticInterfaceName => "zwp_linux_buffer_params_v1";
    public const int InterfaceVersion = 5;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public ZwpLinuxBufferParamsV1(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// the dmabuf_batch object has already been used to create a wl_buffer
        /// </summary>
        AlreadyUsed = 0,
        /// <summary>
        /// plane index out of bounds
        /// </summary>
        PlaneIdx = 1,
        /// <summary>
        /// the plane index was already set
        /// </summary>
        PlaneSet = 2,
        /// <summary>
        /// missing or too many planes to create a buffer
        /// </summary>
        Incomplete = 3,
        /// <summary>
        /// format not supported
        /// </summary>
        InvalidFormat = 4,
        /// <summary>
        /// invalid width or height
        /// </summary>
        InvalidDimensions = 5,
        /// <summary>
        /// offset + stride * height goes out of dmabuf bounds
        /// </summary>
        OutOfBounds = 6,
        /// <summary>
        /// invalid wl_buffer resulted from importing dmabufs via                the create_immed request on given buffer_params
        /// </summary>
        InvalidWlBuffer = 7,
    }

    /// <summary>  </summary>
    [Flags]
    public enum FlagsFlag : uint
    {
        /// <summary>
        /// contents are y-inverted
        /// </summary>
        YInvert = 1,
        /// <summary>
        /// content is interlaced
        /// </summary>
        Interlaced = 2,
        /// <summary>
        /// bottom field first
        /// </summary>
        BottomFirst = 4,
    }

    public delegate void CreatedHandler(WlBuffer buffer);

    private CreatedHandler? _onCreated;

    /// <summary>
    ///Buffer creation succeeded
    /// <para>
    ///
    ///This event indicates that the attempted buffer creation was
    ///successful. It provides the new wl_buffer referencing the dmabuf(s).
    ///
    ///Upon receiving this event, the client should destroy the
    ///zwp_linux_buffer_params_v1 object.
    ///
    /// </para>
    /// </summary>
    public event CreatedHandler? OnCreated
    {
        add
        {
            CheckDisposed();
            _onCreated += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onCreated -= value;
        }
    }

    public delegate void FailedHandler();

    private FailedHandler? _onFailed;

    /// <summary>
    ///Buffer creation failed
    /// <para>
    ///
    ///This event indicates that the attempted buffer creation has
    ///failed. It usually means that one of the dmabuf constraints
    ///has not been fulfilled.
    ///
    ///Upon receiving this event, the client should destroy the
    ///zwp_linux_buffer_params_v1 object.
    ///
    /// </para>
    /// </summary>
    public event FailedHandler? OnFailed
    {
        add
        {
            CheckDisposed();
            _onFailed += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onFailed -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to zwp_linux_buffer_params_v1");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (ZwpLinuxBufferParamsV1)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // created
                    if (obj._onCreated != null)
                    {
                        WlBuffer? _buffer = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'buffer'");
                        _buffer = new WlBuffer((IntPtr)args[0].o, obj.Display);
                        obj._onCreated?.Invoke(_buffer);
                    }
                    break;
                case 1: // failed
                    if (obj._onFailed != null)
                    {
                        obj._onFailed?.Invoke();
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    /// <summary>
    /// Delete this object, used or not
    /// <para>
    /// <br/>
    /// Cleans up the temporary data sent to the server for dmabuf-based<br/>
    /// wl_buffer creation.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Add a dmabuf to the temporary set
    /// <para>
    /// <br/>
    /// This request adds one dmabuf to the set in this<br/>
    /// zwp_linux_buffer_params_v1.<br/>
    /// <br/>
    /// The 64-bit unsigned value combined from modifier_hi and modifier_lo<br/>
    /// is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the<br/>
    /// fb modifier, which is defined in drm_mode.h of Linux UAPI.<br/>
    /// This is an opaque token. Drivers use this token to express tiling,<br/>
    /// compression, etc. driver-specific modifications to the base format<br/>
    /// defined by the DRM fourcc code.<br/>
    /// <br/>
    /// Starting from version 4, the invalid_format protocol error is sent if<br/>
    /// the format + modifier pair was not advertised as supported.<br/>
    /// <br/>
    /// Starting from version 5, the invalid_format protocol error is sent if<br/>
    /// all planes don't use the same modifier.<br/>
    /// <br/>
    /// This request raises the PLANE_IDX error if plane_idx is too large.<br/>
    /// The error PLANE_SET is raised if attempting to set a plane that<br/>
    /// was already set.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Add(int fd, uint planeIdx, uint offset, uint stride, uint modifierHi, uint modifierLo)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[6];
        args[0].h = fd;
        args[1].u = planeIdx;
        args[2].u = offset;
        args[3].u = stride;
        args[4].u = modifierHi;
        args[5].u = modifierLo;

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Create a wl_buffer from the given dmabufs
    /// <para>
    /// <br/>
    /// This asks for creation of a wl_buffer from the added dmabuf<br/>
    /// buffers. The wl_buffer is not created immediately but returned via<br/>
    /// the 'created' event if the dmabuf sharing succeeds. The sharing<br/>
    /// may fail at runtime for reasons a client cannot predict, in<br/>
    /// which case the 'failed' event is triggered.<br/>
    /// <br/>
    /// The 'format' argument is a DRM_FORMAT code, as defined by the<br/>
    /// libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the<br/>
    /// authoritative source on how the format codes should work.<br/>
    /// <br/>
    /// The 'flags' is a bitfield of the flags defined in enum "flags".<br/>
    /// 'y_invert' means the that the image needs to be y-flipped.<br/>
    /// <br/>
    /// Flag 'interlaced' means that the frame in the buffer is not<br/>
    /// progressive as usual, but interlaced. An interlaced buffer as<br/>
    /// supported here must always contain both top and bottom fields.<br/>
    /// The top field always begins on the first pixel row. The temporal<br/>
    /// ordering between the two fields is top field first, unless<br/>
    /// 'bottom_first' is specified. It is undefined whether 'bottom_first'<br/>
    /// is ignored if 'interlaced' is not set.<br/>
    /// <br/>
    /// This protocol does not convey any information about field rate,<br/>
    /// duration, or timing, other than the relative ordering between the<br/>
    /// two fields in one buffer. A compositor may have to estimate the<br/>
    /// intended field rate from the incoming buffer rate. It is undefined<br/>
    /// whether the time of receiving wl_surface.commit with a new buffer<br/>
    /// attached, applying the wl_surface state, wl_surface.frame callback<br/>
    /// trigger, presentation, or any other point in the compositor cycle<br/>
    /// is used to measure the frame or field times. There is no support<br/>
    /// for detecting missed or late frames/fields/buffers either, and<br/>
    /// there is no support whatsoever for cooperating with interlaced<br/>
    /// compositor output.<br/>
    /// <br/>
    /// The composited image quality resulting from the use of interlaced<br/>
    /// buffers is explicitly undefined. A compositor may use elaborate<br/>
    /// hardware features or software to deinterlace and create progressive<br/>
    /// output frames from a sequence of interlaced input buffers, or it<br/>
    /// may produce substandard image quality. However, compositors that<br/>
    /// cannot guarantee reasonable image quality in all cases are recommended<br/>
    /// to just reject all interlaced buffers.<br/>
    /// <br/>
    /// Any argument errors, including non-positive width or height,<br/>
    /// mismatch between the number of planes and the format, bad<br/>
    /// format, bad offset or stride, may be indicated by fatal protocol<br/>
    /// errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,<br/>
    /// OUT_OF_BOUNDS.<br/>
    /// <br/>
    /// Dmabuf import errors in the server that are not obvious client<br/>
    /// bugs are returned via the 'failed' event as non-fatal. This<br/>
    /// allows attempting dmabuf sharing and falling back in the client<br/>
    /// if it fails.<br/>
    /// <br/>
    /// This request can be sent only once in the object's lifetime, after<br/>
    /// which the only legal request is destroy. This object should be<br/>
    /// destroyed after issuing a 'create' request. Attempting to use this<br/>
    /// object after issuing 'create' raises ALREADY_USED protocol error.<br/>
    /// <br/>
    /// It is not mandatory to issue 'create'. If a client wants to<br/>
    /// cancel the buffer creation, it can just destroy this object.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Create(int width, int height, uint format, uint flags)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].i = width;
        args[1].i = height;
        args[2].u = format;
        args[3].u = flags;

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Immediately create a wl_buffer from the given                      dmabufs
    /// <para>
    /// <br/>
    /// This asks for immediate creation of a wl_buffer by importing the<br/>
    /// added dmabufs.<br/>
    /// <br/>
    /// In case of import success, no event is sent from the server, and the<br/>
    /// wl_buffer is ready to be used by the client.<br/>
    /// <br/>
    /// Upon import failure, either of the following may happen, as seen fit<br/>
    /// by the implementation:<br/>
    /// - the client is terminated with one of the following fatal protocol<br/>
    /// errors:<br/>
    /// - INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,<br/>
    /// in case of argument errors such as mismatch between the number<br/>
    /// of planes and the format, bad format, non-positive width or<br/>
    /// height, or bad offset or stride.<br/>
    /// - INVALID_WL_BUFFER, in case the cause for failure is unknown or<br/>
    /// platform specific.<br/>
    /// - the server creates an invalid wl_buffer, marks it as failed and<br/>
    /// sends a 'failed' event to the client. The result of using this<br/>
    /// invalid wl_buffer as an argument in any request by the client is<br/>
    /// defined by the compositor implementation.<br/>
    /// <br/>
    /// This takes the same arguments as a 'create' request, and obeys the<br/>
    /// same restrictions.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe WlBuffer CreateImmed(int width, int height, uint format, uint flags)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[5];
        args[0].o = (WlObject*)IntPtr.Zero;
        args[1].i = width;
        args[2].i = height;
        args[3].u = format;
        args[4].u = flags;

        const uint opcode = 3;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.WlBuffer,
            (uint)WaylandInterfaces.WlBuffer->Version,
            0,
            (nint)args
        );

        return new WlBuffer(newProxy, Display);
    }

    public static ZwpLinuxBufferParamsV1 Create(nint handle, WlDisplay display)
    {
        return new ZwpLinuxBufferParamsV1(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
