// <auto-generated>
// This file was generated from linux-dmabuf-v1.xml
// Stability: Stable
// Link: https://wayland.app/protocols/linux-dmabuf-v1
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.Stable;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// zwp_linux_dmabuf_feedback_v1
/// <para> dmabuf feedback </para>
/// <para> Version: 5 </para>
/// <see>https://wayland.app/protocols/linux-dmabuf-v1/#zwp_linux_dmabuf_feedback_v1</see>
/// </summary>
public sealed partial class ZwpLinuxDmabufFeedbackV1 : WaylandObject, IWaylandObjectFactory<ZwpLinuxDmabufFeedbackV1>
{
    public const string InterfaceName = "zwp_linux_dmabuf_feedback_v1";
    public static string _StaticInterfaceName => "zwp_linux_dmabuf_feedback_v1";
    public const int InterfaceVersion = 5;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public ZwpLinuxDmabufFeedbackV1(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    /// <summary>  </summary>
    [Flags]
    public enum TrancheFlagsFlag : uint
    {
        /// <summary>
        /// direct scan-out tranche
        /// </summary>
        Scanout = 1,
    }

    public delegate void DoneHandler();

    private DoneHandler? _onDone;

    /// <summary>
    ///All feedback has been sent
    /// <para>
    ///
    ///This event is sent after all parameters of a wp_linux_dmabuf_feedback
    ///object have been sent.
    ///
    ///This allows changes to the wp_linux_dmabuf_feedback parameters to be
    ///seen as atomic, even if they happen via multiple events.
    ///
    /// </para>
    /// </summary>
    public event DoneHandler? OnDone
    {
        add
        {
            CheckDisposed();
            _onDone += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDone -= value;
        }
    }

    public delegate void FormatTableHandler(int fd, uint size);

    private FormatTableHandler? _onFormatTable;

    /// <summary>
    ///Format and modifier table
    /// <para>
    ///
    ///This event provides a file descriptor which can be memory-mapped to
    ///access the format and modifier table.
    ///
    ///The table contains a tightly packed array of consecutive format +
    ///modifier pairs. Each pair is 16 bytes wide. It contains a format as a
    ///32-bit unsigned integer, followed by 4 bytes of unused padding, and a
    ///modifier as a 64-bit unsigned integer. The native endianness is used.
    ///
    ///The client must map the file descriptor in read-only private mode.
    ///
    ///Compositors are not allowed to mutate the table file contents once this
    ///event has been sent. Instead, compositors must create a new, separate
    ///table file and re-send feedback parameters. Compositors are allowed to
    ///store duplicate format + modifier pairs in the table.
    ///
    /// </para>
    /// </summary>
    public event FormatTableHandler? OnFormatTable
    {
        add
        {
            CheckDisposed();
            _onFormatTable += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onFormatTable -= value;
        }
    }

    public delegate void MainDeviceHandler(byte[] device);

    private MainDeviceHandler? _onMainDevice;

    /// <summary>
    ///Preferred main device
    /// <para>
    ///
    ///This event advertises the main device that the server prefers to use
    ///when direct scan-out to the target device isn't possible. The
    ///advertised main device may be different for each
    ///wp_linux_dmabuf_feedback object, and may change over time.
    ///
    ///There is exactly one main device. The compositor must send at least
    ///one preference tranche with tranche_target_device equal to main_device.
    ///
    ///Clients need to create buffers that the main device can import and
    ///read from, otherwise creating the dmabuf wl_buffer will fail (see the
    ///wp_linux_buffer_params.create and create_immed requests for details).
    ///The main device will also likely be kept active by the compositor,
    ///so clients can use it instead of waking up another device for power
    ///savings.
    ///
    ///In general the device is a DRM node. The DRM node type (primary vs.
    ///render) is unspecified. Clients must not rely on the compositor sending
    ///a particular node type. Clients cannot check two devices for equality
    ///by comparing the dev_t value.
    ///
    ///If explicit modifiers are not supported and the client performs buffer
    ///allocations on a different device than the main device, then the client
    ///must force the buffer to have a linear layout.
    ///
    /// </para>
    /// </summary>
    public event MainDeviceHandler? OnMainDevice
    {
        add
        {
            CheckDisposed();
            _onMainDevice += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onMainDevice -= value;
        }
    }

    public delegate void TrancheDoneHandler();

    private TrancheDoneHandler? _onTrancheDone;

    /// <summary>
    ///A preference tranche has been sent
    /// <para>
    ///
    ///This event splits tranche_target_device and tranche_formats events in
    ///preference tranches. It is sent after a set of tranche_target_device
    ///and tranche_formats events; it represents the end of a tranche. The
    ///next tranche will have a lower preference.
    ///
    /// </para>
    /// </summary>
    public event TrancheDoneHandler? OnTrancheDone
    {
        add
        {
            CheckDisposed();
            _onTrancheDone += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onTrancheDone -= value;
        }
    }

    public delegate void TrancheTargetDeviceHandler(byte[] device);

    private TrancheTargetDeviceHandler? _onTrancheTargetDevice;

    /// <summary>
    ///Target device
    /// <para>
    ///
    ///This event advertises the target device that the server prefers to use
    ///for a buffer created given this tranche. The advertised target device
    ///may be different for each preference tranche, and may change over time.
    ///
    ///There is exactly one target device per tranche.
    ///
    ///The target device may be a scan-out device, for example if the
    ///compositor prefers to directly scan-out a buffer created given this
    ///tranche. The target device may be a rendering device, for example if
    ///the compositor prefers to texture from said buffer.
    ///
    ///The client can use this hint to allocate the buffer in a way that makes
    ///it accessible from the target device, ideally directly. The buffer must
    ///still be accessible from the main device, either through direct import
    ///or through a potentially more expensive fallback path. If the buffer
    ///can't be directly imported from the main device then clients must be
    ///prepared for the compositor changing the tranche priority or making
    ///wl_buffer creation fail (see the wp_linux_buffer_params.create and
    ///create_immed requests for details).
    ///
    ///If the device is a DRM node, the DRM node type (primary vs. render) is
    ///unspecified. Clients must not rely on the compositor sending a
    ///particular node type. Clients cannot check two devices for equality by
    ///comparing the dev_t value.
    ///
    ///This event is tied to a preference tranche, see the tranche_done event.
    ///
    /// </para>
    /// </summary>
    public event TrancheTargetDeviceHandler? OnTrancheTargetDevice
    {
        add
        {
            CheckDisposed();
            _onTrancheTargetDevice += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onTrancheTargetDevice -= value;
        }
    }

    public delegate void TrancheFormatsHandler(byte[] indices);

    private TrancheFormatsHandler? _onTrancheFormats;

    /// <summary>
    ///Supported buffer format modifier
    /// <para>
    ///
    ///This event advertises the format + modifier combinations that the
    ///compositor supports.
    ///
    ///It carries an array of indices, each referring to a format + modifier
    ///pair in the last received format table (see the format_table event).
    ///Each index is a 16-bit unsigned integer in native endianness.
    ///
    ///For legacy support, DRM_FORMAT_MOD_INVALID is an allowed modifier.
    ///It indicates that the server can support the format with an implicit
    ///modifier. When a buffer has DRM_FORMAT_MOD_INVALID as its modifier, it
    ///is as if no explicit modifier is specified. The effective modifier
    ///will be derived from the dmabuf.
    ///
    ///A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for
    ///a given format supports both explicit modifiers and implicit modifiers.
    ///
    ///Compositors must not send duplicate format + modifier pairs within the
    ///same tranche or across two different tranches with the same target
    ///device and flags.
    ///
    ///This event is tied to a preference tranche, see the tranche_done event.
    ///
    ///For the definition of the format and modifier codes, see the
    ///wp_linux_buffer_params.create request.
    ///
    /// </para>
    /// </summary>
    public event TrancheFormatsHandler? OnTrancheFormats
    {
        add
        {
            CheckDisposed();
            _onTrancheFormats += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onTrancheFormats -= value;
        }
    }

    public delegate void TrancheFlagsHandler(uint flags);

    private TrancheFlagsHandler? _onTrancheFlags;

    /// <summary>
    ///Tranche flags
    /// <para>
    ///
    ///This event sets tranche-specific flags.
    ///
    ///The scanout flag is a hint that direct scan-out may be attempted by the
    ///compositor on the target device if the client appropriately allocates a
    ///buffer. How to allocate a buffer that can be scanned out on the target
    ///device is implementation-defined.
    ///
    ///This event is tied to a preference tranche, see the tranche_done event.
    ///
    /// </para>
    /// </summary>
    public event TrancheFlagsHandler? OnTrancheFlags
    {
        add
        {
            CheckDisposed();
            _onTrancheFlags += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onTrancheFlags -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to zwp_linux_dmabuf_feedback_v1");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (ZwpLinuxDmabufFeedbackV1)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // done
                    if (obj._onDone != null)
                    {
                        obj._onDone?.Invoke();
                    }
                    break;
                case 1: // format_table
                    if (obj._onFormatTable != null)
                    {
                        var _fd = args[0].h;
                        var _size = args[1].u;
                        obj._onFormatTable?.Invoke(_fd, _size);
                    }
                    break;
                case 2: // main_device
                    if (obj._onMainDevice != null)
                    {
                        var _device = args[0].a;
                        obj._onMainDevice?.Invoke(WaylandMarshal.ToSpan(_device));
                    }
                    break;
                case 3: // tranche_done
                    if (obj._onTrancheDone != null)
                    {
                        obj._onTrancheDone?.Invoke();
                    }
                    break;
                case 4: // tranche_target_device
                    if (obj._onTrancheTargetDevice != null)
                    {
                        var _device = args[0].a;
                        obj._onTrancheTargetDevice?.Invoke(WaylandMarshal.ToSpan(_device));
                    }
                    break;
                case 5: // tranche_formats
                    if (obj._onTrancheFormats != null)
                    {
                        var _indices = args[0].a;
                        obj._onTrancheFormats?.Invoke(WaylandMarshal.ToSpan(_indices));
                    }
                    break;
                case 6: // tranche_flags
                    if (obj._onTrancheFlags != null)
                    {
                        var _flags = args[0].u;
                        obj._onTrancheFlags?.Invoke(_flags);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    /// <summary>
    /// Destroy the feedback object
    /// <para>
    /// <br/>
    /// Using this request a client can tell the server that it is not going to<br/>
    /// use the wp_linux_dmabuf_feedback object anymore.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    public static ZwpLinuxDmabufFeedbackV1 Create(nint handle, WlDisplay display)
    {
        return new ZwpLinuxDmabufFeedbackV1(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
