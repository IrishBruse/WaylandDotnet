// <auto-generated>
// This file was generated from river-window-management-v1.xml
// Stability: River
// Link: https://wayland.app/protocols/river-window-management-v1
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.River;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// river_seat_v1
/// <para> a window management seat </para>
/// <para> Version: 3 </para>
/// <see>https://wayland.app/protocols/river-window-management-v1/#river_seat_v1</see>
/// </summary>
public sealed partial class RiverSeatV1 : WaylandObject, IWaylandObjectFactory<RiverSeatV1>
{
    public const string InterfaceName = "river_seat_v1";
    public static string _StaticInterfaceName => "river_seat_v1";
    public const int InterfaceVersion = 3;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public RiverSeatV1(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary> a set of keyboard modifiers </summary>
    [Flags]
    public enum ModifiersFlag : uint
    {
        /// <summary>
        ///
        /// </summary>
        None = 0,
        /// <summary>
        ///
        /// </summary>
        Shift = 1,
        /// <summary>
        ///
        /// </summary>
        Ctrl = 4,
        /// <summary>
        /// commonly called alt
        /// </summary>
        Mod1 = 8,
        /// <summary>
        ///
        /// </summary>
        Mod3 = 32,
        /// <summary>
        /// commonly called super or logo
        /// </summary>
        Mod4 = 64,
        /// <summary>
        ///
        /// </summary>
        Mod5 = 128,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void RemovedHandler();

    private RemovedHandler? _onRemoved;

    /// <summary>
    ///The seat is removed
    /// <para>
    ///
    ///This event indicates that seat is no longer in use and should be
    ///destroyed.
    ///
    ///The server will send no further events on this object and ignore any
    ///request (other than river_seat_v1.destroy) made after this event is
    ///sent.  The client should destroy this object with the
    ///river_seat_v1.destroy request to free up resources.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event RemovedHandler? OnRemoved
    {
        add
        {
            CheckDisposed();
            _onRemoved += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onRemoved -= value;
        }
    }

    public delegate void WlSeatHandler(uint name);

    private WlSeatHandler? _onWlSeat;

    /// <summary>
    ///Corresponding wl_seat
    /// <para>
    ///
    ///The wl_seat object corresponding to the river_seat_v1. The argument is
    ///the global name of the wl_seat advertised with wl_registry.global.
    ///
    ///It is guaranteed that the corresponding wl_seat is advertised before
    ///this event is sent.
    ///
    ///This event is sent exactly once. The wl_seat associated with a
    ///river_seat_v1 cannot change. It is guaranteed that there is a 1-to-1
    ///mapping between wl_seat and river_seat_v1 objects.
    ///
    ///The global_remove event for the corresponding wl_seat may be sent before
    ///the river_seat_v1.remove event. This is due to the fact that
    ///river_seat_v1 state changes are synced to the river window management
    ///manage sequence while changes to globals are not.
    ///
    ///Rationale: The window manager may want to trigger window management
    ///state changes based on normal input events received by its shell
    ///surfaces for example.
    ///
    /// </para>
    /// </summary>
    public event WlSeatHandler? OnWlSeat
    {
        add
        {
            CheckDisposed();
            _onWlSeat += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onWlSeat -= value;
        }
    }

    public delegate void PointerEnterHandler(RiverWindowV1 window);

    private PointerEnterHandler? _onPointerEnter;

    /// <summary>
    ///Pointer entered a window
    /// <para>
    ///
    ///The seat's pointer entered the given window's area.
    ///
    ///The area of a window is defined to include the area defined by the
    ///window dimensions, borders configured using river_window_v1.set_borders,
    ///and the input regions of decoration surfaces. In particular, it does not
    ///include input regions of surfaces belonging to the window that extend
    ///outside the window dimensions.
    ///
    ///The pointer of a seat may only enter a single window at a time. When the
    ///pointer moves between windows, the pointer_leave event for the old
    ///window must be sent before the pointer_enter event for the new window.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event PointerEnterHandler? OnPointerEnter
    {
        add
        {
            CheckDisposed();
            _onPointerEnter += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPointerEnter -= value;
        }
    }

    public delegate void PointerLeaveHandler();

    private PointerLeaveHandler? _onPointerLeave;

    /// <summary>
    ///Pointer left the entered window
    /// <para>
    ///
    ///The seat's pointer left the window for which pointer_enter was most
    ///recently sent. See pointer_enter for details.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event PointerLeaveHandler? OnPointerLeave
    {
        add
        {
            CheckDisposed();
            _onPointerLeave += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPointerLeave -= value;
        }
    }

    public delegate void WindowInteractionHandler(RiverWindowV1 window);

    private WindowInteractionHandler? _onWindowInteraction;

    /// <summary>
    ///A window has been interacted with
    /// <para>
    ///
    ///A window has been interacted with beyond the pointer merely passing over
    ///it. This event might be sent due to a pointer button press or due to a
    ///touch/tablet tool interaction with the window.
    ///
    ///There are no guarantees regarding how this event is sent in relation to
    ///the pointer_enter and pointer_leave events as the interaction may use
    ///touch or tablet tool input.
    ///
    ///Rationale: this event gives window managers necessary information to
    ///determine when to send keyboard focus, raise a window that already has
    ///keyboard focus, etc. Rather than expose all pointer, touch, and tablet
    ///events to window managers, a policy over mechanism approach is taken.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event WindowInteractionHandler? OnWindowInteraction
    {
        add
        {
            CheckDisposed();
            _onWindowInteraction += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onWindowInteraction -= value;
        }
    }

    public delegate void ShellSurfaceInteractionHandler(RiverShellSurfaceV1 shellSurface);

    private ShellSurfaceInteractionHandler? _onShellSurfaceInteraction;

    /// <summary>
    ///A shell surface has been interacted with
    /// <para>
    ///
    ///A shell surface has been interacted with beyond the pointer merely
    ///passing over it. This event might be sent due to a pointer button press
    ///or due to a touch/tablet tool interaction with the shell_surface.
    ///
    ///There are no guarantees regarding how this event is sent in relation to
    ///the pointer_enter and pointer_leave events as the interaction may use
    ///touch or tablet tool input.
    ///
    ///Rationale: While the shell surface does receive all wl_pointer,
    ///wl_touch, etc. input events for the surface directly, these events do
    ///not necessarily trigger a manage sequence and therefore do not allow the
    ///window manager to update focus or perform other actions in response to
    ///the input in a race-free way.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event ShellSurfaceInteractionHandler? OnShellSurfaceInteraction
    {
        add
        {
            CheckDisposed();
            _onShellSurfaceInteraction += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onShellSurfaceInteraction -= value;
        }
    }

    public delegate void OpDeltaHandler(int dx, int dy);

    private OpDeltaHandler? _onOpDelta;

    /// <summary>
    ///Total cumulative motion since op start
    /// <para>
    ///
    ///This event indicates the total change in position since the start of the
    ///operation of the pointer/touch point/etc.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event OpDeltaHandler? OnOpDelta
    {
        add
        {
            CheckDisposed();
            _onOpDelta += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onOpDelta -= value;
        }
    }

    public delegate void OpReleaseHandler();

    private OpReleaseHandler? _onOpRelease;

    /// <summary>
    ///Operation input has been released
    /// <para>
    ///
    ///The input driving the current interactive operation has been released.
    ///For a pointer op for example, all pointer buttons have been released.
    ///
    ///Depending on the op type, op_delta events may continue to be sent until
    ///the op is ended with the op_end request.
    ///
    ///This event is sent at most once during an interactive operation.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event OpReleaseHandler? OnOpRelease
    {
        add
        {
            CheckDisposed();
            _onOpRelease += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onOpRelease -= value;
        }
    }

    public delegate void PointerPositionHandler(int x, int y);

    private PointerPositionHandler? _onPointerPosition;

    /// <summary>
    ///The current position of the pointer
    /// <para>
    ///
    ///The current position of the pointer in the compositor's logical
    ///coordinate space.
    ///
    ///This state is special in that a change in pointer position alone must
    ///not cause the compositor to start a manage sequence.
    ///
    ///Assuming the seat has a pointer, this event must be sent in every manage
    ///sequence unless there is no change in x/y position since the last time this
    ///event was sent.
    ///
    /// </para>
    /// </summary>
    public event PointerPositionHandler? OnPointerPosition
    {
        add
        {
            CheckDisposed();
            _onPointerPosition += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPointerPosition -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to river_seat_v1");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (RiverSeatV1)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // removed
                    if (obj._onRemoved != null)
                    {
                        obj._onRemoved?.Invoke();
                    }
                    break;
                case 1: // wl_seat
                    if (obj._onWlSeat != null)
                    {
                        var _name = args[0].u;
                        obj._onWlSeat?.Invoke(_name);
                    }
                    break;
                case 2: // pointer_enter
                    if (obj._onPointerEnter != null)
                    {
                        RiverWindowV1? _window = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'window'");
                        _window = new RiverWindowV1((IntPtr)args[0].o, obj.Display);
                        obj._onPointerEnter?.Invoke(_window);
                    }
                    break;
                case 3: // pointer_leave
                    if (obj._onPointerLeave != null)
                    {
                        obj._onPointerLeave?.Invoke();
                    }
                    break;
                case 4: // window_interaction
                    if (obj._onWindowInteraction != null)
                    {
                        RiverWindowV1? _window = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'window'");
                        _window = new RiverWindowV1((IntPtr)args[0].o, obj.Display);
                        obj._onWindowInteraction?.Invoke(_window);
                    }
                    break;
                case 5: // shell_surface_interaction
                    if (obj._onShellSurfaceInteraction != null)
                    {
                        RiverShellSurfaceV1? _shellSurface = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'shell_surface'");
                        _shellSurface = new RiverShellSurfaceV1((IntPtr)args[0].o, obj.Display);
                        obj._onShellSurfaceInteraction?.Invoke(_shellSurface);
                    }
                    break;
                case 6: // op_delta
                    if (obj._onOpDelta != null)
                    {
                        var _dx = args[0].i;
                        var _dy = args[1].i;
                        obj._onOpDelta?.Invoke(_dx, _dy);
                    }
                    break;
                case 7: // op_release
                    if (obj._onOpRelease != null)
                    {
                        obj._onOpRelease?.Invoke();
                    }
                    break;
                case 8: // pointer_position
                    if (obj._onPointerPosition != null)
                    {
                        var _x = args[0].i;
                        var _y = args[1].i;
                        obj._onPointerPosition?.Invoke(_x, _y);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Destroy the seat object
    /// <para>
    /// <br/>
    /// This request indicates that the client will no longer use the seat<br/>
    /// object and that it may be safely destroyed.<br/>
    /// <br/>
    /// This request should be made after the river_seat_v1.removed event is<br/>
    /// received to complete destruction of the seat.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Give keyboard focus to a window
    /// <para>
    /// <br/>
    /// Request that the compositor send keyboard input to the given window.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void FocusWindow(RiverWindowV1 window)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)(window?.Handle ?? IntPtr.Zero);

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Give keyboard focus to a shell_surface
    /// <para>
    /// <br/>
    /// Request that the compositor send keyboard input to the given shell<br/>
    /// surface.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void FocusShellSurface(RiverShellSurfaceV1 shellSurface)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)(shellSurface?.Handle ?? IntPtr.Zero);

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Clear keyboard focus
    /// <para>
    /// <br/>
    /// Request that the compositor not send keyboard input to any client.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void ClearFocus()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 3;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Start an interactive pointer operation
    /// <para>
    /// <br/>
    /// Start an interactive pointer operation. During the operation, op_delta<br/>
    /// events will be sent based on pointer input.<br/>
    /// <br/>
    /// When all pointer buttons are released, the op_release event is sent.<br/>
    /// <br/>
    /// The pointer operation continues until the op_end request is made during<br/>
    /// a manage sequence and that manage sequence is finished.<br/>
    /// <br/>
    /// The window manager may use this operation to implement interactive<br/>
    /// move/resize of windows by setting the position of windows and proposing<br/>
    /// dimensions based off of the op_delta events.<br/>
    /// <br/>
    /// This request is ignored if an operation is already in progress.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void OpStartPointer()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 4;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// End an interactive operation
    /// <para>
    /// <br/>
    /// End an interactive operation.<br/>
    /// <br/>
    /// This request is ignored if there is no operation in progress.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void OpEnd()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 5;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Define a new pointer binding
    /// <para>
    /// <br/>
    /// Define a pointer binding in terms of a pointer button, keyboard<br/>
    /// modifiers, and other configurable properties.<br/>
    /// <br/>
    /// The button argument is a Linux input event code defined in the<br/>
    /// linux/input-event-codes.h header file (e.g. BTN_RIGHT).<br/>
    /// <br/>
    /// The new pointer binding is not enabled until initial configuration is<br/>
    /// completed and the enable request is made during a manage sequence.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe RiverPointerBindingV1 GetPointerBinding(uint button, uint modifiers)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[3];
        args[0].o = (WlObject*)IntPtr.Zero;
        args[1].u = button;
        args[2].u = modifiers;

        const uint opcode = 6;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.RiverPointerBindingV1,
            (uint)WaylandInterfaces.RiverPointerBindingV1->Version,
            0,
            (nint)args
        );

        return new RiverPointerBindingV1(newProxy, Display);
    }

    /// <summary>
    /// Set the xcursor theme for the seat
    /// <para>
    /// <br/>
    /// Set the XCursor theme for the seat. This theme is used for cursors<br/>
    /// rendered by the compositor, but not necessarily for cursors rendered by<br/>
    /// clients.<br/>
    /// <br/>
    /// Note: The window manager may also wish to set the XCURSOR_THEME and<br/>
    /// XCURSOR_SIZE environment variable for programs it starts.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetXcursorTheme(string name, uint size)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].s = Utf8StringMarshaller.ConvertToUnmanaged(name);
        args[1].u = size;

        const uint opcode = 7;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Warp the pointer to a given position
    /// <para>
    /// <br/>
    /// Warp the pointer to the given position in the compositor's logical<br/>
    /// coordinate space.<br/>
    /// <br/>
    /// If the given position is outside the bounds of all outputs, the pointer<br/>
    /// will be warped to the closest point inside an output instead.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void PointerWarp(int x, int y)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].i = x;
        args[1].i = y;

        const uint opcode = 8;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static RiverSeatV1 Create(nint handle, WlDisplay display)
    {
        return new RiverSeatV1(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
