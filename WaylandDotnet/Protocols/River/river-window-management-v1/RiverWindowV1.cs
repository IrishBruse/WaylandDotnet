// <auto-generated>
// This file was generated from river-window-management-v1.xml
// Stability: River
// Link: https://wayland.app/protocols/river-window-management-v1
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.River;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// river_window_v1
/// <para> a logical window </para>
/// <para> Version: 3 </para>
/// <see>https://wayland.app/protocols/river-window-management-v1/#river_window_v1</see>
/// </summary>
public sealed partial class RiverWindowV1 : WaylandObject, IWaylandObjectFactory<RiverWindowV1>
{
    public const string InterfaceName = "river_window_v1";
    public static string _StaticInterfaceName => "river_window_v1";
    public const int InterfaceVersion = 3;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public RiverWindowV1(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// window already has a node object
        /// </summary>
        NodeExists = 0,
        /// <summary>
        /// proposed dimensions out of bounds
        /// </summary>
        InvalidDimensions = 1,
        /// <summary>
        /// invalid arg to set_borders
        /// </summary>
        InvalidBorder = 2,
        /// <summary>
        /// invalid arg to set_clip_box
        /// </summary>
        InvalidClipBox = 3,
    }

    /// <summary>  </summary>
    public enum DecorationHint : uint
    {
        /// <summary>
        /// only supports client side decoration
        /// </summary>
        OnlySupportsCsd = 0,
        /// <summary>
        /// client side decoration preferred, both CSD and SSD supported
        /// </summary>
        PrefersCsd = 1,
        /// <summary>
        /// server side decoration preferred, both CSD and SSD supported
        /// </summary>
        PrefersSsd = 2,
        /// <summary>
        /// no preference, both CSD and SSD supported
        /// </summary>
        NoPreference = 3,
    }

    /// <summary>  </summary>
    [Flags]
    public enum EdgesFlag : uint
    {
        /// <summary>
        ///
        /// </summary>
        None = 0,
        /// <summary>
        ///
        /// </summary>
        Top = 1,
        /// <summary>
        ///
        /// </summary>
        Bottom = 2,
        /// <summary>
        ///
        /// </summary>
        Left = 4,
        /// <summary>
        ///
        /// </summary>
        Right = 8,
    }

    /// <summary>  </summary>
    [Flags]
    public enum CapabilitiesFlag : uint
    {
        /// <summary>
        ///
        /// </summary>
        WindowMenu = 1,
        /// <summary>
        ///
        /// </summary>
        Maximize = 2,
        /// <summary>
        ///
        /// </summary>
        Fullscreen = 4,
        /// <summary>
        ///
        /// </summary>
        Minimize = 8,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void ClosedHandler();

    private ClosedHandler? _onClosed;

    /// <summary>
    ///The window has been closed
    /// <para>
    ///
    ///The window has been closed by the server, perhaps due to an
    ///xdg_toplevel.close request or similar.
    ///
    ///The server will send no further events on this object and ignore any
    ///request other than river_window_v1.destroy made after this event is
    ///sent. The client should destroy this object with the
    ///river_window_v1.destroy request to free up resources.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event ClosedHandler? OnClosed
    {
        add
        {
            CheckDisposed();
            _onClosed += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onClosed -= value;
        }
    }

    public delegate void DimensionsHintHandler(int minWidth, int minHeight, int maxWidth, int maxHeight);

    private DimensionsHintHandler? _onDimensionsHint;

    /// <summary>
    ///The window's preferred min/max dimensions
    /// <para>
    ///
    ///This event informs the window manager of the window's preferred min/max
    ///dimensions. These preferences are a hint, and the window manager is free
    ///to propose dimensions outside of these bounds.
    ///
    ///All min/max width/height values must be strictly greater than or equal
    ///to 0. A value of 0 indicates that the window has no preference for that
    ///value.
    ///
    ///The min_width/min_height must be strictly less than or equal to the
    ///max_width/max_height.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event DimensionsHintHandler? OnDimensionsHint
    {
        add
        {
            CheckDisposed();
            _onDimensionsHint += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDimensionsHint -= value;
        }
    }

    public delegate void DimensionsHandler(int width, int height);

    private DimensionsHandler? _onDimensions;

    /// <summary>
    ///Window dimensions
    /// <para>
    ///
    ///This event indicates the dimensions of the window in the compositor's
    ///logical coordinate space. The width and height must be strictly greater
    ///than zero.
    ///
    ///Note that the dimensions of a river_window_v1 refer to the dimensions of
    ///the window content and are unaffected by the presence of borders or
    ///decoration surfaces.
    ///
    ///This event is sent as part of a render sequence before the render_start
    ///event.
    ///
    ///It may be sent due to a propose_dimensions or fullscreen request in a
    ///previous manage sequence or because a window independently decides to
    ///change its dimensions.
    ///
    ///The window will not be displayed until the first dimensions event is
    ///received and the render sequence is finished.
    ///
    /// </para>
    /// </summary>
    public event DimensionsHandler? OnDimensions
    {
        add
        {
            CheckDisposed();
            _onDimensions += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDimensions -= value;
        }
    }

    public delegate void AppIdHandler(string? appId);

    private AppIdHandler? _onAppId;

    /// <summary>
    ///The window set an application ID
    /// <para>
    ///
    ///The window set an application ID.
    ///
    ///The app_id argument will be null if the window has never set an
    ///application ID or if the window cleared its application ID. (Xwayland
    ///windows may do this for example, though xdg-toplevels may not.)
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event AppIdHandler? OnAppId
    {
        add
        {
            CheckDisposed();
            _onAppId += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onAppId -= value;
        }
    }

    public delegate void TitleHandler(string? title);

    private TitleHandler? _onTitle;

    /// <summary>
    ///The window set a title
    /// <para>
    ///
    ///The window set a title.
    ///
    ///The title argument will be null if the window has never set a title or
    ///if the window cleared its title. (Xwayland windows may do this for
    ///example, though xdg-toplevels may not.)
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event TitleHandler? OnTitle
    {
        add
        {
            CheckDisposed();
            _onTitle += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onTitle -= value;
        }
    }

    public delegate void ParentHandler(RiverWindowV1? parent);

    private ParentHandler? _onParent;

    /// <summary>
    ///The window set a parent
    /// <para>
    ///
    ///The window set a parent window. If this event is never received or if
    ///the parent argument is null then the window has no parent.
    ///
    ///A surface with a parent set might be a dialog, file picker, or similar
    ///for the parent window.
    ///
    ///Child windows should generally be rendered directly above their parent.
    ///
    ///The compositor must guarantee that there are no loops in the window
    ///tree: a parent must not be the descendant of one of its children.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event ParentHandler? OnParent
    {
        add
        {
            CheckDisposed();
            _onParent += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onParent -= value;
        }
    }

    public delegate void DecorationHintHandler(uint hint);

    private DecorationHintHandler? _onDecorationHint;

    /// <summary>
    ///Supported/preferred decoration style
    /// <para>
    ///
    ///Information from the window about the supported and preferred client
    ///side/server side decoration options.
    ///
    ///This event may be sent multiple times over the lifetime of the window if
    ///the window changes its preferences.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event DecorationHintHandler? OnDecorationHint
    {
        add
        {
            CheckDisposed();
            _onDecorationHint += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDecorationHint -= value;
        }
    }

    public delegate void PointerMoveRequestedHandler(RiverSeatV1 seat);

    private PointerMoveRequestedHandler? _onPointerMoveRequested;

    /// <summary>
    ///Window requested interactive pointer move
    /// <para>
    ///
    ///This event informs the window manager that the window has requested to
    ///be interactively moved using the pointer. The seat argument indicates the
    ///seat for the move.
    ///
    ///The xdg-shell protocol for example allows windows to request that an
    ///interactive move be started, perhaps when a client-side rendered
    ///titlebar is dragged.
    ///
    ///The window manager may use the river_seat_v1.op_start_pointer request to
    ///interactively move the window or ignore this event entirely.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event PointerMoveRequestedHandler? OnPointerMoveRequested
    {
        add
        {
            CheckDisposed();
            _onPointerMoveRequested += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPointerMoveRequested -= value;
        }
    }

    public delegate void PointerResizeRequestedHandler(RiverSeatV1 seat, uint edges);

    private PointerResizeRequestedHandler? _onPointerResizeRequested;

    /// <summary>
    ///Window requested interactive pointer resize
    /// <para>
    ///
    ///This event informs the window manager that the window has requested to
    ///be interactively resized using the pointer. The seat argument indicates
    ///the seat for the resize.
    ///
    ///The edges argument indicates which edges the window has requested to be
    ///resized from. The edges argument will never be none and will never have
    ///both top and bottom or both left and right edges set.
    ///
    ///The xdg-shell protocol for example allows windows to request that an
    ///interactive resize be started, perhaps when the corner of client-side
    ///rendered decorations is dragged.
    ///
    ///The window manager may use the river_seat_v1.op_start_pointer request to
    ///interactively resize the window or ignore this event entirely.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event PointerResizeRequestedHandler? OnPointerResizeRequested
    {
        add
        {
            CheckDisposed();
            _onPointerResizeRequested += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPointerResizeRequested -= value;
        }
    }

    public delegate void ShowWindowMenuRequestedHandler(int x, int y);

    private ShowWindowMenuRequestedHandler? _onShowWindowMenuRequested;

    /// <summary>
    ///Window requested that the window menu be shown
    /// <para>
    ///
    ///The xdg-shell protocol for example allows windows to request that a
    ///window menu be shown, for example when the user right clicks on client
    ///side window decorations.
    ///
    ///A window menu might include options to maximize or minimize the window.
    ///
    ///The window manager is free to ignore this request and decide what the
    ///window menu contains if it does choose to show one.
    ///
    ///The x and y arguments indicate where the window requested that the
    ///window menu be shown.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event ShowWindowMenuRequestedHandler? OnShowWindowMenuRequested
    {
        add
        {
            CheckDisposed();
            _onShowWindowMenuRequested += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onShowWindowMenuRequested -= value;
        }
    }

    public delegate void MaximizeRequestedHandler();

    private MaximizeRequestedHandler? _onMaximizeRequested;

    /// <summary>
    ///The window requested to be maximized
    /// <para>
    ///
    ///The xdg-shell protocol for example allows windows to request to be
    ///maximized.
    ///
    ///The window manager is free to honor this request using
    ///river_window_v1.inform_maximize or ignore it.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event MaximizeRequestedHandler? OnMaximizeRequested
    {
        add
        {
            CheckDisposed();
            _onMaximizeRequested += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onMaximizeRequested -= value;
        }
    }

    public delegate void UnmaximizeRequestedHandler();

    private UnmaximizeRequestedHandler? _onUnmaximizeRequested;

    /// <summary>
    ///The window requested to be unmaximized
    /// <para>
    ///
    ///The xdg-shell protocol for example allows windows to request to be
    ///unmaximized.
    ///
    ///The window manager is free to honor this request using
    ///river_window_v1.inform_unmaximized or ignore it.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event UnmaximizeRequestedHandler? OnUnmaximizeRequested
    {
        add
        {
            CheckDisposed();
            _onUnmaximizeRequested += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onUnmaximizeRequested -= value;
        }
    }

    public delegate void FullscreenRequestedHandler(RiverOutputV1? output);

    private FullscreenRequestedHandler? _onFullscreenRequested;

    /// <summary>
    ///The window requested to be fullscreen
    /// <para>
    ///
    ///The xdg-shell protocol for example allows windows to request that they
    ///be made fullscreen and allows them to provide an output preference.
    ///
    ///The window manager is free to honor this request using
    ///river_window_v1.fullscreen or ignore it.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event FullscreenRequestedHandler? OnFullscreenRequested
    {
        add
        {
            CheckDisposed();
            _onFullscreenRequested += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onFullscreenRequested -= value;
        }
    }

    public delegate void ExitFullscreenRequestedHandler();

    private ExitFullscreenRequestedHandler? _onExitFullscreenRequested;

    /// <summary>
    ///The window requested to exit fullscreen
    /// <para>
    ///
    ///The xdg-shell protocol for example allows windows to request to exit
    ///fullscreen.
    ///
    ///The window manager is free to honor this request using
    ///river_window_v1.exit_fullscreen or ignore it.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event ExitFullscreenRequestedHandler? OnExitFullscreenRequested
    {
        add
        {
            CheckDisposed();
            _onExitFullscreenRequested += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onExitFullscreenRequested -= value;
        }
    }

    public delegate void MinimizeRequestedHandler();

    private MinimizeRequestedHandler? _onMinimizeRequested;

    /// <summary>
    ///The window requested to be minimized
    /// <para>
    ///
    ///The xdg-shell protocol for example allows windows to request to be
    ///minimized.
    ///
    ///The window manager is free to ignore this request, hide the window, or
    ///do whatever else it chooses.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event MinimizeRequestedHandler? OnMinimizeRequested
    {
        add
        {
            CheckDisposed();
            _onMinimizeRequested += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onMinimizeRequested -= value;
        }
    }

    public delegate void UnreliablePidHandler(int unreliablePid);

    private UnreliablePidHandler? _onUnreliablePid;

    /// <summary>
    ///Unreliable PID of the window's creator
    /// <para>
    ///
    ///This event gives an unreliable PID of the process that created the
    ///window. Obtaining this information is inherently racy due to PID reuse.
    ///Therefore, this PID must not be used for anything security sensitive.
    ///
    ///Note also that a single process may create multiple windows, so there is
    ///not necessarily a 1-to-1 mapping from PID to window. Multiple windows
    ///may have the same PID.
    ///
    ///This event is sent once when the river_window_v1 is created and never
    ///sent again.
    ///
    /// </para>
    /// </summary>
    public event UnreliablePidHandler? OnUnreliablePid
    {
        add
        {
            CheckDisposed();
            _onUnreliablePid += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onUnreliablePid -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to river_window_v1");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (RiverWindowV1)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // closed
                    if (obj._onClosed != null)
                    {
                        obj._onClosed?.Invoke();
                    }
                    break;
                case 1: // dimensions_hint
                    if (obj._onDimensionsHint != null)
                    {
                        var _minWidth = args[0].i;
                        var _minHeight = args[1].i;
                        var _maxWidth = args[2].i;
                        var _maxHeight = args[3].i;
                        obj._onDimensionsHint?.Invoke(_minWidth, _minHeight, _maxWidth, _maxHeight);
                    }
                    break;
                case 2: // dimensions
                    if (obj._onDimensions != null)
                    {
                        var _width = args[0].i;
                        var _height = args[1].i;
                        obj._onDimensions?.Invoke(_width, _height);
                    }
                    break;
                case 3: // app_id
                    if (obj._onAppId != null)
                    {
                        var _appId = Utf8StringMarshaller.ConvertToManaged(args[0].s);
                        obj._onAppId?.Invoke(_appId);
                    }
                    break;
                case 4: // title
                    if (obj._onTitle != null)
                    {
                        var _title = Utf8StringMarshaller.ConvertToManaged(args[0].s);
                        obj._onTitle?.Invoke(_title);
                    }
                    break;
                case 5: // parent
                    if (obj._onParent != null)
                    {
                        RiverWindowV1? _parent = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'parent'");
                        _parent = new RiverWindowV1((IntPtr)args[0].o, obj.Display);
                        obj._onParent?.Invoke(_parent);
                    }
                    break;
                case 6: // decoration_hint
                    if (obj._onDecorationHint != null)
                    {
                        var _hint = args[0].u;
                        obj._onDecorationHint?.Invoke(_hint);
                    }
                    break;
                case 7: // pointer_move_requested
                    if (obj._onPointerMoveRequested != null)
                    {
                        RiverSeatV1? _seat = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'seat'");
                        _seat = new RiverSeatV1((IntPtr)args[0].o, obj.Display);
                        obj._onPointerMoveRequested?.Invoke(_seat);
                    }
                    break;
                case 8: // pointer_resize_requested
                    if (obj._onPointerResizeRequested != null)
                    {
                        RiverSeatV1? _seat = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'seat'");
                        _seat = new RiverSeatV1((IntPtr)args[0].o, obj.Display);
                        var _edges = args[1].u;
                        obj._onPointerResizeRequested?.Invoke(_seat, _edges);
                    }
                    break;
                case 9: // show_window_menu_requested
                    if (obj._onShowWindowMenuRequested != null)
                    {
                        var _x = args[0].i;
                        var _y = args[1].i;
                        obj._onShowWindowMenuRequested?.Invoke(_x, _y);
                    }
                    break;
                case 10: // maximize_requested
                    if (obj._onMaximizeRequested != null)
                    {
                        obj._onMaximizeRequested?.Invoke();
                    }
                    break;
                case 11: // unmaximize_requested
                    if (obj._onUnmaximizeRequested != null)
                    {
                        obj._onUnmaximizeRequested?.Invoke();
                    }
                    break;
                case 12: // fullscreen_requested
                    if (obj._onFullscreenRequested != null)
                    {
                        RiverOutputV1? _output = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'output'");
                        _output = new RiverOutputV1((IntPtr)args[0].o, obj.Display);
                        obj._onFullscreenRequested?.Invoke(_output);
                    }
                    break;
                case 13: // exit_fullscreen_requested
                    if (obj._onExitFullscreenRequested != null)
                    {
                        obj._onExitFullscreenRequested?.Invoke();
                    }
                    break;
                case 14: // minimize_requested
                    if (obj._onMinimizeRequested != null)
                    {
                        obj._onMinimizeRequested?.Invoke();
                    }
                    break;
                case 15: // unreliable_pid
                    if (obj._onUnreliablePid != null)
                    {
                        var _unreliablePid = args[0].i;
                        obj._onUnreliablePid?.Invoke(_unreliablePid);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Destroy the window object
    /// <para>
    /// <br/>
    /// This request indicates that the client will no longer use the window<br/>
    /// object and that it may be safely destroyed.<br/>
    /// <br/>
    /// This request should be made after the river_window_v1.closed event or<br/>
    /// river_window_manager_v1.finished is received to complete destruction of<br/>
    /// the window.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Request that the window be closed
    /// <para>
    /// <br/>
    /// Request that the window be closed. The window may ignore this request or<br/>
    /// only close after some delay, perhaps opening a dialog asking the user to<br/>
    /// save their work or similar.<br/>
    /// <br/>
    /// The server will send a river_window_v1.closed event if/when the window<br/>
    /// has been closed.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Close()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Get the window's render list node
    /// <para>
    /// <br/>
    /// Get the node in the render list corresponding to the window.<br/>
    /// <br/>
    /// It is a protocol error to make this request more than once for a single<br/>
    /// window.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe RiverNodeV1 GetNode()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)IntPtr.Zero;

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.RiverNodeV1,
            (uint)WaylandInterfaces.RiverNodeV1->Version,
            0,
            (nint)args
        );

        return new RiverNodeV1(newProxy, Display);
    }

    /// <summary>
    /// Propose window dimensions
    /// <para>
    /// <br/>
    /// This request proposes dimensions for the window in the compositor's<br/>
    /// logical coordinate space.<br/>
    /// <br/>
    /// The width and height must be greater than or equal to zero. If the width<br/>
    /// or height is zero the window will be allowed to decide its own<br/>
    /// dimensions.<br/>
    /// <br/>
    /// The window may not take the exact dimensions proposed. The actual<br/>
    /// dimensions taken by the window will be sent in a subsequent<br/>
    /// river_window_v1.dimensions event. For example, a terminal emulator may<br/>
    /// only allow dimensions that are multiple of the cell size.<br/>
    /// <br/>
    /// When a propose_dimensions request is made, the server must send a<br/>
    /// dimensions event in response as soon as possible. It may not be possible<br/>
    /// to send a dimensions event in the very next render sequence if, for<br/>
    /// example, the window takes too long to respond to the proposed<br/>
    /// dimensions. In this case, the server will send the dimensions event in a<br/>
    /// future render sequence.<br/>
    /// <br/>
    /// Note that the dimensions of a river_window_v1 refer to the dimensions of<br/>
    /// the window content and are unaffected by the presence of borders or<br/>
    /// decoration surfaces.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void ProposeDimensions(int width, int height)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].i = width;
        args[1].i = height;

        const uint opcode = 3;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Request that the window be hidden
    /// <para>
    /// <br/>
    /// Request that the window be hidden. Has no effect if the window is<br/>
    /// already hidden. Hides any window borders and decorations as well.<br/>
    /// <br/>
    /// Newly created windows are considered shown unless explicitly hidden with<br/>
    /// the hide request.<br/>
    /// <br/>
    /// This request modifies rendering state and may only be made as part of a<br/>
    /// render sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Hide()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 4;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Request that the window be shown
    /// <para>
    /// <br/>
    /// Request that the window be shown. Has no effect if the window is not<br/>
    /// hidden. Does not guarantee that the window is visible as it may be<br/>
    /// completely obscured by other windows placed above it for example.<br/>
    /// <br/>
    /// Newly created windows are considered shown unless explicitly hidden with<br/>
    /// the hide request.<br/>
    /// <br/>
    /// This request modifies rendering state and may only be made as part of a<br/>
    /// render sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Show()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 5;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Tell the client to use CSD
    /// <para>
    /// <br/>
    /// Tell the client to use client side decoration and draw its own title<br/>
    /// bar, borders, etc.<br/>
    /// <br/>
    /// This is the default if neither this request nor the use_ssd request is<br/>
    /// ever made.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void UseCsd()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 6;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Tell the client to use SSD
    /// <para>
    /// <br/>
    /// Tell the client to use server side decoration and not draw any client<br/>
    /// side decorations.<br/>
    /// <br/>
    /// This request will have no effect if the client only supports client side<br/>
    /// decoration, see the decoration_hint event.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void UseSsd()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 7;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set window borders
    /// <para>
    /// <br/>
    /// This request decorates the window with borders drawn by the compositor<br/>
    /// on the specified edges of the window. Borders are drawn above the window<br/>
    /// content.<br/>
    /// <br/>
    /// Corners are drawn only between borders on adjacent edges. If e.g. the<br/>
    /// left edge has a border and the top edge does not, the border drawn on<br/>
    /// the left edge will not extend vertically beyond the top edge of the<br/>
    /// window.<br/>
    /// <br/>
    /// Borders are not drawn while the window is fullscreen.<br/>
    /// <br/>
    /// The color is defined by four 32-bit RGBA values. Unless specified in<br/>
    /// another protocol extension, the RGBA values use pre-multiplied alpha.<br/>
    /// <br/>
    /// Setting the edges to none or the width to 0 disables the borders.<br/>
    /// Setting a negative width is a protocol error.<br/>
    /// <br/>
    /// This request completely overrides all previous set_borders requests.<br/>
    /// Only the most recent set_borders request has an effect.<br/>
    /// <br/>
    /// Note that the position/dimensions of a river_window_v1 refer to the<br/>
    /// position/dimensions of the window content and are unaffected by the<br/>
    /// presence of borders or decoration surfaces.<br/>
    /// <br/>
    /// This request modifies rendering state and may only be made as part of a<br/>
    /// render sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetBorders(uint edges, int width, uint r, uint g, uint b, uint a)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[6];
        args[0].u = edges;
        args[1].i = width;
        args[2].u = r;
        args[3].u = g;
        args[4].u = b;
        args[5].u = a;

        const uint opcode = 8;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Set window tiled state
    /// <para>
    /// <br/>
    /// Inform the window that it is part of a tiled layout and adjacent to<br/>
    /// other elements in the tiled layout on the given edges.<br/>
    /// <br/>
    /// The window should use this information to change the style of its client<br/>
    /// side decorations and avoid drawing e.g. drop shadows outside of the<br/>
    /// window dimensions on the tiled edges.<br/>
    /// <br/>
    /// Setting the edges argument to none informs the window that it is not<br/>
    /// part of a tiled layout. If this request is never made, the window is<br/>
    /// informed that it is not part of a tiled layout.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetTiled(uint edges)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].u = edges;

        const uint opcode = 9;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Create a decoration surface above the window
    /// <para>
    /// <br/>
    /// Create a decoration surface and assign the river_decoration_v1 role to<br/>
    /// the surface. The created decoration is placed above the window in<br/>
    /// rendering order, see the description of river_decoration_v1.<br/>
    /// <br/>
    /// Providing a wl_surface which already has a role or already has a buffer<br/>
    /// attached or committed is a protocol error.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe RiverDecorationV1 GetDecorationAbove(WlSurface surface)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].o = (WlObject*)IntPtr.Zero;
        args[1].o = (WlObject*)(surface?.Handle ?? IntPtr.Zero);

        const uint opcode = 10;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.RiverDecorationV1,
            (uint)WaylandInterfaces.RiverDecorationV1->Version,
            0,
            (nint)args
        );

        return new RiverDecorationV1(newProxy, Display);
    }

    /// <summary>
    /// Create a decoration surface below the window
    /// <para>
    /// <br/>
    /// Create a decoration surface and assign the river_decoration_v1 role to<br/>
    /// the surface. The created decoration is placed below the window in<br/>
    /// rendering order, see the description of river_decoration_v1.<br/>
    /// <br/>
    /// Providing a wl_surface which already has a role or already has a buffer<br/>
    /// attached or committed is a protocol error.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe RiverDecorationV1 GetDecorationBelow(WlSurface surface)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].o = (WlObject*)IntPtr.Zero;
        args[1].o = (WlObject*)(surface?.Handle ?? IntPtr.Zero);

        const uint opcode = 11;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.RiverDecorationV1,
            (uint)WaylandInterfaces.RiverDecorationV1->Version,
            0,
            (nint)args
        );

        return new RiverDecorationV1(newProxy, Display);
    }

    /// <summary>
    /// Inform the window it is being resized
    /// <para>
    /// <br/>
    /// Inform the window that it is being resized. The window manager should<br/>
    /// use this request to inform windows that are the target of an interactive<br/>
    /// resize for example.<br/>
    /// <br/>
    /// The window manager remains responsible for handling the position and<br/>
    /// dimensions of the window while it is resizing.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void InformResizeStart()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 12;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Inform the window it no longer being resized
    /// <para>
    /// <br/>
    /// Inform the window that it is no longer being resized. The window manager<br/>
    /// should use this request to inform windows that are the target of an<br/>
    /// interactive resize that the interactive resize has ended for example.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void InformResizeEnd()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 13;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Inform window of supported capabilities
    /// <para>
    /// <br/>
    /// This request informs the window of the capabilities supported by the<br/>
    /// window manager. If the window manager, for example, ignores requests to<br/>
    /// be maximized from the window it should not tell the window that it<br/>
    /// supports the maximize capability.<br/>
    /// <br/>
    /// The window might use this information to, for example, only show a<br/>
    /// maximize button if the window manager supports the maximize capability.<br/>
    /// <br/>
    /// The window manager client should use this request to set capabilities<br/>
    /// for all new windows. If this request is never made, the compositor will<br/>
    /// inform windows that all capabilities are supported.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetCapabilities(uint caps)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].u = caps;

        const uint opcode = 14;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Inform the window that it is maximized
    /// <para>
    /// <br/>
    /// Inform the window that it is maximized. The window might use this<br/>
    /// information to adapt the style of its client-side window decorations for<br/>
    /// example.<br/>
    /// <br/>
    /// The window manager remains responsible for handling the position and<br/>
    /// dimensions of the window while it is maximized.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void InformMaximized()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 15;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Inform the window that it is unmaximized
    /// <para>
    /// <br/>
    /// Inform the window that it is unmaximized. The window might use this<br/>
    /// information to adapt the style of its client-side window decorations for<br/>
    /// example.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void InformUnmaximized()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 16;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Inform the window that it is fullscreen
    /// <para>
    /// <br/>
    /// Inform the window that it is fullscreen. The window might use this<br/>
    /// information to adapt the style of its client-side window decorations for<br/>
    /// example.<br/>
    /// <br/>
    /// This request does not affect the size/position of the window or cause it<br/>
    /// to become the only window rendered, see the river_window_v1.fullscreen<br/>
    /// and exit_fullscreen requests for that.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void InformFullscreen()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 17;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Inform the window that it is not fullscreen
    /// <para>
    /// <br/>
    /// Inform the window that it is not fullscreen. The window might use this<br/>
    /// information to adapt the style of its client-side window decorations for<br/>
    /// example.<br/>
    /// <br/>
    /// This request does not affect the size/position of the window or cause it<br/>
    /// to become the only window rendered, see the river_window_v1.fullscreen<br/>
    /// and exit_fullscreen requests for that.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void InformNotFullscreen()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 18;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Make the window fullscreen
    /// <para>
    /// <br/>
    /// Make the window fullscreen on the given output. If multiple windows are<br/>
    /// fullscreen on the same output at the same time only the "top" window in<br/>
    /// rendering order shall be displayed.<br/>
    /// <br/>
    /// All river_shell_surface_v1 objects above the top fullscreen window in<br/>
    /// the rendering order will continue to be rendered.<br/>
    /// <br/>
    /// The compositor will handle the position and dimensions of the window<br/>
    /// while it is fullscreen. The set_position and propose_dimensions requests<br/>
    /// shall not affect the current position and dimensions of a fullscreen<br/>
    /// window.<br/>
    /// <br/>
    /// When a fullscreen request is made, the server must send a dimensions<br/>
    /// event in response as soon as possible. It may not be possible to send a<br/>
    /// dimensions event in the very next render sequence if, for example, the<br/>
    /// window takes too long to respond. In this case, the server will send the<br/>
    /// dimensions event in a future render sequence.<br/>
    /// <br/>
    /// The compositor will clip window content, decoration surfaces, and<br/>
    /// borders to the given output's dimensions while the window is fullscreen.<br/>
    /// The effects of set_clip_box and set_content_clip_box are ignored while<br/>
    /// the window is fullscreen.<br/>
    /// <br/>
    /// If the output on which a window is currently fullscreen is removed, the<br/>
    /// windowing state is modified as if there were an exit_fullscreen request<br/>
    /// made in the same manage sequence as the river_output_v1.removed event.<br/>
    /// <br/>
    /// This request does not inform the window that it is fullscreen, see the<br/>
    /// river_window_v1.inform_fullscreen and inform_not_fullscreen requests.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Fullscreen(RiverOutputV1 output)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[1];
        args[0].o = (WlObject*)(output?.Handle ?? IntPtr.Zero);

        const uint opcode = 19;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Make the window not fullscreen
    /// <para>
    /// <br/>
    /// Make the window not fullscreen.<br/>
    /// <br/>
    /// The position and dimensions are undefined after this request is made<br/>
    /// until a manage sequence in which the window manager makes the<br/>
    /// propose_dimensions and set_position requests is completed.<br/>
    /// <br/>
    /// The window manager should make propose_dimensions and set_position<br/>
    /// requests in the same manage sequence as the exit_fullscreen request for<br/>
    /// frame perfection.<br/>
    /// <br/>
    /// This request does not inform the window that it is fullscreen, see the<br/>
    /// river_window_v1.inform_fullscreen and inform_not_fullscreen requests.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void ExitFullscreen()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 20;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Clip the window to a given box
    /// <para>
    /// <br/>
    /// Clip the window, including borders and decoration surfaces, to the box<br/>
    /// specified by the x, y, width, and height arguments. The x/y position of<br/>
    /// the box is relative to the top left corner of the window.<br/>
    /// <br/>
    /// The width and height arguments must be greater than or equal to 0.<br/>
    /// <br/>
    /// Setting a clip box with 0 width or height disables clipping.<br/>
    /// <br/>
    /// The clip box is ignored while the window is fullscreen.<br/>
    /// <br/>
    /// Both set_clip_box and set_content_clip_box may be enabled simultaneously.<br/>
    /// <br/>
    /// This request modifies rendering state and may only be made as part of a<br/>
    /// render sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetClipBox(int x, int y, int width, int height)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].i = x;
        args[1].i = y;
        args[2].i = width;
        args[3].i = height;

        const uint opcode = 21;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Clip the window content to a given box
    /// <para>
    /// <br/>
    /// Clip the content of the window, excluding borders and decoration<br/>
    /// surfaces, to the box specified by the x, y, width, and height arguments.<br/>
    /// The x/y position of the box is relative to the top left corner of the<br/>
    /// window.<br/>
    /// <br/>
    /// Borders drawn by the compositor (see set_borders) are placed around the<br/>
    /// intersection of the window content (as defined by the dimensions event)<br/>
    /// and the content clip box when content clipping is enabled.<br/>
    /// <br/>
    /// The width and height arguments must be greater than or equal to 0.<br/>
    /// <br/>
    /// Setting a box with 0 width or height disables content clipping.<br/>
    /// <br/>
    /// The content clip box is ignored while the window is fullscreen.<br/>
    /// <br/>
    /// Both set_clip_box and set_content_clip_box may be enabled simultaneously.<br/>
    /// <br/>
    /// This request modifies rendering state and may only be made as part of a<br/>
    /// render sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void SetContentClipBox(int x, int y, int width, int height)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[4];
        args[0].i = x;
        args[1].i = y;
        args[2].i = width;
        args[3].i = height;

        const uint opcode = 22;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static RiverWindowV1 Create(nint handle, WlDisplay display)
    {
        return new RiverWindowV1(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
