// <auto-generated>
// This file was generated from river-window-management-v1.xml
// Stability: River
// Link: https://wayland.app/protocols/river-window-management-v1
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.River;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// river_window_manager_v1
/// <para> window manager global interface </para>
/// <para> Version: 3 </para>
/// <see>https://wayland.app/protocols/river-window-management-v1/#river_window_manager_v1</see>
/// </summary>
public sealed partial class RiverWindowManagerV1 : WaylandObject, IWaylandObjectFactory<RiverWindowManagerV1>
{
    public const string InterfaceName = "river_window_manager_v1";
    public static string _StaticInterfaceName => "river_window_manager_v1";
    public const int InterfaceVersion = 3;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public RiverWindowManagerV1(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEnums

    /// <summary>  </summary>
    public enum Error : uint
    {
        /// <summary>
        /// request violates manage/render sequence ordering
        /// </summary>
        SequenceOrder = 0,
        /// <summary>
        /// given wl_surface already has a role
        /// </summary>
        Role = 1,
        /// <summary>
        /// window manager unresponsive
        /// </summary>
        Unresponsive = 2,
    }


    #endregion // GenerateEnums


    #region GenerateEventDelegates

    public delegate void UnavailableHandler();

    private UnavailableHandler? _onUnavailable;

    /// <summary>
    ///Window management unavailable
    /// <para>
    ///
    ///This event indicates that window management is not available to the
    ///client, perhaps due to another window management client already running.
    ///The circumstances causing this event to be sent are compositor policy.
    ///
    ///If sent, this event is guaranteed to be the first and only event sent by
    ///the server.
    ///
    ///The server will send no further events on this object. The client should
    ///destroy this object and all objects created through this interface.
    ///
    /// </para>
    /// </summary>
    public event UnavailableHandler? OnUnavailable
    {
        add
        {
            CheckDisposed();
            _onUnavailable += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onUnavailable -= value;
        }
    }

    public delegate void FinishedHandler();

    private FinishedHandler? _onFinished;

    /// <summary>
    ///The server has finished with the window manager
    /// <para>
    ///
    ///This event indicates that the server will send no further events on this
    ///object. The client should destroy the object. See
    ///river_window_manager_v1.destroy for more information.
    ///
    /// </para>
    /// </summary>
    public event FinishedHandler? OnFinished
    {
        add
        {
            CheckDisposed();
            _onFinished += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onFinished -= value;
        }
    }

    public delegate void ManageStartHandler();

    private ManageStartHandler? _onManageStart;

    /// <summary>
    ///Start a manage sequence
    /// <para>
    ///
    ///This event indicates that the server has sent events indicating all
    ///state changes since the last manage sequence.
    ///
    ///In response to this event, the client should make requests modifying
    ///window management state as it chooses. Then, the client must make the
    ///manage_finish request.
    ///
    ///See the description of the river_window_manager_v1 interface for a
    ///complete overview of the manage/render sequence loop.
    ///
    /// </para>
    /// </summary>
    public event ManageStartHandler? OnManageStart
    {
        add
        {
            CheckDisposed();
            _onManageStart += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onManageStart -= value;
        }
    }

    public delegate void RenderStartHandler();

    private RenderStartHandler? _onRenderStart;

    /// <summary>
    ///Start a render sequence
    /// <para>
    ///
    ///This event indicates that the server has sent all river_node_v1.position
    ///and river_window_v1.dimensions events necessary.
    ///
    ///In response to this event, the client should make requests modifying
    ///rendering state as it chooses. Then, the client must make the
    ///render_finish request.
    ///
    ///See the description of the river_window_manager_v1 interface for a
    ///complete overview of the manage/render sequence loop.
    ///
    /// </para>
    /// </summary>
    public event RenderStartHandler? OnRenderStart
    {
        add
        {
            CheckDisposed();
            _onRenderStart += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onRenderStart -= value;
        }
    }

    public delegate void SessionLockedHandler();

    private SessionLockedHandler? _onSessionLocked;

    /// <summary>
    ///The session has been locked
    /// <para>
    ///
    ///This event indicates that the session has been locked.
    ///
    ///The window manager may wish to restrict which key bindings are available
    ///while locked or otherwise use this information.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event SessionLockedHandler? OnSessionLocked
    {
        add
        {
            CheckDisposed();
            _onSessionLocked += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onSessionLocked -= value;
        }
    }

    public delegate void SessionUnlockedHandler();

    private SessionUnlockedHandler? _onSessionUnlocked;

    /// <summary>
    ///The session has been unlocked
    /// <para>
    ///
    ///This event indicates that the session has been unlocked.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event SessionUnlockedHandler? OnSessionUnlocked
    {
        add
        {
            CheckDisposed();
            _onSessionUnlocked += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onSessionUnlocked -= value;
        }
    }

    public delegate void WindowHandler(RiverWindowV1 id);

    private WindowHandler? _onWindow;

    /// <summary>
    ///New window
    /// <para>
    ///
    ///A new window has been created.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event WindowHandler? OnWindow
    {
        add
        {
            CheckDisposed();
            _onWindow += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onWindow -= value;
        }
    }

    public delegate void OutputHandler(RiverOutputV1 id);

    private OutputHandler? _onOutput;

    /// <summary>
    ///New output
    /// <para>
    ///
    ///A new logical output has been created, perhaps due to a new physical
    ///monitor being plugged in or perhaps due to a change in configuration.
    ///
    ///This event will be followed by river_output_v1.position and dimensions
    ///events as well as a manage_start event after all other new state has
    ///been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event OutputHandler? OnOutput
    {
        add
        {
            CheckDisposed();
            _onOutput += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onOutput -= value;
        }
    }

    public delegate void SeatHandler(RiverSeatV1 id);

    private SeatHandler? _onSeat;

    /// <summary>
    ///New seat
    /// <para>
    ///
    ///A new seat has been created.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event SeatHandler? OnSeat
    {
        add
        {
            CheckDisposed();
            _onSeat += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onSeat -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to river_window_manager_v1");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (RiverWindowManagerV1)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // unavailable
                    if (obj._onUnavailable != null)
                    {
                        obj._onUnavailable?.Invoke();
                    }
                    break;
                case 1: // finished
                    if (obj._onFinished != null)
                    {
                        obj._onFinished?.Invoke();
                    }
                    break;
                case 2: // manage_start
                    if (obj._onManageStart != null)
                    {
                        obj._onManageStart?.Invoke();
                    }
                    break;
                case 3: // render_start
                    if (obj._onRenderStart != null)
                    {
                        obj._onRenderStart?.Invoke();
                    }
                    break;
                case 4: // session_locked
                    if (obj._onSessionLocked != null)
                    {
                        obj._onSessionLocked?.Invoke();
                    }
                    break;
                case 5: // session_unlocked
                    if (obj._onSessionUnlocked != null)
                    {
                        obj._onSessionUnlocked?.Invoke();
                    }
                    break;
                case 6: // window
                    if (obj._onWindow != null)
                    {
                        RiverWindowV1? _id = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'id'");
                        _id = new RiverWindowV1((IntPtr)args[0].o, obj.Display);
                        obj._onWindow?.Invoke(_id);
                    }
                    break;
                case 7: // output
                    if (obj._onOutput != null)
                    {
                        RiverOutputV1? _id = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'id'");
                        _id = new RiverOutputV1((IntPtr)args[0].o, obj.Display);
                        obj._onOutput?.Invoke(_id);
                    }
                    break;
                case 8: // seat
                    if (obj._onSeat != null)
                    {
                        RiverSeatV1? _id = null;
                        if (args[0].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException("Received null object for non-nullable argument 'id'");
                        _id = new RiverSeatV1((IntPtr)args[0].o, obj.Display);
                        obj._onSeat?.Invoke(_id);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Stop sending events
    /// <para>
    /// <br/>
    /// This request indicates that the client no longer wishes to receive<br/>
    /// events on this object.<br/>
    /// <br/>
    /// The Wayland protocol is asynchronous, which means the server may send<br/>
    /// further events until the stop request is processed. The client must wait<br/>
    /// for a river_window_manager_v1.finished event before destroying this<br/>
    /// object.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Stop()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Destroy the river_window_manager_v1 object
    /// <para>
    /// <br/>
    /// This request should be called after the finished event has been received<br/>
    /// to complete destruction of the object.<br/>
    /// <br/>
    /// If a client wishes to destroy this object it should send a<br/>
    /// river_window_manager_v1.stop request and wait for a<br/>
    /// river_window_manager_v1.finished event. Once the finished event is<br/>
    /// received it is safe to destroy this object and any other objects created<br/>
    /// through this interface.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Finish a manage sequence
    /// <para>
    /// <br/>
    /// This request indicates that the client has made all changes to window<br/>
    /// management state it wishes to include in the current manage sequence and<br/>
    /// that the server should atomically send these state changes to the<br/>
    /// windows and continue with the manage sequence.<br/>
    /// <br/>
    /// After sending this request, it is a protocol error for the client to<br/>
    /// make further changes to window management state until the next<br/>
    /// manage_start event is received.<br/>
    /// <br/>
    /// See the description of the river_window_manager_v1 interface for a<br/>
    /// complete overview of the manage/render sequence loop.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void ManageFinish()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Ensure a manage sequence is started
    /// <para>
    /// <br/>
    /// This request ensures a manage sequence is started and that a<br/>
    /// manage_start event is sent by the server. If this request is made during<br/>
    /// an ongoing manage sequence, a new manage sequence will be started as<br/>
    /// soon as the current one is completed.<br/>
    /// <br/>
    /// The client may want to use this request due to an internal state change<br/>
    /// that the compositor is not aware of (e.g. a dbus event) which should<br/>
    /// affect window management or rendering state.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void ManageDirty()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 3;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Finish a render sequence
    /// <para>
    /// <br/>
    /// This request indicates that the client has made all changes to rendering<br/>
    /// state it wishes to include in the current manage sequence and that the<br/>
    /// server should atomically apply and display these state changes to the<br/>
    /// user.<br/>
    /// <br/>
    /// After sending this request, it is a protocol error for the client to<br/>
    /// make further changes to rendering state until the next manage_start or<br/>
    /// render_start event is received, whichever comes first.<br/>
    /// <br/>
    /// See the description of the river_window_manager_v1 interface for a<br/>
    /// complete overview of the manage/render sequence loop.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void RenderFinish()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 4;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Assign the river_shell_surface_v1 surface role
    /// <para>
    /// <br/>
    /// Create a new shell surface for window manager UI and assign the<br/>
    /// river_shell_surface_v1 role to the surface.<br/>
    /// <br/>
    /// Providing a wl_surface which already has a role or already has a buffer<br/>
    /// attached or committed is a protocol error.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe RiverShellSurfaceV1 GetShellSurface(WlSurface surface)
    {
        CheckDisposed();

        var args = stackalloc WlArgument[2];
        args[0].o = (WlObject*)IntPtr.Zero;
        args[1].o = (WlObject*)(surface?.Handle ?? IntPtr.Zero);

        const uint opcode = 5;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            WaylandInterfaces.RiverShellSurfaceV1,
            (uint)WaylandInterfaces.RiverShellSurfaceV1->Version,
            0,
            (nint)args
        );

        return new RiverShellSurfaceV1(newProxy, Display);
    }


    #endregion // GenerateRequests

    public static RiverWindowManagerV1 Create(nint handle, WlDisplay display)
    {
        return new RiverWindowManagerV1(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
