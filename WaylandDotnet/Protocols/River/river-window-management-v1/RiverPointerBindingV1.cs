// <auto-generated>
// This file was generated from river-window-management-v1.xml
// Stability: River
// Link: https://wayland.app/protocols/river-window-management-v1
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.River;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// river_pointer_binding_v1
/// <para> configure a pointer binding, receive trigger events </para>
/// <para> Version: 3 </para>
/// <see>https://wayland.app/protocols/river-window-management-v1/#river_pointer_binding_v1</see>
/// </summary>
public sealed partial class RiverPointerBindingV1 : WaylandObject, IWaylandObjectFactory<RiverPointerBindingV1>
{
    public const string InterfaceName = "river_pointer_binding_v1";
    public static string _StaticInterfaceName => "river_pointer_binding_v1";
    public const int InterfaceVersion = 3;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();


    #region GenerateConstructor

    public RiverPointerBindingV1(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }

    #endregion // GenerateConstructor


    #region GenerateEventDelegates

    public delegate void PressedHandler();

    private PressedHandler? _onPressed;

    /// <summary>
    ///The bound pointer button has been pressed
    /// <para>
    ///
    ///This event indicates that the pointer button triggering the binding has
    ///been pressed.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    ///The compositor should wait for the manage sequence to complete before
    ///processing further input events. This allows the window manager client
    ///to, for example, modify key bindings and keyboard focus without racing
    ///against future input events. The window manager should of course respond
    ///as soon as possible as the capacity of the compositor to buffer incoming
    ///input events is finite.
    ///
    /// </para>
    /// </summary>
    public event PressedHandler? OnPressed
    {
        add
        {
            CheckDisposed();
            _onPressed += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPressed -= value;
        }
    }

    public delegate void ReleasedHandler();

    private ReleasedHandler? _onReleased;

    /// <summary>
    ///The bound pointer button has been released
    /// <para>
    ///
    ///This event indicates that the pointer button triggering the binding has
    ///been released.
    ///
    ///Releasing the modifiers for the binding without releasing the pointer
    ///button does not trigger the release event. This event is sent when the
    ///pointer button is released, even if the modifiers have changed since the
    ///pressed event.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    ///The compositor should wait for the manage sequence to complete before
    ///processing further input events. This allows the window manager client
    ///to, for example, modify key bindings and keyboard focus without racing
    ///against future input events. The window manager should of course respond
    ///as soon as possible as the capacity of the compositor to buffer incoming
    ///input events is finite.
    ///
    /// </para>
    /// </summary>
    public event ReleasedHandler? OnReleased
    {
        add
        {
            CheckDisposed();
            _onReleased += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onReleased -= value;
        }
    }


    #endregion // GenerateEventDelegates


    #region GenerateEvents

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to river_pointer_binding_v1");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (RiverPointerBindingV1)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // pressed
                    if (obj._onPressed != null)
                    {
                        obj._onPressed?.Invoke();
                    }
                    break;
                case 1: // released
                    if (obj._onReleased != null)
                    {
                        obj._onReleased?.Invoke();
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }

    #endregion // GenerateEvents


    #region GenerateRequests

    /// <summary>
    /// Destroy the pointer binding object
    /// <para>
    /// <br/>
    /// This request indicates that the client will no longer use the pointer<br/>
    /// binding object and that it may be safely destroyed.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Enable the pointer binding
    /// <para>
    /// <br/>
    /// This request should be made after all initial configuration has been<br/>
    /// completed and the window manager wishes the pointer binding to be able<br/>
    /// to be triggered.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Enable()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 1;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    /// <summary>
    /// Disable the pointer binding
    /// <para>
    /// <br/>
    /// This request may be used to temporarily disable the pointer binding. It<br/>
    /// may be later re-enabled with the enable request.<br/>
    /// <br/>
    /// This request modifies window management state and may only be made as<br/>
    /// part of a manage sequence, see the river_window_manager_v1 description.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Disable()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 2;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }


    #endregion // GenerateRequests

    public static RiverPointerBindingV1 Create(nint handle, WlDisplay display)
    {
        return new RiverPointerBindingV1(handle, display);
    }

    #region GenerateDisposeOverride

    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }

    #endregion // GenerateDisposeOverride

}
