// <auto-generated>
// This file was generated from river-window-management-v1.xml
// Stability: River
// Link: https://wayland.app/protocols/river-window-management-v1
// </auto-generated>

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable CS8604

namespace WaylandDotnet.River;

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using WaylandDotnet;
using WaylandDotnet.Internal;
using WaylandDotnet.Stable;
using WaylandDotnet.Wlr;

/// <summary>
/// river_output_v1
/// <para> a logical output </para>
/// <para> Version: 3 </para>
/// <see>https://wayland.app/protocols/river-window-management-v1/#river_output_v1</see>
/// </summary>
public sealed partial class RiverOutputV1 : WaylandObject, IWaylandObjectFactory<RiverOutputV1>
{
    public const string InterfaceName = "river_output_v1";
    public static string _StaticInterfaceName => "river_output_v1";
    public const int InterfaceVersion = 3;

    private GCHandle gcHandle;
    private bool dispatcherRegistered = false;
    private readonly object dispatcherLock = new object();

    public RiverOutputV1(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)
    {
    }
    public delegate void RemovedHandler();

    private RemovedHandler? _onRemoved;

    /// <summary>
    ///The output is removed
    /// <para>
    ///
    ///This event indicates that the logical output is no longer conceptually
    ///part of window management space.
    ///
    ///The server will send no further events on this object and ignore any
    ///request (other than river_output_v1.destroy) made after this event is
    ///sent. The client should destroy this object with the
    ///river_output_v1.destroy request to free up resources.
    ///
    ///This event may be sent because a corresponding physical output has been
    ///physically unplugged or because some output configuration has changed.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    /// </para>
    /// </summary>
    public event RemovedHandler? OnRemoved
    {
        add
        {
            CheckDisposed();
            _onRemoved += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onRemoved -= value;
        }
    }

    public delegate void WlOutputHandler(uint name);

    private WlOutputHandler? _onWlOutput;

    /// <summary>
    ///Corresponding wl_output
    /// <para>
    ///
    ///The wl_output object corresponding to the river_output_v1. The argument
    ///is the global name of the wl_output advertised with wl_registry.global.
    ///
    ///It is guaranteed that the corresponding wl_output is advertised before
    ///this event is sent.
    ///
    ///This event is sent exactly once. The wl_output associated with a
    ///river_output_v1 cannot change. It is guaranteed that there is a 1-to-1
    ///mapping between wl_output and river_output_v1 objects.
    ///
    ///The global_remove event for the corresponding wl_output may be sent
    ///before the river_output_v1.remove event. This is due to the fact that
    ///river_output_v1 state changes are synced to the river window management
    ///manage sequence while changes to globals are not.
    ///
    ///Rationale: The window manager may need information provided by the
    ///wl_output interface such as the name/description. It also may need the
    ///wl_output object to start screencopy for example.
    ///
    /// </para>
    /// </summary>
    public event WlOutputHandler? OnWlOutput
    {
        add
        {
            CheckDisposed();
            _onWlOutput += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onWlOutput -= value;
        }
    }

    public delegate void PositionHandler(int x, int y);

    private PositionHandler? _onPosition;

    /// <summary>
    ///Output position
    /// <para>
    ///
    ///This event indicates the position of the output in the compositor's
    ///logical coordinate space. The x and y coordinates may be positive or
    ///negative.
    ///
    ///This event is sent once when the river_output_v1 is created and again
    ///whenever the position changes.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    ///The server must guarantee that the position and dimensions events do not
    ///cause the areas of multiple logical outputs to overlap when the
    ///corresponding manage_start event is received.
    ///
    /// </para>
    /// </summary>
    public event PositionHandler? OnPosition
    {
        add
        {
            CheckDisposed();
            _onPosition += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onPosition -= value;
        }
    }

    public delegate void DimensionsHandler(int width, int height);

    private DimensionsHandler? _onDimensions;

    /// <summary>
    ///Output dimensions
    /// <para>
    ///
    ///This event indicates the dimensions of the output in the compositor's
    ///logical coordinate space. The width and height will always be strictly
    ///greater than zero.
    ///
    ///This event is sent once when the river_output_v1 is created and again
    ///whenever the dimensions change.
    ///
    ///This event will be followed by a manage_start event after all other new
    ///state has been sent by the server.
    ///
    ///The server must guarantee that the position and dimensions events do not
    ///cause the areas of multiple logical outputs to overlap when the
    ///corresponding manage_start event is received.
    ///
    /// </para>
    /// </summary>
    public event DimensionsHandler? OnDimensions
    {
        add
        {
            CheckDisposed();
            _onDimensions += value;
            EnsureDispatcherRegistered();
        }

        remove
        {
            _onDimensions -= value;
        }
    }

    private unsafe void EnsureDispatcherRegistered()
    {
        lock (dispatcherLock)
        {
            if (dispatcherRegistered)
            {
                return;
            }

            // Allocate GCHandle to keep this object alive
            gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);

            // Register the dispatcher with the Wayland proxy
            var dataPtr = GCHandle.ToIntPtr(gcHandle);
            var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);
            if (result != 0)
            {
                gcHandle.Free();
                throw new InvalidOperationException("Failed to add dispatcher to river_output_v1");
            }

            dispatcherRegistered = true;
        }
    }

    [UnmanagedCallersOnly]
    private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)
    {
        try
        {
            var handle = GCHandle.FromIntPtr(userData);
            var obj = (RiverOutputV1)handle.Target!;
            var display = obj.Display;

            switch (opcode)
            {
                case 0: // removed
                    if (obj._onRemoved != null)
                    {
                        obj._onRemoved?.Invoke();
                    }
                    break;
                case 1: // wl_output
                    if (obj._onWlOutput != null)
                    {
                        var _name = args[0].u;
                        obj._onWlOutput?.Invoke(_name);
                    }
                    break;
                case 2: // position
                    if (obj._onPosition != null)
                    {
                        var _x = args[0].i;
                        var _y = args[1].i;
                        obj._onPosition?.Invoke(_x, _y);
                    }
                    break;
                case 3: // dimensions
                    if (obj._onDimensions != null)
                    {
                        var _width = args[0].i;
                        var _height = args[1].i;
                        obj._onDimensions?.Invoke(_width, _height);
                    }
                    break;
                default:
                    return -1;
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in event dispatcher: {ex}");
            return -1;
        }
    }
    /// <summary>
    /// Destroy the output object
    /// <para>
    /// <br/>
    /// This request indicates that the client will no longer use the output<br/>
    /// object and that it may be safely destroyed.<br/>
    /// <br/>
    /// This request should be made after the river_output_v1.removed event is<br/>
    /// received to complete destruction of the output.<br/>
    /// <br/>
    /// </para>
    /// </summary>
    public unsafe void Destroy()
    {
        CheckDisposed();

        var args = stackalloc WlArgument[0];

        const uint opcode = 0;

        var newProxy = WaylandNative.ProxyMarshalArrayFlags(
            Handle,
            opcode,
            (WlInterface*)IntPtr.Zero,
            0,
            0,
            (nint)args
        );
    }

    public static RiverOutputV1 Create(nint handle, WlDisplay display)
    {
        return new RiverOutputV1(handle, display);
    }
    protected override void Dispose(bool disposing)
    {
        if (gcHandle.IsAllocated)
        {
            gcHandle.Free();
        }
        base.Dispose(disposing);
    }
}
