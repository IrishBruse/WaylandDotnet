namespace WaylandScanner;

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Xml.Serialization;
using WaylandDotnet;
using WaylandScanner.Data;

public partial class ProtocolGenerator
{
    public readonly StringBuilder sb = new();
    public SourceFile md = new("");
    public int indentLevel = 0;

    public static readonly string ProjectNamespace = "WaylandDotnet";

    private ProtocolMetadata metadata = null!;
    private static readonly string[] separator = new[] { "\r\n", "\r", "\n" };

    public void GenerateFileHeader(ProtocolMetadata metadata)
    {
        this.metadata = metadata;

        WriteLine($"// <auto-generated>");
        WriteLine($"// This file was generated from {Path.GetFileName(metadata.XmlFile)}");
        WriteLine($"// Stability: {metadata.Namespace}");
        WriteLine($"// Link: {metadata.Link}");
        WriteLine($"// </auto-generated>");
        WriteLine();
        WriteLine($"#nullable enable");
        WriteLine($"#pragma warning disable CS1591");
        WriteLine($"#pragma warning disable CS0108");
        WriteLine($"#pragma warning disable CS8604");
        WriteLine();

        if (metadata.Namespace == "Core")
        {
            WriteLine($"namespace {ProjectNamespace};");
        }
        else
        {
            WriteLine($"namespace {ProjectNamespace}.{metadata.Namespace};");
        }

        WriteLine();
        WriteLine($"using System;");
        WriteLine($"using System.Runtime.CompilerServices;");
        WriteLine($"using System.Runtime.InteropServices;");
        WriteLine($"using System.Runtime.InteropServices.Marshalling;");
        WriteLine($"using System.Text;");
        WriteLine($"using {ProjectNamespace};");
        WriteLine($"using {ProjectNamespace}.Internal;");
        WriteLine($"using {ProjectNamespace}.Stable;");
        // WriteLine($"using {ProjectNamespace}.Staging;");
        // WriteLine($"using {ProjectNamespace}.Unstable;");
        WriteLine($"using {ProjectNamespace}.Wlr;");
        WriteLine();
    }

    public void Generate(ProtocolMetadata metadata)
    {
        string mdFile = Path.GetFileNameWithoutExtension(metadata.XmlFile);
        md = new($"../docs/Protocols/{metadata.Namespace}/{mdFile}.md");

        string ArrowSVG = "![](../../assets/arrow.svg ':class=breadcrumb-arrow')";

        md.WriteLine($"# {metadata.Name}");
        md.WriteLine();
        md.WriteLine($"##### [WaylandDotnet](https://github.com/IrishBruse/WaylandDotnet/blob/main/WaylandDotnet) {ArrowSVG} [{metadata.Namespace}](https://github.com/IrishBruse/WaylandDotnet/blob/main/WaylandDotnet/Protocols/{metadata.Namespace})");
        md.WriteLine();
        md.WriteLine("---");
        md.WriteLine();

        XmlSerializer serializer = new(typeof(WaylandProtocol));
        using FileStream fileStream = new(metadata.XmlFile, FileMode.Open);
        WaylandProtocol protocol = (WaylandProtocol)serializer.Deserialize(fileStream)!;

        foreach (var iface in protocol.Interfaces)
        {
            indentLevel = 0;
            sb.Clear();
            GenerateFileHeader(metadata);
            GenerateInterface(iface);
            var outputFile = Path.Combine(metadata.OutputDir, iface.Name.ToPascal() + ".cs");

            Console.WriteLine($"Generated {metadata.Namespace}/{iface.Name.ToPascal()}.cs");
            File.WriteAllText(outputFile, sb.ToString());
        }

        indentLevel = 0;

        GenerateInterfacesClass(protocol.Interfaces);

        File.WriteAllLines(Path.Combine(metadata.OutputDir, "Copyright.txt"), protocol.Copyright.Trim().Split("\n").Select(s => s.Trim()));

        md.Save();

        Console.WriteLine();
    }

    private void GenerateInterfacesClass(List<WaylandInterface> interfaces)
    {
        sb.Clear();

        WriteLine($"namespace {ProjectNamespace}.Internal;");
        WriteLine();
        WriteLine($"// <auto-generated>");
        WriteLine($"// This file was generated from {Path.GetFileName(metadata.XmlFile)}");
        WriteLine($"// Stability: {metadata.Namespace}");
        WriteLine($"// Link: {metadata.Link}");
        WriteLine($"// </auto-generated>");
        WriteLine();
        WriteLine($"#nullable enable");
        WriteLine($"#pragma warning disable CS1591");
        WriteLine($"#pragma warning disable CS0108");
        WriteLine();
        WriteLine("using System.Runtime.InteropServices;");
        WriteLine("using System.Runtime.InteropServices.Marshalling;");
        WriteLine();
        WriteLine("/// <summary> Static Wayland interface definitions </summary>");
        WriteLine("public static unsafe partial class WaylandInterfaces");
        BeginBlock();
        {
            if (metadata.Namespace == "Core")
            {
                foreach (var iface in interfaces)
                {
                    var className = iface.Name.ToPascal();
                    WriteLine($"public static WlInterface* {className} = Create{className}Interface();");
                }
                WriteLine();
            }
            else
            {
                // TODO: Simplify
                WriteLine("// Use lazy initialization to ensure Core interfaces are initialized first");

                foreach (var iface in interfaces)
                {
                    var className = iface.Name.ToPascal();
                    WriteLine($"private static WlInterface* _{className.ToCamel()};");
                }
                WriteLine();

                foreach (var iface in interfaces)
                {
                    var className = iface.Name.ToPascal();
                    var backingField = $"_{className.ToCamel()}";

                    WriteLine($"public static WlInterface* {className}");
                    BeginBlock();
                    {
                        WriteLine("get");
                        BeginBlock();
                        {
                            WriteLine($"if ({backingField} == null)");
                            BeginBlock();
                            {
                                WriteLine($"{backingField} = Create{className}Interface();");
                            }
                            EndBlock();
                            WriteLine($"return {backingField};");
                        }
                        EndBlock();
                    }
                    EndBlock();
                }
                WriteLine();
            }

            WriteLine($"public static IntPtr? Get{metadata.Namespace}RuntimeInterface(string interfaceName)");
            BeginBlock();
            {
                WriteLine($"return interfaceName switch");
                BeginBlock();
                foreach (var iface in interfaces)
                {
                    var className = iface.Name.ToPascal();
                    WriteLine($"\"{iface.Name}\" => (IntPtr){className},");
                }
                WriteLine($"_ => null");
                EndBlock(";");
            }
            EndBlock();
            WriteLine();

            // Generate interface creation methods
            foreach (var iface in interfaces)
            {
                GenerateInterfaceCreationMethod(iface);
            }
        }
        EndBlock();

        var interfaceFile = Path.Combine(metadata.OutputDir, "WaylandInterfaces.cs");
        File.WriteAllText(interfaceFile, sb.ToString());
    }

    private void GenerateInterfaceCreationMethod(WaylandInterface iface)
    {
        var className = iface.Name.ToPascal();

        var requestCount = iface.Requests.Count;
        var eventCount = iface.Events.Count;
        WriteLine("/// <summary>");
        WriteLine($"/// Interface: {iface.Name}");
        WriteLine($"/// Version: {iface.Version}");
        WriteLine($"/// Requests: {requestCount}, Events: {eventCount}");
        WriteLine("/// </summary>");
        WriteLine($"private static WlInterface* Create{className}Interface()");
        BeginBlock();
        {
            // Generate request signatures
            if (requestCount > 0)
            {
                // MEMORY: This leak is fine as its exepected to live for the whole length of the app
                WriteLine("// Request signatures");
                WriteLine($"var requests = (WlMessage*)Marshal.AllocHGlobal(sizeof(WlMessage) * {requestCount});");
                for (int i = 0; i < requestCount; i++)
                {
                    var request = iface.Requests[i];
                    var signature = GenerateSignature(request.Args);

                    var types = GenerateTypesArray(request.Args);

                    var (finalSignature, finalTypes) = ExpandUntypedNewId(request, signature, types);

                    WriteLine($"requests[{i}] = new WlMessage");
                    BeginBlock();
                    {
                        WriteLine($"Name = Utf8StringMarshaller.ConvertToUnmanaged(\"{request.Name}\"),");
                        WriteLine($"Signature = Utf8StringMarshaller.ConvertToUnmanaged(\"{finalSignature}\"),");
                        WriteLine($"Types = (WlInterface**){finalTypes}");
                    }
                    EndBlock(";");
                }
                WriteLine();
            }

            // Generate event signatures
            if (eventCount > 0)
            {
                WriteLine("// Event signatures");
                WriteLine($"var events = (WlMessage*)Marshal.AllocHGlobal(sizeof(WlMessage) * {eventCount});");
                for (int i = 0; i < eventCount; i++)
                {
                    var evt = iface.Events[i];
                    var signature = GenerateSignature(evt.Args);

                    var types = GenerateTypesArray(evt.Args);

                    WriteLine($"events[{i}] = new WlMessage");
                    BeginBlock();
                    {
                        WriteLine($"Name = Utf8StringMarshaller.ConvertToUnmanaged(\"{evt.Name}\"),");
                        WriteLine($"Signature = Utf8StringMarshaller.ConvertToUnmanaged(\"{signature}\"),");
                        WriteLine($"Types = (WlInterface**){types}");
                    }
                    EndBlock(";");
                }
                WriteLine();
            }

            // Create the interface structure
            WriteLine($"var iface = new WlInterface");
            BeginBlock();
            {
                WriteLine($"Name = Utf8StringMarshaller.ConvertToUnmanaged(\"{iface.Name}\"),");
                WriteLine($"Version = {iface.Version},");
                WriteLine($"MethodCount = {requestCount},");
                WriteLine($"Methods = {(requestCount > 0 ? "requests" : "(WlMessage*)IntPtr.Zero")},");
                WriteLine($"EventCount = {eventCount},");
                WriteLine($"Events = {(eventCount > 0 ? "events" : "(WlMessage*)IntPtr.Zero")}");
            }
            EndBlock(";");
            WriteLine();

            // Allocate and copy to unmanaged memory
            WriteLine("var size = Marshal.SizeOf<WlInterface>();");
            WriteLine("var ptr = (WlInterface*)Marshal.AllocHGlobal(size);");
            WriteLine("Marshal.StructureToPtr(iface, (IntPtr)ptr, false);");
            WriteLine();
            WriteLine("return ptr;");
        }
        EndBlock();
        WriteLine();
    }

    private (string signature, string types) ExpandUntypedNewId(WaylandRequest request, string baseSignature, string baseTypes)
    {
        // Check if this request has an untyped new_id argument
        var newIdArg = request.Args.FirstOrDefault(a => a.Type == "new_id" && string.IsNullOrEmpty(a.Interface));
        if (newIdArg == null)
        {
            // No untyped new_id, return as is
            return (baseSignature, baseTypes);
        }

        // Special case for wl_registry.bind: expand "un" to "usun" TODO: make generic
        if (request.Name == "bind" && baseSignature == "un")
        {
            return ("usun", "CreateTypesArray([(WlInterface*)IntPtr.Zero, (WlInterface*)IntPtr.Zero, (WlInterface*)IntPtr.Zero, (WlInterface*)IntPtr.Zero])");
        }

        return (baseSignature, baseTypes);
    }

    private string GenerateSignature(List<WaylandArg> args)
    {
        if (args.Count == 0) return "";

        var sb = new StringBuilder();
        foreach (var arg in args)
        {
            // Add version prefix if since attribute exists
            if (!string.IsNullOrEmpty(arg.Since) && arg.Since != "1")
            {
                sb.Append(arg.Since);
            }

            // Add nullable prefix
            if (arg.AllowNull?.ToLower() == "true")
            {
                sb.Append('?');
            }

            // Add type character
            sb.Append(GetSignatureChar(arg.Type));
        }
        return sb.ToString();
    }

    /// <summary> Get the Wayland signature character for a type </summary>
    private char GetSignatureChar(string type)
    {
        return type switch
        {
            "int" => 'i',
            "uint" => 'u',
            "fixed" => 'f',
            "string" => 's',
            "object" => 'o',
            "new_id" => 'n',
            "array" => 'a',
            "fd" => 'h',
            _ => '?'
        };
    }

    /// <summary> Generate the types array for interface references </summary>
    private string GenerateTypesArray(List<WaylandArg> args)
    {
        // Always create a types array matching the signature length
        // Each entry is either the interface type or null for non-interface types
        if (args.Count == 0)
        {
            return "IntPtr.Zero";
        }

        var types = new List<string>();
        foreach (var arg in args)
        {
            if ((arg.Type == "object" || arg.Type == "new_id") && !string.IsNullOrEmpty(arg.Interface))
            {
                types.Add($"{arg.Interface.ToPascal()}");
            }
            else
            {
                types.Add("(WlInterface*)IntPtr.Zero");
            }
        }

        return $"CreateTypesArray([{string.Join(", ", types)}])";
    }

    public void GenerateInterface(WaylandInterface iface)
    {
        string className = iface.Name.ToPascal();

        md.WriteLine($"""
        <h2 class='decleration interface'>
            <a href='?id={className}' id='{className}'>
                <span class='codicon codicon-symbol-interface'></span>
                {className}
            </a>
            <span class='pill'>version {iface.Version}</span>
        </h2>
        """
        );
        md.WriteLine();
        md.WriteLine(iface.Description.Summary.CapitalizeFirst());
        md.WriteLine();
        md.WriteLine(iface.Description.Text.TrimLinesStart());
        md.WriteLine();

        WriteLine($"/// <summary>");
        WriteLine($"/// {EscapeXmlDoc(iface.Name)}");
        WriteLine($"/// <para> {EscapeXmlDoc(iface.Description.Summary)} </para>");
        // WriteLine($"/// <para> {EscapeXmlDoc(iface.Description.Summary)} </para>"); TODO: Text
        WriteLine($"/// <para> Version: {iface.Version} </para>");
        WriteLine($"/// <see>{metadata.Link}/#{iface.Name}</see>");
        WriteLine("/// </summary>");
        WriteLine($"public sealed partial class {className} : WaylandObject, IWaylandObjectFactory<{className}>");
        BeginBlock();
        {
            WriteLine($"public const string InterfaceName = \"{iface.Name}\";");
            WriteLine($"public const int InterfaceVersion = {iface.Version};");
            WriteLine();

            // GCHandle field for event handling
            if (iface.Events.Count > 0)
            {
                WriteLine("private GCHandle gcHandle;");
                WriteLine("private bool dispatcherRegistered = false;");
                WriteLine("private readonly object dispatcherLock = new object();");
                WriteLine();
            }

            GenerateConstructor(iface, className);
            GenerateEnums(iface);
            GenerateEventDelegates(iface);
            GenerateEvents(iface);
            GenerateRequests(iface);

            WriteLine($"public static {className} Create(nint handle, WlDisplay display)");
            WriteLine("{");
            WriteLine($"    return new {className}(handle, display);");
            WriteLine("}");

            // Override Dispose to free GCHandle
            if (iface.Events.Count > 0)
            {
                GenerateDisposeOverride();
            }
        }
        EndBlock();
    }

    private void GenerateDisposeOverride()
    {
        BeginRegion();
        WriteLine("protected override void Dispose(bool disposing)");
        BeginBlock();
        {
            WriteLine("if (gcHandle.IsAllocated)");
            BeginBlock();
            {
                WriteLine("gcHandle.Free();");
            }
            EndBlock();
            WriteLine("base.Dispose(disposing);");
        }
        EndBlock();
        EndRegion();
    }

    private void GenerateEnums(WaylandInterface iface)
    {
        if (iface.Enums.Count == 0) return;

        BeginRegion();

        foreach (var enumDef in iface.Enums)
        {
            GenerateEnum(enumDef);
        }
        EndRegion();
    }

    public void GenerateEnum(WaylandEnum enumDef)
    {
        string enumName = (enumDef?.Name ?? "").ToPascal();
        WriteLine($"/// <summary> {EscapeXmlDoc(enumDef?.Description?.Summary ?? "")} </summary>");

        bool isBitfield = enumDef?.Bitfield?.ToLower() == "true";

        if (isBitfield) WriteLine("[Flags]");
        string suffix = isBitfield ? "Flag" : "";
        WriteLine($"public enum {enumName}{suffix} : uint");
        BeginBlock();
        {
            foreach (var entry in enumDef?.Entries ?? [])
            {
                var desc = EscapeXmlDoc(entry.Summary).Trim();
                if (!string.IsNullOrEmpty(desc))
                {
                    desc = " " + desc;
                }
                WriteLine("/// <summary>");
                WriteLine($"///{desc ?? string.Empty}");
                WriteLine("/// </summary>");
                WriteLine($"{entry.Name.ToPascal()} = {entry.Value},");
            }
        }
        EndBlock();
        WriteLine();
    }


    private void GenerateConstructor(WaylandInterface iface, string className)
    {
        BeginRegion();
        WriteLine($"public {className}(IntPtr handle, WlDisplay display) : base(handle, display, InterfaceName, InterfaceVersion)");
        BeginBlock();
        {
            // Empty
        }
        EndBlock();
        EndRegion();
    }


    public void GenerateEventDelegates(WaylandInterface iface)
    {
        if (iface.Events.Count == 0) return;

        BeginRegion();

        foreach (var evt in iface.Events)
        {
            var eventName = evt.Name.ToPascal();
            var delegateName = eventName + "Handler";

            var parameters = string.Join(", ", evt.Args.Select(arg => $"{MapTypeToCSharp(arg.Type, arg.Interface, arg.AllowNull)} {arg.Name.ToCamel()}"));

            WriteLine($"public delegate void {delegateName}({parameters});");
            WriteLine();

            // Generate backing field
            WriteLine($"private {delegateName}? _on{eventName};");
            WriteLine();

            // Generate event property with lazy registration
            WriteLine($"public event {delegateName}? On{eventName}");
            BeginBlock();
            {
                WriteLine("add");
                BeginBlock();
                {
                    WriteLine("CheckDisposed();");
                    WriteLine($"_on{eventName} += value;");
                    WriteLine("EnsureDispatcherRegistered();");
                }
                EndBlock();
                WriteLine();
                WriteLine("remove");
                BeginBlock();
                {
                    WriteLine($"_on{eventName} -= value;");
                }
                EndBlock();
            }
            EndBlock();
            WriteLine();
        }
        EndRegion();
    }

    public void GenerateEvents(WaylandInterface iface)
    {
        if (iface.Events.Count == 0) return;

        var className = iface.Name.ToPascal();

        BeginRegion();

        WriteLine("private unsafe void EnsureDispatcherRegistered()");
        BeginBlock();
        {
            WriteLine("lock (dispatcherLock)");
            BeginBlock();
            {
                WriteLine("if (dispatcherRegistered)");
                BeginBlock();
                {
                    WriteLine("return;");
                }
                EndBlock();
                WriteLine();
                WriteLine("// Allocate GCHandle to keep this object alive");
                WriteLine("gcHandle = GCHandle.Alloc(this, GCHandleType.Normal);");
                WriteLine();
                WriteLine("// Register the dispatcher with the Wayland proxy");
                WriteLine("var dataPtr = GCHandle.ToIntPtr(gcHandle);");
                WriteLine($"var result = WaylandNative.ProxyAddDispatcher(Handle, &DispatchEvent, dataPtr, IntPtr.Zero);");
                WriteLine("if (result != 0)");
                BeginBlock();
                {
                    WriteLine("gcHandle.Free();");
                    WriteLine($"throw new InvalidOperationException(\"Failed to add dispatcher to {iface.Name}\");");
                }
                EndBlock();
                WriteLine();
                WriteLine("dispatcherRegistered = true;");
            }
            EndBlock();
        }
        EndBlock();
        WriteLine();

        WriteLine("[UnmanagedCallersOnly]");
        WriteLine("private static unsafe int DispatchEvent(IntPtr userData, IntPtr target, uint opcode, WlMessage* message, WlArgument* args)");
        BeginBlock();
        {
            WriteLine("try");
            BeginBlock();
            {
                WriteLine("var handle = GCHandle.FromIntPtr(userData);");
                WriteLine($"var obj = ({className})handle.Target!;");
                WriteLine($"var display = obj.Display;");
                WriteLine();
                WriteLine("switch (opcode)");
                BeginBlock();
                {
                    for (int i = 0; i < iface.Events.Count; i++)
                    {
                        var evt = iface.Events[i];
                        WriteLine($"case {i}: // {evt.Name}");
                        indentLevel++;
                        GenerateDispatcherEventCase(evt, iface);
                        WriteLine("break;");
                        indentLevel--;
                    }
                    WriteLine("default:");
                    indentLevel++;
                    WriteLine("return -1;");
                    indentLevel--;
                }
                EndBlock();
                WriteLine();
                WriteLine("return 0;");
            }
            EndBlock();
            WriteLine("catch (Exception ex)");
            BeginBlock();
            {
                WriteLine("Console.Error.WriteLine($\"Error in event dispatcher: {ex}\");");
                WriteLine("return -1;");
            }
            EndBlock();
        }
        EndBlock();

        EndRegion();
    }

    private void GenerateDispatcherEventCase(WaylandEvent evt, WaylandInterface iface)
    {
        var eventName = evt.Name.ToPascal();
        WriteLine($"if (obj._on{eventName} != null)");
        BeginBlock();
        {
            // Extract arguments from WlArgument array
            for (int i = 0; i < evt.Args.Count; i++)
            {
                var arg = evt.Args[i];
                var argName = arg.Name.ToCamel();

                switch (arg.Type)
                {
                    case "int":
                        WriteLine($"var _{argName} = args[{i}].i;");
                        break;
                    case "uint":
                        WriteLine($"var _{argName} = args[{i}].u;");
                        break;
                    case "fixed":
                        WriteLine($"var _{argName} = args[{i}].f;");
                        break;
                    case "string":
                        WriteLine($"var _{argName} = Utf8StringMarshaller.ConvertToManaged(args[{i}].s);");
                        break;
                    case "object":
                        // Check if interface is specified
                        if (!string.IsNullOrEmpty(arg.Interface))
                        {
                            var interfaceType = arg.Interface.ToPascal();
                            WriteLine($"{interfaceType}? _{argName} = null;");
                            WriteLine($"if (args[{i}].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException(\"Received null object for non-nullable argument '{arg.Name}'\");");
                            WriteLine($"_{argName} = new {interfaceType}((IntPtr)args[{i}].o, obj.Display);");
                        }
                        else
                        {
                            // Generic object pointer
                            WriteLine($"var _{argName} = new {iface.Name.ToPascal()}((IntPtr)args[{i}].o, obj.Display);");
                        }
                        break;
                    case "new_id":
                        // Handle new_id if needed
                        if (!string.IsNullOrEmpty(arg.Interface))
                        {
                            var interfaceType = arg.Interface.ToPascal();
                            WriteLine($"{interfaceType}? _{argName} = null;");
                            WriteLine($"if (args[{i}].o == (WlObject*)IntPtr.Zero) throw new InvalidOperationException(\"Received null object for non-nullable argument '{arg.Name}'\");");
                            WriteLine($"_{argName} = new {interfaceType}((IntPtr)args[{i}].o, obj.Display);");
                        }
                        else
                        {
                            WriteLine($"var _{argName} = args[{i}].o;");
                        }
                        break;
                    case "array":
                        WriteLine($"var _{argName} = args[{i}].a;");
                        break;
                    case "fd":
                        WriteLine($"var _{argName} = args[{i}].h;");
                        break;
                }
            }

            // Invoke the delegate
            var parameters = string.Join(", ", evt.Args.Select(arg =>
            {
                if (arg.Type == "array")
                {
                    return $"WaylandMarshal.ToSpan(_{arg.Name.ToCamel()})";
                }
                return $"_{arg.Name.ToCamel()}";
            }));
            WriteLine($"obj._on{eventName}?.Invoke({parameters});");
        }
        EndBlock();
    }

    private void GenerateRequests(WaylandInterface iface)
    {
        if (iface.Requests.Count == 0) return;

        BeginRegion();
        foreach (WaylandRequest request in iface.Requests)
        {
            GenerateRequestMethod(request, iface);
        }
        EndRegion();
    }

    public void GenerateRequestMethod(WaylandRequest request, WaylandInterface iface)
    {
        var summary = EscapeXmlDoc(request.Description?.Summary ?? request.Name).CapitalizeFirst();
        var docs = EscapeXmlDoc(request.Description?.Text ?? request.Name);

        var docLines = docs.Split(new[] { Environment.NewLine }, StringSplitOptions.None);

        WriteLine("/// <summary>");
        WriteLine($"/// {summary}");
        WriteLine("/// <para>");
        foreach (var line in docLines)
        {
            WriteLine($"/// {line}<br/>");
        }
        WriteLine("/// </para>");
        WriteLine("/// </summary>");

        var methodName = request.Name.ToPascal();

        var parameters = new List<string>();
        var hasNewId = request.Args.Any(a => a.Type == "new_id");

        // Determine return type and extra parameters
        string returnType = "void";
        string? newIdInterface = null;
        bool isUntypedNewId = false;

        if (hasNewId)
        {
            var newIdArg = request.Args.First(a => a.Type == "new_id");
            newIdInterface = newIdArg.Interface;

            if (!string.IsNullOrEmpty(newIdInterface))
            {
                // Typed new_id (e.g. wl_compositor.create_surface)
                returnType = newIdInterface.ToPascal();
            }
            else
            {
                // Untyped new_id (e.g. wl_registry.bind)
                isUntypedNewId = true;

                // Add the implicit arguments required for untyped binding
                parameters.Add("string interfaceName");
                parameters.Add("uint version");
                returnType = "WaylandObject";
            }
        }

        foreach (var arg in request.Args.Where(a => a.Type != "new_id"))
        {
            var paramType = MapTypeToCSharp(arg.Type, arg.Interface, arg.AllowNull);
            parameters.Add($"{paramType} {arg.Name.ToCamel()}");
        }

        string requestDeclaration = $"{returnType} {methodName}({string.Join(", ", parameters)})";

        RequestDocumentation(iface, request, summary, docs, methodName, requestDeclaration);

        WriteLine("public unsafe " + requestDeclaration);
        BeginBlock();
        {
            WriteLine("CheckDisposed();");
            WriteLine();

            WriteLine($"var args = stackalloc WlArgument[{CalculateWireArgCount(request.Args)}];");

            int argIndex = 0;
            foreach (var arg in request.Args)
            {
                var argName = arg.Name.ToCamel();

                switch (arg.Type)
                {
                    case "int":
                    case "uint":
                    case "fd":
                        WriteLine($"args[{argIndex}].{GetWlArgumentField(arg.Type)} = {argName};");
                        argIndex++;
                        break;

                    case "fixed":
                        WriteLine($"args[{argIndex}].f = WaylandMarshal.ToFixed({argName});");
                        argIndex++;
                        break;

                    case "string":
                        WriteLine($"args[{argIndex}].s = Utf8StringMarshaller.ConvertToUnmanaged({argName});");
                        argIndex++;
                        break;

                    case "object":
                        WriteLine($"args[{argIndex}].o = (WlObject*)({argName}?.Handle ?? IntPtr.Zero);");
                        argIndex++;
                        break;

                    case "array":
                        WriteLine($"args[{argIndex}].a = {argName};");
                        argIndex++;
                        break;

                    case "new_id":
                        if (isUntypedNewId)
                        {
                            WriteLine($"// Untyped new_id expansion for {arg.Name}");
                            WriteLine($"args[{argIndex}].s = Utf8StringMarshaller.ConvertToUnmanaged(interfaceName);");
                            argIndex++;

                            WriteLine($"args[{argIndex}].u = version;");
                            argIndex++;

                            WriteLine($"args[{argIndex}].o = (WlObject*)IntPtr.Zero; // Placeholder for new ID");
                            argIndex++;
                        }
                        else
                        {
                            WriteLine($"args[{argIndex}].o = (WlObject*)IntPtr.Zero;");
                            argIndex++;
                        }
                        break;
                }
            }
            WriteLine();

            string interfacePtrExpr;
            string versionExpr;

            if (isUntypedNewId)
            {
                WriteLine($"WlInterface* targetInterface = (WlInterface*)WaylandInterfaces.GetInterfacePtr(interfaceName);");
                interfacePtrExpr = "targetInterface";
                versionExpr = "version";
            }
            else if (newIdInterface != null)
            {
                interfacePtrExpr = $"WaylandInterfaces.{newIdInterface.ToPascal()}";
                versionExpr = $"(uint)WaylandInterfaces.{newIdInterface.ToPascal()}->Version";
            }
            else
            {
                interfacePtrExpr = "(WlInterface*)IntPtr.Zero";
                versionExpr = "0";
            }

            var opcode = iface.Requests.IndexOf(request);
            WriteLine($"const uint opcode = {opcode};");
            WriteLine();

            WriteLine($"var newProxy = WaylandNative.ProxyMarshalArrayFlags(");
            indentLevel++;
            WriteLine("Handle,");
            WriteLine("opcode,");
            WriteLine($"{interfacePtrExpr},");
            WriteLine($"{versionExpr},");
            WriteLine("0,");
            WriteLine("(nint)args");
            indentLevel--;
            WriteLine(");");

            if (isUntypedNewId)
            {
                WriteLine();
                WriteLine("return new WaylandObject(newProxy, Display, interfaceName, version);");
            }
            else if (newIdInterface != null)
            {
                WriteLine();
                WriteLine($"return new {newIdInterface.ToPascal()}(newProxy, Display);");
            }
        }
        EndBlock();
        WriteLine();
    }

    private void RequestDocumentation(WaylandInterface iface, WaylandRequest request, string summary, string docs, string methodName, string requestDeclaration)
    {
        string urlMethodName = iface.Name.ToPascal() + "_" + methodName;

        string type = "";
        string since = "";

        if (request.Since > 0)
        {
            since = $"<span class='pill'>since {request.Since}</span>";
        }

        if (!string.IsNullOrEmpty(request.Type))
        {
            Assert(request.Type == "destructor");
            type = $"<span class='pill destructor'>Type: {request.Type}</span>";
        }

        md.WriteLine($"""
        <h3 class="decleration request">
            <a href="?id={urlMethodName}" id="{urlMethodName}">
                <span class='codicon codicon-symbol-method method'></span>
                {iface.Name.ToPascal()}.<span class="method">{methodName}</span>
            </a>
            {type}{since}
        </h3>
        """);
        md.WriteLine();
        md.WriteLine("```csharp");
        md.WriteLine(requestDeclaration);
        md.WriteLine("```");
        md.WriteLine();
        if (request.Args.Count > 0)
        {
            md.WriteLine("| Argument | Type | Description |");
            md.WriteLine("| --- | --- | --- |");
        }
        foreach (var arg in request.Args)
        {
            md.WriteLine($"| {arg.Name} | {arg.Type} | {arg.Summary.CapitalizeFirst()} |");
        }
        md.WriteLine();
        // TODO: param table
        md.WriteLine($"**{summary}**");
        md.WriteLine(docs);
    }

    private void Assert(bool condition, [CallerArgumentExpression("condition")] string? message = null)
    {
        if (!condition)
        {
            throw new InvalidOperationException($"Assertion failed: {message}");
        }
    }

    private int CalculateWireArgCount(List<WaylandArg> args)
    {
        int count = 0;
        foreach (var arg in args)
        {
            // Untyped new_id counts as 3 arguments on the wire (string + uint + new_id)
            if (arg.Type == "new_id" && string.IsNullOrEmpty(arg.Interface))
                count += 3;
            else
                count += 1;
        }
        return count;
    }

    private string GetWlArgumentField(string type)
    {
        return type switch
        {
            "int" => "i",
            "uint" => "u",
            "fixed" => "f",
            "string" => "s",
            "object" => "o",
            "new_id" => "o",
            "array" => "a",
            "fd" => "h",
            _ => "o"
        };
    }


    private string MapTypeToCSharp(string waylandType, string? interfaceName, string? allowNull)
    {
        var nullable = allowNull?.ToLower() == "true" ? "?" : "";

        return waylandType switch
        {
            "int" => "int",
            "uint" => "uint",
            "fixed" => "WlFixed",
            "string" => $"string{nullable}",
            "object" => !string.IsNullOrEmpty(interfaceName) ? $"{interfaceName.ToPascal()}{nullable}" : $"WaylandObject{nullable}",
            "new_id" => !string.IsNullOrEmpty(interfaceName) ? interfaceName.ToPascal() : "WaylandObject",
            "array" => $"byte[]{nullable}",
            "fd" => "int",
            _ => $"object{nullable}"
        };
    }


    private static string EscapeXmlDoc(string? text)
    {
        if (string.IsNullOrWhiteSpace(text)) return "";

        var lines = text.Split(separator, StringSplitOptions.None)
                        .Select(line => line.TrimStart());

        var trimmedText = string.Join(Environment.NewLine, lines);

        return trimmedText
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;");
    }

    public void WriteLine(string text = "")
    {
        if (string.IsNullOrEmpty(text))
        {
            sb.AppendLine();
        }
        else
        {
            sb.Append(new string(' ', indentLevel * 4));
            sb.AppendLine(text);
        }
    }

    private void BeginBlock()
    {
        WriteLine("{");
        indentLevel++;
    }

    private void EndBlock(string suffix = "")
    {
        indentLevel--;
        WriteLine("}" + suffix);
    }

    private void BeginRegion([CallerMemberName] string methodName = "")
    {
        WriteLine();
        WriteLine($"#region {methodName}");
        WriteLine();
    }

    private void EndRegion([CallerMemberName] string methodName = "")
    {
        WriteLine();
        WriteLine($"#endregion // {methodName}");
        WriteLine();
    }
}