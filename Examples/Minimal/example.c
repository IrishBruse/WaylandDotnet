#include <SDL3/SDL.h>
#include <SDL3/SDL_gpu.h>
#include <wayland-client.h>
#include <wayland-egl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "wayland/xdg-shell.h"
#include "wayland/wlr-layer-shell-unstable-v1.h"

/* Wayland objects */
static struct wl_display *wl_display = NULL;
static struct wl_registry *wl_registry = NULL;
static struct wl_compositor *wl_compositor = NULL;
static struct wl_shm *wl_shm = NULL;
static struct zwlr_layer_shell_v1 *layer_shell = NULL;
static struct wl_output *wl_output = NULL;
static struct wl_surface *wl_surface = NULL;
static struct zwlr_layer_surface_v1 *layer_surface = NULL;

/* SDL3 GPU objects */
static SDL_GPUDevice *gpu_device = NULL;

/* SDL objects - for events and custom surface */
static SDL_Window *sdl_window = NULL;

/* State */
static int window_width = 800;
static int window_height = 600;
static int done = 0;
static float rotation = 0.0f;

/* GPU Pipeline and buffers */
static SDL_GPUGraphicsPipeline *pipeline = NULL;
static SDL_GPUBuffer *vertex_buffer = NULL;

/* Registry listener */
static void registry_global(void *data, struct wl_registry *registry, uint32_t name, const char *interface, uint32_t version)
{
    if (strcmp(interface, "wl_compositor") == 0)
    {
        wl_compositor = wl_registry_bind(registry, name, &wl_compositor_interface, 4);
    }
    else if (strcmp(interface, "wl_shm") == 0)
    {
        wl_shm = wl_registry_bind(registry, name, &wl_shm_interface, 1);
    }
    else if (strcmp(interface, "zwlr_layer_shell_v1") == 0)
    {
        layer_shell = wl_registry_bind(registry, name, &zwlr_layer_shell_v1_interface, 4);
    }
    else if (strcmp(interface, "wl_output") == 0)
    {
        if (!wl_output)
        {
            wl_output = wl_registry_bind(registry, name, &wl_output_interface, 4);
        }
    }
}

static void registry_global_remove(void *data, struct wl_registry *registry, uint32_t name) {}

static const struct wl_registry_listener registry_listener = {
    .global = registry_global,
    .global_remove = registry_global_remove,
};

/* Layer surface listener */
static void layer_surface_configure(void *data, struct zwlr_layer_surface_v1 *surface,
                                    uint32_t serial, uint32_t w, uint32_t h)
{
    printf("Layer surface configure: %ux%u\n", w, h);
    window_width = w;
    window_height = h;

    /* Update SDL window size to match the new surface size */
    if (sdl_window)
    {
        SDL_SetWindowSize(sdl_window, w, h);
    }

    zwlr_layer_surface_v1_ack_configure(surface, serial);
}

static void layer_surface_closed(void *data, struct zwlr_layer_surface_v1 *surface)
{
    printf("Layer surface closed\n");
    done = 1;
}

static const struct zwlr_layer_surface_v1_listener layer_surface_listener = {
    .configure = layer_surface_configure,
    .closed = layer_surface_closed,
};

static int init_wayland(void)
{
    wl_display = wl_display_connect(NULL);
    if (!wl_display)
    {
        fprintf(stderr, "Failed to connect to Wayland display\n");
        return 0;
    }

    wl_registry = wl_display_get_registry(wl_display);
    wl_registry_add_listener(wl_registry, &registry_listener, NULL);
    wl_display_roundtrip(wl_display);

    if (!wl_compositor || !wl_shm || !layer_shell)
    {
        fprintf(stderr, "Failed to bind required Wayland interfaces\n");
        return 0;
    }

    printf("Wayland initialized\n");
    return 1;
}

static int init_sdl_gpu(void)
{
    /* Create SDL3 GPU device */
    gpu_device = SDL_CreateGPUDevice(SDL_GPU_SHADERFORMAT_SPIRV, true, NULL);
    if (!gpu_device)
    {
        fprintf(stderr, "Failed to create SDL GPU device: %s\n", SDL_GetError());
        return 0;
    }

    printf("SDL GPU device created\n");
    return 1;
}

static int create_layer_shell_surface(void)
{
    /* Create surface */
    wl_surface = wl_compositor_create_surface(wl_compositor);
    if (!wl_surface)
    {
        fprintf(stderr, "Failed to create surface\n");
        return 0;
    }

    /* Get layer surface role */
    layer_surface = zwlr_layer_shell_v1_get_layer_surface(
        layer_shell, wl_surface, wl_output,
        ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY, "sdl3-overlay");

    if (!layer_surface)
    {
        fprintf(stderr, "Failed to create layer surface\n");
        wl_surface_destroy(wl_surface);
        return 0;
    }

    zwlr_layer_surface_v1_add_listener(layer_surface, &layer_surface_listener, NULL);
    zwlr_layer_surface_v1_set_size(layer_surface, window_width, window_height);
    zwlr_layer_surface_v1_set_anchor(layer_surface,
                                     ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |
                                         ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT |
                                         ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT |
                                         ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM);
    zwlr_layer_surface_v1_set_exclusive_zone(layer_surface, -1);
    zwlr_layer_surface_v1_set_keyboard_interactivity(layer_surface, ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_EXCLUSIVE);

    wl_surface_commit(wl_surface);
    wl_display_roundtrip(wl_display);

    printf("Layer surface created\n");
    return 1;
}

static int create_sdl_window(void)
{
    /* Create SDL window that wraps the custom Wayland surface */
    SDL_PropertiesID props = SDL_CreateProperties();
    SDL_SetPointerProperty(props, SDL_PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER, wl_surface);
    SDL_SetBooleanProperty(props, SDL_PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN, true);
    SDL_SetNumberProperty(props, SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER, window_width);
    SDL_SetNumberProperty(props, SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER, window_height);
    SDL_SetBooleanProperty(props, SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN, false); /* Make it visible */

    sdl_window = SDL_CreateWindowWithProperties(props);
    SDL_DestroyProperties(props);

    if (!sdl_window)
    {
        fprintf(stderr, "Failed to create SDL window: %s\n", SDL_GetError());
        return 0;
    }

    /* Show the window */
    SDL_ShowWindow(sdl_window);

    printf("SDL window created for custom surface\n");
    return 1;
}

static int claim_window_for_gpu(void)
{
    /* Claim the window for GPU rendering */
    if (!SDL_ClaimWindowForGPUDevice(gpu_device, sdl_window))
    {
        fprintf(stderr, "Failed to claim window for GPU: %s\n", SDL_GetError());
        return 0;
    }

    printf("Window claimed for GPU rendering\n");
    return 1;
}

/* Compiled SPIR-V shaders */
static const unsigned char triangle_vert_spv[] = {
    0x03, 0x02, 0x23, 0x07, 0x00, 0x00, 0x01, 0x00, 0x0b, 0x00, 0x08, 0x00,
    0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x47, 0x4c, 0x53, 0x4c, 0x2e, 0x73, 0x74, 0x64, 0x2e, 0x34, 0x35, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00,
    0x3c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00,
    0xc2, 0x01, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x05, 0x00, 0x06, 0x00,
    0x09, 0x00, 0x00, 0x00, 0x55, 0x6e, 0x69, 0x66, 0x6f, 0x72, 0x6d, 0x42,
    0x75, 0x66, 0x66, 0x65, 0x72, 0x00, 0x00, 0x00, 0x06, 0x00, 0x06, 0x00,
    0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0x6f, 0x74, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00,
    0x0b, 0x00, 0x00, 0x00, 0x75, 0x62, 0x6f, 0x00, 0x05, 0x00, 0x03, 0x00,
    0x12, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00,
    0x19, 0x00, 0x00, 0x00, 0x72, 0x6f, 0x74, 0x00, 0x05, 0x00, 0x03, 0x00,
    0x25, 0x00, 0x00, 0x00, 0x70, 0x6f, 0x73, 0x00, 0x05, 0x00, 0x05, 0x00,
    0x28, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69,
    0x6f, 0x6e, 0x00, 0x00, 0x05, 0x00, 0x06, 0x00, 0x2f, 0x00, 0x00, 0x00,
    0x67, 0x6c, 0x5f, 0x50, 0x65, 0x72, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78,
    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x06, 0x00, 0x2f, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x67, 0x6c, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74,
    0x69, 0x6f, 0x6e, 0x00, 0x06, 0x00, 0x07, 0x00, 0x2f, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x67, 0x6c, 0x5f, 0x50, 0x6f, 0x69, 0x6e, 0x74,
    0x53, 0x69, 0x7a, 0x65, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x07, 0x00,
    0x2f, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x67, 0x6c, 0x5f, 0x43,
    0x6c, 0x69, 0x70, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x00,
    0x06, 0x00, 0x07, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x67, 0x6c, 0x5f, 0x43, 0x75, 0x6c, 0x6c, 0x44, 0x69, 0x73, 0x74, 0x61,
    0x6e, 0x63, 0x65, 0x00, 0x05, 0x00, 0x03, 0x00, 0x31, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0x3a, 0x00, 0x00, 0x00,
    0x66, 0x72, 0x61, 0x67, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x04, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x43, 0x6f,
    0x6c, 0x6f, 0x72, 0x00, 0x47, 0x00, 0x03, 0x00, 0x09, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00, 0x09, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x47, 0x00, 0x04, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x0b, 0x00, 0x00, 0x00,
    0x22, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
    0x28, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x47, 0x00, 0x03, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x48, 0x00, 0x05, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00,
    0x2f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00, 0x2f, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x48, 0x00, 0x05, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x0b, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
    0x3a, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x47, 0x00, 0x04, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x13, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x21, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x16, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x03, 0x00, 0x09, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
    0x0a, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x15, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00,
    0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
    0x0e, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x17, 0x00, 0x04, 0x00, 0x16, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x18, 0x00, 0x04, 0x00, 0x17, 0x00, 0x00, 0x00,
    0x16, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00,
    0x2b, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x3f, 0x2b, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
    0x24, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x04, 0x00, 0x27, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x16, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x27, 0x00, 0x00, 0x00,
    0x28, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00,
    0x2b, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x15, 0x00, 0x04, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x2c, 0x00, 0x00, 0x00,
    0x2d, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x04, 0x00,
    0x2e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00,
    0x1e, 0x00, 0x06, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x04, 0x00, 0x30, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x2f, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x30, 0x00, 0x00, 0x00,
    0x31, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
    0x36, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00,
    0x17, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x39, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
    0x39, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x04, 0x00, 0x3b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x3b, 0x00, 0x00, 0x00,
    0x3c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x36, 0x00, 0x05, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x3b, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x12, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x3b, 0x00, 0x04, 0x00, 0x24, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x0e, 0x00, 0x00, 0x00,
    0x0f, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
    0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
    0x0f, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x11, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x11, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x0e, 0x00, 0x00, 0x00,
    0x13, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
    0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
    0x13, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x15, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
    0x14, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x12, 0x00, 0x00, 0x00,
    0x15, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x1a, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
    0x7f, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,
    0x1b, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x1d, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x50, 0x00, 0x05, 0x00, 0x16, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
    0x1a, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x50, 0x00, 0x05, 0x00,
    0x16, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00,
    0x1e, 0x00, 0x00, 0x00, 0x50, 0x00, 0x05, 0x00, 0x17, 0x00, 0x00, 0x00,
    0x23, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
    0x3e, 0x00, 0x03, 0x00, 0x19, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00,
    0x3d, 0x00, 0x04, 0x00, 0x17, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,
    0x19, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x16, 0x00, 0x00, 0x00,
    0x29, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x91, 0x00, 0x05, 0x00,
    0x16, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,
    0x29, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x25, 0x00, 0x00, 0x00,
    0x2a, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x16, 0x00, 0x00, 0x00,
    0x32, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x51, 0x00, 0x05, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x51, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x34, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x50, 0x00, 0x07, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00,
    0x33, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x1f, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x36, 0x00, 0x00, 0x00,
    0x37, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
    0x3e, 0x00, 0x03, 0x00, 0x37, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00,
    0x3d, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00,
    0x3c, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x3a, 0x00, 0x00, 0x00,
    0x3d, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x01, 0x00, 0x38, 0x00, 0x01, 0x00};

static const unsigned char triangle_frag_spv[] = {
    0x03, 0x02, 0x23, 0x07, 0x00, 0x00, 0x01, 0x00, 0x0b, 0x00, 0x08, 0x00,
    0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x47, 0x4c, 0x53, 0x4c, 0x2e, 0x73, 0x74, 0x64, 0x2e, 0x34, 0x35, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00,
    0x09, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x03, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00,
    0x02, 0x00, 0x00, 0x00, 0xc2, 0x01, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x05, 0x00, 0x09, 0x00, 0x00, 0x00, 0x6f, 0x75, 0x74, 0x43,
    0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00,
    0x0c, 0x00, 0x00, 0x00, 0x66, 0x72, 0x61, 0x67, 0x43, 0x6f, 0x6c, 0x6f,
    0x72, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x09, 0x00, 0x00, 0x00,
    0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
    0x0c, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x21, 0x00, 0x03, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x16, 0x00, 0x03, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00,
    0x07, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x09, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00,
    0x0a, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x04, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x0a, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x0b, 0x00, 0x00, 0x00,
    0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f,
    0x36, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
    0x05, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00,
    0x0d, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x51, 0x00, 0x05, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x51, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x51, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
    0x0d, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x50, 0x00, 0x07, 0x00,
    0x07, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
    0x3e, 0x00, 0x03, 0x00, 0x09, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
    0xfd, 0x00, 0x01, 0x00, 0x38, 0x00, 0x01, 0x00};

static int create_triangle_pipeline(void)
{
    /* Create vertex shader */
    SDL_GPUShaderCreateInfo vert_info = {
        .code = triangle_vert_spv,
        .code_size = sizeof(triangle_vert_spv),
        .entrypoint = "main",
        .format = SDL_GPU_SHADERFORMAT_SPIRV,
        .stage = SDL_GPU_SHADERSTAGE_VERTEX,
        .num_uniform_buffers = 1,
        .num_samplers = 0,
        .num_storage_textures = 0,
        .num_storage_buffers = 0};

    SDL_GPUShader *vertex_shader = SDL_CreateGPUShader(gpu_device, &vert_info);
    if (!vertex_shader)
    {
        fprintf(stderr, "Failed to create vertex shader: %s\n", SDL_GetError());
        return 0;
    }

    /* Create fragment shader */
    SDL_GPUShaderCreateInfo frag_info = {
        .code = triangle_frag_spv,
        .code_size = sizeof(triangle_frag_spv),
        .entrypoint = "main",
        .format = SDL_GPU_SHADERFORMAT_SPIRV,
        .stage = SDL_GPU_SHADERSTAGE_FRAGMENT,
        .num_uniform_buffers = 0,
        .num_samplers = 0,
        .num_storage_textures = 0,
        .num_storage_buffers = 0};

    SDL_GPUShader *fragment_shader = SDL_CreateGPUShader(gpu_device, &frag_info);
    if (!fragment_shader)
    {
        fprintf(stderr, "Failed to create fragment shader: %s\n", SDL_GetError());
        SDL_ReleaseGPUShader(gpu_device, vertex_shader);
        return 0;
    }

    /* Create graphics pipeline */
    SDL_GPUVertexAttribute vertex_attributes[] = {
        {.location = 0,
         .format = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT2,
         .offset = 0,
         .buffer_slot = 0},
        {.location = 1,
         .format = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT3,
         .offset = sizeof(float) * 2,
         .buffer_slot = 0}};

    SDL_GPUVertexBufferDescription vertex_buffer_desc = {
        .slot = 0,
        .pitch = sizeof(float) * 5,
        .input_rate = SDL_GPU_VERTEXINPUTRATE_VERTEX,
        .instance_step_rate = 0};

    SDL_GPUColorTargetDescription color_target_desc = {
        .format = SDL_GetGPUSwapchainTextureFormat(gpu_device, sdl_window)};

    SDL_GPUGraphicsPipelineCreateInfo pipeline_info = {
        .vertex_shader = vertex_shader,
        .fragment_shader = fragment_shader,
        .vertex_input_state = {
            .num_vertex_buffers = 1,
            .vertex_buffer_descriptions = &vertex_buffer_desc,
            .num_vertex_attributes = 2,
            .vertex_attributes = vertex_attributes},
        .primitive_type = SDL_GPU_PRIMITIVETYPE_TRIANGLELIST,
        .rasterizer_state = {.fill_mode = SDL_GPU_FILLMODE_FILL, .cull_mode = SDL_GPU_CULLMODE_NONE},
        .multisample_state = {.sample_count = SDL_GPU_SAMPLECOUNT_1, .sample_mask = 0},
        .depth_stencil_state = {.compare_op = SDL_GPU_COMPAREOP_ALWAYS},
        .target_info = {.num_color_targets = 1, .color_target_descriptions = &color_target_desc}};

    pipeline = SDL_CreateGPUGraphicsPipeline(gpu_device, &pipeline_info);

    SDL_ReleaseGPUShader(gpu_device, vertex_shader);
    SDL_ReleaseGPUShader(gpu_device, fragment_shader);

    if (!pipeline)
    {
        fprintf(stderr, "Failed to create graphics pipeline: %s\n", SDL_GetError());
        return 0;
    }

    /* Create vertex buffer */
    /* Triangle vertices: position (x,y) + color (r,g,b) */
    float vertices[] = {
        /* Top vertex - Red */
        0.0f, 0.5f, 1.0f, 0.0f, 0.0f,
        /* Bottom left - Green */
        -0.5f, -0.5f, 0.0f, 1.0f, 0.0f,
        /* Bottom right - Blue */
        0.5f, -0.5f, 0.0f, 0.0f, 1.0f};

    SDL_GPUBufferCreateInfo buffer_info = {
        .size = sizeof(vertices),
        .usage = SDL_GPU_BUFFERUSAGE_VERTEX};

    vertex_buffer = SDL_CreateGPUBuffer(gpu_device, &buffer_info);
    if (!vertex_buffer)
    {
        fprintf(stderr, "Failed to create vertex buffer: %s\n", SDL_GetError());
        return 0;
    }

    /* Upload vertex data */
    SDL_GPUTransferBufferCreateInfo transfer_info = {
        .size = sizeof(vertices),
        .usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD};

    SDL_GPUTransferBuffer *transfer_buffer = SDL_CreateGPUTransferBuffer(gpu_device, &transfer_info);
    if (!transfer_buffer)
    {
        fprintf(stderr, "Failed to create transfer buffer: %s\n", SDL_GetError());
        return 0;
    }

    void *data = SDL_MapGPUTransferBuffer(gpu_device, transfer_buffer, false);
    memcpy(data, vertices, sizeof(vertices));
    SDL_UnmapGPUTransferBuffer(gpu_device, transfer_buffer);

    SDL_GPUCommandBuffer *cmd_buf = SDL_AcquireGPUCommandBuffer(gpu_device);
    SDL_GPUCopyPass *copy_pass = SDL_BeginGPUCopyPass(cmd_buf);

    SDL_GPUTransferBufferLocation src = {
        .transfer_buffer = transfer_buffer,
        .offset = 0};

    SDL_GPUBufferRegion dst = {
        .buffer = vertex_buffer,
        .offset = 0,
        .size = sizeof(vertices)};

    SDL_UploadToGPUBuffer(copy_pass, &src, &dst, false);
    SDL_EndGPUCopyPass(copy_pass);
    SDL_SubmitGPUCommandBuffer(cmd_buf);

    SDL_ReleaseGPUTransferBuffer(gpu_device, transfer_buffer);

    printf("Triangle pipeline created\n");
    return 1;
}

static int init_sdl(void)
{
    /* Set SDL to use the existing Wayland display */
    SDL_SetPointerProperty(SDL_GetGlobalProperties(), SDL_PROP_GLOBAL_VIDEO_WAYLAND_WL_DISPLAY_POINTER, wl_display);

    if (!SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS))
    {
        fprintf(stderr, "Failed to initialize SDL\n");
        return 0;
    }

    printf("SDL initialized\n");
    return 1;
}

static void handle_events(void)
{
    SDL_Event event;
    while (SDL_PollEvent(&event))
    {
        switch (event.type)
        {
        case SDL_EVENT_QUIT:
            done = 1;
            break;
        case SDL_EVENT_KEY_DOWN:
            if (event.key.key == SDLK_ESCAPE)
            {
                done = 1;
            }
            break;
        default:
            break;
        }
    }

    wl_display_flush(wl_display);
    wl_display_dispatch_pending(wl_display);
}

static void render(void)
{
    /* Update rotation */
    rotation += 0.02f;

    /* Begin command buffer */
    SDL_GPUCommandBuffer *cmd_buf = SDL_AcquireGPUCommandBuffer(gpu_device);
    if (!cmd_buf)
    {
        fprintf(stderr, "Failed to acquire command buffer: %s\n", SDL_GetError());
        return;
    }

    /* Get a texture to render to */
    SDL_GPUTexture *render_target = NULL;
    Uint32 texture_width, texture_height;

    if (!SDL_WaitAndAcquireGPUSwapchainTexture(cmd_buf, sdl_window, &render_target, &texture_width, &texture_height))
    {
        fprintf(stderr, "Failed to acquire swapchain texture: %s\n", SDL_GetError());
        SDL_CancelGPUCommandBuffer(cmd_buf);
        return;
    }

    /* Skip rendering if texture is NULL (window minimized, etc.) */
    if (!render_target)
    {
        SDL_SubmitGPUCommandBuffer(cmd_buf);
        return;
    }

    /* Begin render pass with a semi-transparent dark overlay */
    SDL_GPUColorTargetInfo color_target = {
        .texture = render_target,
        .mip_level = 0,
        .layer_or_depth_plane = 0,
        .clear_color = {0.0f, 0.0f, 0.0f, 0.5f}, /* 50% transparent black */
        .load_op = SDL_GPU_LOADOP_CLEAR,
        .store_op = SDL_GPU_STOREOP_STORE};

    SDL_GPURenderPass *render_pass = SDL_BeginGPURenderPass(cmd_buf, &color_target, 1, NULL);

    /* Bind pipeline and draw triangle */
    SDL_BindGPUGraphicsPipeline(render_pass, pipeline);

    /* Push rotation constant - using 16 bytes for std140 alignment */
    float uniform_data[4] = {rotation, 0.0f, 0.0f, 0.0f};
    SDL_PushGPUVertexUniformData(cmd_buf, 0, uniform_data, sizeof(uniform_data));

    /* Bind vertex buffer */
    SDL_GPUBufferBinding vertex_binding = {
        .buffer = vertex_buffer,
        .offset = 0};
    SDL_BindGPUVertexBuffers(render_pass, 0, &vertex_binding, 1);

    /* Draw the triangle */
    SDL_DrawGPUPrimitives(render_pass, 3, 1, 0, 0);

    /* End render pass */
    SDL_EndGPURenderPass(render_pass);

    /* Submit command buffer */
    SDL_SubmitGPUCommandBuffer(cmd_buf);
}

static void cleanup(void)
{
    if (vertex_buffer)
    {
        SDL_ReleaseGPUBuffer(gpu_device, vertex_buffer);
    }

    if (pipeline)
    {
        SDL_ReleaseGPUGraphicsPipeline(gpu_device, pipeline);
    }

    if (gpu_device && sdl_window)
    {
        SDL_ReleaseWindowFromGPUDevice(gpu_device, sdl_window);
    }

    if (gpu_device)
    {
        SDL_DestroyGPUDevice(gpu_device);
    }

    if (sdl_window)
    {
        SDL_DestroyWindow(sdl_window);
    }

    SDL_Quit();

    if (layer_surface)
    {
        zwlr_layer_surface_v1_destroy(layer_surface);
    }

    if (wl_surface)
    {
        wl_surface_destroy(wl_surface);
    }

    if (layer_shell)
    {
        zwlr_layer_shell_v1_destroy(layer_shell);
    }

    if (wl_output)
    {
        wl_output_destroy(wl_output);
    }

    if (wl_shm)
    {
        wl_shm_destroy(wl_shm);
    }

    if (wl_compositor)
    {
        wl_compositor_destroy(wl_compositor);
    }

    if (wl_registry)
    {
        wl_registry_destroy(wl_registry);
    }

    if (wl_display)
    {
        wl_display_disconnect(wl_display);
    }
}

int run()
{
    printf("SDL3_GPU Wayland Layer Shell Overlay\n");

    if (!init_wayland())
    {
        fprintf(stderr, "Failed to init Wayland\n");
        return 1;
    }

    if (!init_sdl())
    {
        fprintf(stderr, "Failed to init SDL\n");
        cleanup();
        return 1;
    }

    if (!init_sdl_gpu())
    {
        fprintf(stderr, "Failed to init SDL GPU\n");
        cleanup();
        return 1;
    }

    if (!create_layer_shell_surface())
    {
        fprintf(stderr, "Failed to create layer shell surface\n");
        cleanup();
        return 1;
    }

    if (!create_sdl_window())
    {
        fprintf(stderr, "Failed to create SDL window\n");
        cleanup();
        return 1;
    }

    if (!claim_window_for_gpu())
    {
        fprintf(stderr, "Failed to claim window for GPU\n");
        cleanup();
        return 1;
    }

    if (!create_triangle_pipeline())
    {
        fprintf(stderr, "Failed to create triangle pipeline\n");
        cleanup();
        return 1;
    }

    /* Recommit the surface after SDL window is created and shown */
    wl_surface_commit(wl_surface);
    wl_display_flush(wl_display);

    printf("All initialized. Press ESC to exit.\n");

    while (!done)
    {
        handle_events();
        render();
        SDL_Delay(16);
    }

    cleanup();
    printf("Exited cleanly\n");
    return 0;
}

int main(int argc, char *argv[])
{
    return run();
}